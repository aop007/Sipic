CCS PCD C Compiler, Version 4.104, 5967               01-févr.-12 21:40

               Filename: Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\main.lst

               ROM used: 12462 bytes (76%)
                         Largest free fragment is 3922
               RAM used: 419 (45%) at main() level
                         717 (77%) worst case
               Stack:    13 worst case (10 in main + 3 for interrupts)

*
0000:  GOTO    2E96
*
0006:  DATA    34,08,00
0008:  DATA    16,08,00
000A:  DATA    34,08,00
000C:  DATA    34,08,00
000E:  DATA    34,08,00
0010:  DATA    34,08,00
0012:  DATA    34,08,00
0014:  DATA    34,08,00
0016:  DATA    34,08,00
0018:  DATA    34,08,00
001A:  DATA    74,07,00
001C:  DATA    34,08,00
001E:  DATA    34,08,00
0020:  DATA    34,08,00
0022:  DATA    70,04,00
0024:  DATA    34,08,00
0026:  DATA    C2,07,00
0028:  DATA    DE,07,00
002A:  DATA    FA,07,00
002C:  DATA    34,08,00
002E:  DATA    34,08,00
0030:  DATA    34,08,00
0032:  DATA    1E,03,00
0034:  DATA    34,08,00
0036:  DATA    34,08,00
0038:  DATA    34,08,00
003A:  DATA    34,08,00
003C:  DATA    34,08,00
003E:  DATA    FC,03,00
0040:  DATA    B8,02,00
0042:  DATA    34,08,00
0044:  DATA    34,08,00
0046:  DATA    34,08,00
0048:  DATA    34,08,00
004A:  DATA    34,08,00
004C:  DATA    34,08,00
004E:  DATA    34,08,00
0050:  DATA    34,08,00
0052:  DATA    34,08,00
0054:  DATA    34,08,00
0056:  DATA    34,08,00
0058:  DATA    34,08,00
005A:  DATA    34,08,00
005C:  DATA    34,08,00
005E:  DATA    34,08,00
0060:  DATA    34,08,00
0062:  DATA    34,08,00
0064:  DATA    A6,07,00
0066:  DATA    34,08,00
0068:  DATA    34,08,00
006A:  DATA    34,08,00
006C:  DATA    34,08,00
006E:  DATA    34,08,00
0070:  DATA    34,08,00
0072:  DATA    34,08,00
0074:  DATA    34,08,00
0076:  DATA    34,08,00
0078:  DATA    34,08,00
007A:  DATA    34,08,00
007C:  DATA    34,08,00
007E:  DATA    34,08,00
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
*
12A8:  MOV     W0,W5
12AA:  MOV     W1,W6
12AC:  MOV     W5,W0
12AE:  MOV     W6,W1
12B0:  MOV     #100,W2
12B2:  MOV     #477E,W3
12B4:  CALL    C78
*
12C8:  MOV     W0,W5
12CA:  MOV     W1,W6
12CC:  MOV     W5,W0
12CE:  MOV     W6,W1
12D0:  MOV     #0,W2
12D2:  MOV     #4270,W3
12D4:  CALL    C78
*
12EE:  MOV     W0,W5
12F0:  MOV     W1,W6
12F2:  BSET.B  43.0
12F4:  MOV     W5,W0
12F6:  MOV     W6,W1
12F8:  MOV     #0,W2
12FA:  MOV     #3F80,W3
12FC:  CALL    E20
1300:  MOV     W0,W5
1302:  MOV     W1,W6
*
13F4:  MOV     W0,W5
13F6:  MOV     W1,W6
13F8:  MOV     W5,W0
13FA:  MOV     W6,W1
13FC:  MOV     #0,W2
13FE:  MOV     #437F,W3
1400:  CALL    C78
1404:  MOV     W0,W5
1406:  MOV     W1,W6
1408:  BSET.B  43.0
140A:  MOV     W5,W0
140C:  MOV     W6,W1
140E:  MOV     9B2,W2
1410:  MOV     9B4,W3
1412:  CALL    E20
*
17B6:  MOV     W0,W5
17B8:  MOV     W1,W6
17BA:  MOV     W5,W0
17BC:  MOV     W6,W1
17BE:  MOV     98E,W2
17C0:  MOV     990,W3
17C2:  CALL    FC0
17C6:  MOV     W0,W5
17C8:  MOV     W1,W6
17CA:  MOV     W5,W0
17CC:  MOV     W6,W1
17CE:  MOV     #0,W2
17D0:  MOV     #42C8,W3
17D2:  CALL    C78
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #ifndef __MAIN__ 
.................... #define __MAIN__ 
....................  
.................... #include <30F3011.h> 
.................... //////// Standard Header file for the DSPIC30F3011 device //////////////// 
.................... #device DSPIC30F3011 
.................... #list 
....................  
.................... #define USE_UART_2 
....................  
.................... #device *=16 ICD=TRUE 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES FRC_PLL16              	//Internal Fast RC oscillator with 16X PLL 
.................... //#FUSES FRC                   	//Internal Fast RC Oscillator 
.................... #FUSES NOCKSFSM              	//Clock Switching is disabled, fail Safe clock monitor is disabled 
.................... #FUSES WPSB16                	//Watch Dog Timer PreScalar B 1:16 
.................... #FUSES WPSA512               	//Watch Dog Timer PreScalar A 1:512 
.................... #FUSES PUT64                 	//Power On Reset Timer value 64ms 
.................... #FUSES NOBROWNOUT            	//No brownout reset  
.................... //#FUSES BORV27                	//Brownout reset at 2.7V 
.................... #FUSES LPOL_HIGH             	//Low-Side Transistors Polarity is Active-High (PWM 0,2,4 and 6) 
.................... 								//PWM module low side output pins have active high output polar 
.................... #FUSES HPOL_HIGH             	//High-Side Transistors Polarity is Active-High (PWM 1,3,5 and 7) 
.................... 								//PWM module high side output pins have active high output polarity 
.................... #FUSES NOPWMPIN              	//PWM outputs drive active state upon Reset 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOCOE                 	//Device will reset into operational mode 
.................... #FUSES ICSP1                 	//ICD uses PGC1/PGD1 pins 
....................  
.................... #define  DSPIC30F_OSC  118662200     //29665550 
....................  
.................... #use delay(clock= DSPIC30F_OSC) 
*
0AEC:  CP0     W0
0AEE:  BTSC.B  42.1
0AF0:  BRA     AFE
0AF2:  REPEAT  #33DB
0AF4:  NOP     
0AF6:  REPEAT  #3FFF
0AF8:  NOP     
0AFA:  DEC     W0,W0
0AFC:  BRA     AEC
0AFE:  RETURN  
....................  
.................... #ifdef USE_UART_2 
.................... #use rs232(UART2,baud=115200,parity=N,bits=8) 
.................... #endif 
....................  
.................... //IO Definition 
.................... #define LED_B     PIN_B0 
.................... #define LED_G     PIN_B1 
.................... #define PUSH  	  PIN_B2 
.................... #define SYNC  	  PIN_B3 
.................... #define ENCA 	  PIN_B4 
.................... #define ENCB 	  PIN_B5 
.................... #define AMB_LUM   PIN_B6 
.................... #define LED_R     PIN_B7 
.................... #define SHDN_5V   PIN_B8 
....................  
.................... #define SOSCI     PIN_C13 
.................... #define SOSCO     PIN_C14 
....................  
.................... #define LOAD_CTRL PIN_E0 
.................... #define CHIME     PIN_E2 
.................... #define SCK		  PIN_E3 
.................... #define SISO	  PIN_E4 
.................... #define STB		  PIN_E5 
....................  
.................... //#define SDA       PIN_F0 
.................... //#define SCL       PIN_F1 
.................... #define RX   	  PIN_F4 
.................... #define TX   	  PIN_F5 
....................  
....................  
.................... //#define DEBUG	  PIN_D3 
....................  
.................... //RTCC CLOCK DEFINITION 
.................... #word TMR1  = 0x0100 
.................... #word PR1   = 0x0102 
.................... #word T1CON = 0x0104  
....................  
.................... #bit T1TON   = T1CON.15 
.................... #bit T1TCS   = T1CON.1 
.................... #bit T1TGATE = T1CON.6 
.................... #bit T1TSYNC = T1CON.2 
....................  
.................... #word INTCON1 = 0x0080  
.................... #word TMR2	  = 0x0106 
.................... #word TMR3H   = 0x0108 
....................  
.................... #bit  ADDRERR = INTCON1.3 
....................  
.................... #define max(a,b) a > b ? a : b 
.................... #define min(a,b) ((a) > (b) ? (a) : (b)) 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
.................... } WORD_VAL; 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)    (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... #ifdef USE_UART_2 
.................... #define TRANSMIT_TLV_ENABLED 
.................... #endif 
....................  
.................... int16 previousPOSCNT = -1; 
.................... int16 currentPOSCNT  = 0; 
....................  
.................... enum ALARM_STATE 
.................... { 
....................     ALARM_MASTER_OFF = 0, 
....................     ALARM_STANDBY, 
....................     ALARM_RAMP, 
....................     ALARM_WAKE, 
....................     ALARM_SNOOZE, 
....................     ALARM_SNOOZE_RAMP, 
....................     ALARM_LAMP_ON 
.................... }; 
....................  
.................... typedef struct  
.................... { 
.................... 	unsigned long  SnoozeBinaryTime; 
....................     unsigned long  AlarmBinaryTime; 
....................     unsigned long  CurrentBinaryTime; 
....................                                                         /* Stats                                    */ 
....................     unsigned long  MainLoops; 
....................     unsigned long  PulseWidthErr; 
....................     unsigned long  ButtonDownTick;  
....................     ALARM_STATE    AlarmState; 
....................      
.................... //    unsigned long  ; 
.................... } ALARM_DATA; 
....................  
.................... ALARM_DATA alarmData; 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
*
107E:  MOV     W5,[W15++]
1080:  MOV     W6,[W15++]
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
1082:  BCLR.B  9F7.0
....................    y = x; 
1084:  PUSH    9F2
1086:  POP     9F8
1088:  PUSH    9F4
108A:  POP     9FA
....................  
....................    if (x < 0) 
108C:  MOV     9F2,W0
108E:  MOV     9F4,W1
1090:  MOV     #0,W2
1092:  MOV     #0,W3
1094:  CALL    D8C
1098:  BRA     NC,109E
....................    { 
....................       s = 1; 
109A:  BSET.B  9F7.0
....................       y = -y; 
109C:  BTG.B   9FB.7
....................    } 
....................  
....................    if (y <= 32768.0) 
109E:  MOV     9F8,W0
10A0:  MOV     9FA,W1
10A2:  MOV     #0,W2
10A4:  MOV     #4700,W3
10A6:  CALL    D8C
10AA:  BRA     C,10AE
10AC:  BRA     NZ,10C0
....................   res = (float32)(unsigned int16)y; 
10AE:  MOV     9F8,W0
10B0:  MOV     9FA,W1
10B2:  CALL    DF4
10B6:  CALL    C3E
10BA:  MOV     W0,9FC
10BC:  MOV     W1,9FE
....................  
....................  else if (y < 10000000.0) 
10BE:  BRA     1152
10C0:  MOV     9F8,W0
10C2:  MOV     9FA,W1
10C4:  MOV     #9680,W2
10C6:  MOV     #4B18,W3
10C8:  CALL    D8C
10CC:  BRA     NC,114A
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
10CE:  MOV     9F8,W0
10D0:  MOV     9FA,W1
10D2:  MOV     #0,W2
10D4:  MOV     #4700,W3
10D6:  CALL    C78
10DA:  CALL    DF4
10DE:  MOV     W0,A00
....................       y = 32768.0*(y/32768.0 - (float32)l); 
10E0:  MOV     9F8,W0
10E2:  MOV     9FA,W1
10E4:  MOV     #0,W2
10E6:  MOV     #4700,W3
10E8:  CALL    C78
10EC:  MOV     W0,W5
10EE:  MOV     W1,W6
10F0:  MOV     A00,W0
10F2:  CALL    C3E
10F6:  BSET.B  43.0
10F8:  MOV     W0,W2
10FA:  MOV     W1,W3
10FC:  MOV     W5,W0
10FE:  MOV     W6,W1
1100:  CALL    E20
1104:  MOV     W0,W2
1106:  MOV     W1,W3
1108:  MOV     #0,W0
110A:  MOV     #4700,W1
110C:  CALL    FC0
1110:  MOV     W0,9F8
1112:  MOV     W1,9FA
....................   res = 32768.0*(float32)l; 
1114:  MOV     A00,W0
1116:  CALL    C3E
111A:  MOV     W0,W2
111C:  MOV     W1,W3
111E:  MOV     #0,W0
1120:  MOV     #4700,W1
1122:  CALL    FC0
1126:  MOV     W0,9FC
1128:  MOV     W1,9FE
....................   res += (float32)(unsigned int16)y; 
112A:  MOV     9F8,W0
112C:  MOV     9FA,W1
112E:  CALL    DF4
1132:  CALL    C3E
1136:  BCLR.B  43.0
1138:  MOV     W0,W2
113A:  MOV     W1,W3
113C:  MOV     9FC,W0
113E:  MOV     9FE,W1
1140:  CALL    E20
1144:  MOV     W0,9FC
1146:  MOV     W1,9FE
....................  } 
....................  
....................  else 
1148:  BRA     1152
....................   res = y; 
114A:  PUSH    9F8
114C:  POP     9FC
114E:  PUSH    9FA
1150:  POP     9FE
....................  
....................  y = y - (float32)(unsigned int16)y; 
1152:  MOV     9F8,W0
1154:  MOV     9FA,W1
1156:  CALL    DF4
115A:  CALL    C3E
115E:  BSET.B  43.0
1160:  MOV     W0,W2
1162:  MOV     W1,W3
1164:  MOV     9F8,W0
1166:  MOV     9FA,W1
1168:  CALL    E20
116C:  MOV     W0,9F8
116E:  MOV     W1,9FA
....................  
....................  if (s) 
1170:  BTSS.B  9F7.0
1172:  BRA     1176
....................   res = -res; 
1174:  BTG.B   9FF.7
....................  
....................  if (y != 0) 
1176:  MOV     9F8,W0
1178:  MOV     9FA,W1
117A:  MOV     #0,W2
117C:  MOV     #0,W3
117E:  CALL    D8C
1182:  BRA     Z,11BA
....................  { 
....................   if (s == 1 && n == 0) 
1184:  BTSS.B  9F7.0
1186:  BRA     119E
1188:  CP0.B   9F6
118A:  BRA     NZ,119E
....................    res -= 1.0; 
118C:  BSET.B  43.0
118E:  MOV     9FC,W0
1190:  MOV     9FE,W1
1192:  MOV     #0,W2
1194:  MOV     #3F80,W3
1196:  CALL    E20
119A:  MOV     W0,9FC
119C:  MOV     W1,9FE
....................  
....................   if (s == 0 && n == 1) 
119E:  BTSC.B  9F7.0
11A0:  BRA     11BA
11A2:  MOV     9F6,W4
11A4:  CP.B    W4L,#1
11A6:  BRA     NZ,11BA
....................    res += 1.0; 
11A8:  BCLR.B  43.0
11AA:  MOV     9FC,W0
11AC:  MOV     9FE,W1
11AE:  MOV     #0,W2
11B0:  MOV     #3F80,W3
11B2:  CALL    E20
11B6:  MOV     W0,9FC
11B8:  MOV     W1,9FE
....................  } 
....................  if (x == 0) 
11BA:  MOV     9F2,W0
11BC:  MOV     9F4,W1
11BE:  MOV     #0,W2
11C0:  MOV     #0,W3
11C2:  CALL    D8C
11C6:  BRA     NZ,11CC
....................     res = 0; 
11C8:  CLR     9FC
11CA:  CLR     9FE
....................  
....................  return (res); 
11CC:  MOV     9FC,W0
11CE:  MOV     9FE,W1
.................... } 
11D0:  MOV     [--W15],W6
11D2:  MOV     [--W15],W5
11D4:  RETURN  
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
11EA:  CLR.B   9F6
11EC:  PUSH    9EA
11EE:  POP     9F2
11F0:  PUSH    9EC
11F2:  POP     9F4
11F4:  CALL    107E
11F8:  MOV.D   W0,W0
.................... } 
11FA:  RETURN  
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
11D6:  MOV.B   #1,W0L
11D8:  MOV.B   W0L,9F6
11DA:  PUSH    9EA
11DC:  POP     9F2
11DE:  PUSH    9EC
11E0:  POP     9F4
11E2:  CALL    107E
11E6:  MOV.D   W0,W0
.................... } 
11E8:  RETURN  
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
*
11FC:  MOV     W5,[W15++]
11FE:  MOV     W6,[W15++]
....................    float32 i; 
....................    if (y!=0.0) 
1200:  MOV     9D6,W0
1202:  MOV     9D8,W1
1204:  MOV     #0,W2
1206:  MOV     #0,W3
1208:  CALL    D8C
120C:  BRA     Z,1282
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
120E:  MOV     9D2,W0
1210:  MOV     9D4,W1
1212:  MOV     9D6,W2
1214:  MOV     9D8,W3
1216:  CALL    C78
121A:  MOV     W0,W5
121C:  MOV     W1,W6
121E:  MOV     W5,W0
1220:  MOV     W6,W1
1222:  MOV     #0,W2
1224:  MOV     #0,W3
1226:  CALL    D8C
122A:  BRA     NC,1246
122C:  MOV     9D2,W0
122E:  MOV     9D4,W1
1230:  MOV     9D6,W2
1232:  MOV     9D8,W3
1234:  CALL    C78
1238:  MOV     W0,W5
123A:  MOV     W1,W6
123C:  MOV     W5,9EA
123E:  MOV     W6,9EC
1240:  CALL    11D6
1244:  BRA     125E
1246:  MOV     9D2,W0
1248:  MOV     9D4,W1
124A:  MOV     9D6,W2
124C:  MOV     9D8,W3
124E:  CALL    C78
1252:  MOV     W0,W5
1254:  MOV     W1,W6
1256:  MOV     W5,9EA
1258:  MOV     W6,9EC
125A:  CALL    11EA
125E:  MOV     W0,9DA
1260:  MOV     W1,9DC
....................       return(x-(i*y)); 
1262:  MOV     9DA,W0
1264:  MOV     9DC,W1
1266:  MOV     9D6,W2
1268:  MOV     9D8,W3
126A:  CALL    FC0
126E:  BSET.B  43.0
1270:  MOV     W0,W2
1272:  MOV     W1,W3
1274:  MOV     9D2,W0
1276:  MOV     9D4,W1
1278:  CALL    E20
127C:  MOV.D   W0,W0
127E:  BRA     1282
....................    } 
....................    else 
1280:  BRA     1282
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
1282:  MOV     [--W15],W6
1284:  MOV     [--W15],W5
1286:  RETURN  
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <uart.h> 
.................... #ifndef __UART__ 
.................... #define __UART__ 
....................  
.................... #define ALARM_DATA_ID 0x03 
....................  
.................... void transmitTLV(int8 *arrayToSend, int8 length); 
.................... void transmitTLV(int8 *arrayToSend, int8 length, int8 tlvID); 
.................... void TransmitDataStreaming(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <i2c.h> 
.................... #ifndef __IIC__ 
.................... #define __IIC__ 
....................  
.................... #word TRISF = 0x002DE 
.................... #bit  SDA_DIR = TRISF.0 
.................... #bit  SCL_DIR = TRISF.1 
....................  
.................... #define SDA_PIN SDA 
.................... #define SCL_PIN SCL 
....................  
.................... // common i2c routines 
.................... int8 i2c_in_byte(); 
.................... void i2c_out_byte(int8 o_byte); 
.................... void i2c_nack(); 
.................... void i2c_ack(); 
.................... void i2c_start(); 
.................... void i2c_stop(); 
.................... void i2c_high_sda(); 
.................... void i2c_low_sda(); 
.................... void i2c_high_scl(); 
.................... void i2c_low_scl(); 
....................  
.................... #endif 
....................  
.................... #include <EEPROM.h> 
.................... //#ifndef __EEPROM__ 
.................... //#define __EEPROM__ 
.................... // 
.................... ///* 
.................... // *  EEPROM.h 
.................... // *  DawnStar 
.................... // * 
.................... // *  Created by Alexis Ouellet-Patenaude on 10-12-12. 
.................... // *  Copyright 2010 EmbVue Inc. All rights reserved. 
.................... // * 
.................... // */ 
.................... // 
.................... //void saveConfigToEEPROM(); 
.................... //void readConfigFromEEPROM(); 
.................... //int16 eepromContent[15]; 
.................... // 
.................... //#define EE_START_ADDR	0x00 
.................... // 
.................... ////Address locations RTCC 
.................... //#define EE_ALARM_H		0x00 
.................... //#define EE_ALARM_M		0x02 
.................... //#define EE_ALARM_DAYS	0x04 
.................... //#define EE_ALARM_SNOOZE	0x06 
.................... //#define EE_ALARM_ENABLE	0x08 
.................... // 
.................... ////Address locations RGBLighting 
.................... //#define EE_HUE			0x0A 
.................... //#define EE_SAT			0x0C 
.................... //#define EE_VAL			0x0E 
.................... //#define EE_MOOD_ENABLE	0x10 
.................... // 
.................... ////Address locations Chime 
.................... //#define EE_CARILLON		0x12 
.................... //#define EE_VOLUME		0x14 
.................... //#define EE_TONE			0x16 
.................... // 
.................... ////Address locations Load Lighting 
.................... //#define EE_MAX_LOAD		0x18 
.................... //#define EE_LOAD_DELAY	0x1A 
.................... // 
.................... //#endif 
....................  
.................... #include <Menu.h> 
.................... #ifndef __MENU__ 
.................... #define __MENU__ 
....................  
.................... typedef void (*funPtr)(void);  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
2F16:  CLR     878
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define UP 1 
.................... #define DOWN 0 
....................  
.................... //#word QEICON = 0x0122 
.................... //#bit  UPDN   = QEICON.11 
....................  
.................... #define EDIT_DATE_TIME_PH_COUNT 7 
.................... #define EDIT_ALARM_OPTIONS_PH_LOCATION 9 
.................... #define EDIT_CARILLON_PH_LOCATION 2 
.................... #define EDIT_ALARM_TIME_PH_LOCATION 6 
.................... #define EDIT_ALARM_DAYS_PH_LOCATION 8 
.................... #define EDIT_ALARM_SNOOZE_PH_LOCATION 2 
.................... #define EDIT_LOAD_LIGHT_PH_LOCATION 3 
.................... #define EDIT_RGB_LIGHT_PH_LOCATION 5 
.................... #define EDIT_VOLUME_PH_LOCATION 3 
.................... #define EDIT_LOAD_DISPLAY_PH_LOCATION 3 
....................  
....................  
.................... int8 EDIT_DATE_TIME_PH_LOCATION[]  = {0x01, 0x04, 0x07, 0x29, 0x2C, 0x31, 0x37}; 
2F18:  MOV     #401,W4
2F1A:  MOV     W4,87E
2F1C:  MOV     #2907,W4
2F1E:  MOV     W4,880
2F20:  MOV     #312C,W4
2F22:  MOV     W4,882
2F24:  MOV.B   #37,W0L
2F26:  MOV.B   W0L,884
.................... int8 EDIT_ALARM_OPTIONS_LOCATION[] = {0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37}; 
2F28:  MOV     #302F,W4
2F2A:  MOV     W4,886
2F2C:  MOV     #3231,W4
2F2E:  MOV     W4,888
2F30:  MOV     #3433,W4
2F32:  MOV     W4,88A
2F34:  MOV     #3635,W4
2F36:  MOV     W4,88C
2F38:  MOV.B   #37,W0L
2F3A:  MOV.B   W0L,88E
.................... int8 EDIT_CARILLON_LOCATION[] = {0x2A, 0x37}; 
2F3C:  MOV     #372A,W4
2F3E:  MOV     W4,890
.................... int8 EDIT_ALARM_TIME_LOCATION[] = {0x09, 0x29, 0x2C, 0x33, 0x35, 0x37}; 
2F40:  MOV     #2909,W4
2F42:  MOV     W4,892
2F44:  MOV     #332C,W4
2F46:  MOV     W4,894
2F48:  MOV     #3735,W4
2F4A:  MOV     W4,896
.................... int8 EDIT_ALARM_DAYS_LOCATION[] = {0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x37}; 
2F4C:  MOV     #302F,W4
2F4E:  MOV     W4,898
2F50:  MOV     #3231,W4
2F52:  MOV     W4,89A
2F54:  MOV     #3433,W4
2F56:  MOV     W4,89C
2F58:  MOV     #3735,W4
2F5A:  MOV     W4,89E
.................... int8 EDIT_ALARM_SNOOZE_LOCATION[] = {0x29, 0x37}; 
2F5C:  MOV     #3729,W4
2F5E:  MOV     W4,8A0
.................... int8 EDIT_LOAD_LIGHT_LOCATION[] = {0x0D, 0x35, 0x37}; 
2F60:  MOV     #350D,W4
2F62:  MOV     W4,8A2
2F64:  MOV.B   #37,W0L
2F66:  MOV.B   W0L,8A4
.................... int8 EDIT_RGB_LIGHT_LOCATION[] = {0x07, 0x0D, 0x2F, 0x35, 0x37}; 
2F68:  MOV     #D07,W4
2F6A:  MOV     W4,8A6
2F6C:  MOV     #352F,W4
2F6E:  MOV     W4,8A8
2F70:  MOV.B   #37,W0L
2F72:  MOV.B   W0L,8AA
.................... int8 EDIT_VOLUME_LOCATION[] = {0x0A, 0x32, 0x37}; 
2F74:  MOV     #320A,W4
2F76:  MOV     W4,8AC
2F78:  MOV.B   #37,W0L
2F7A:  MOV.B   W0L,8AE
.................... int8 EDIT_LOAD_DISPLAY_LOCATION[] = {0x09, 0x31, 0x37}; 
2F7C:  MOV     #3109,W4
2F7E:  MOV     W4,8B0
2F80:  MOV.B   #37,W0L
2F82:  MOV.B   W0L,8B2
....................  
.................... void editField(byte * field, byte minimum, byte maximum, funPtr displayFunction); 
.................... void editIntField(int * field, int minimum, int maximum, funPtr displayFunction); 
....................  
.................... void displayEditDateAndTime(); 
....................  
.................... void displayEditAlarmOptions(); 
....................  
.................... void displayCarillon(); 
....................  
.................... void displayEditAlarmTime(); 
....................  
.................... void displayAlarmDays(); 
....................  
.................... void displaySnooze(); 
....................  
.................... void displayLoadLighting(); 
....................  
.................... void displayRGBLight(); 
....................  
.................... void displayVolume(); 
....................  
.................... void displayPowerCtrls(); 
....................  
.................... #define BUZZER_ON_TIME 50 
.................... #define WAIT_FOR_DEBOUNCE 100 
....................  
.................... void EditDateAndTime(); 
....................  
.................... void EditAlarmTime(); 
....................  
.................... void EditCarillon(); 
....................  
.................... void EditLoadLighting(); 
....................  
.................... void EditRGBLighting(); 
....................  
.................... void EditVolume(); 
....................  
.................... void EditBattery(); 
....................  
.................... void EditAlarmDays(); 
....................  
.................... void EditAlarmSnooze(); 
....................  
.................... void EditPowerCtrls(); 
....................  
.................... int1 insideMenu = false; 
....................  
.................... #endif 
....................  
.................... #include <RBGLighting.h> 
.................... #ifndef __RGBLIGHTING__ 
.................... #define __RGBLIGHTING__ 
.................... /* 
....................  *  RBGLighting.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 10-12-09. 
....................  *  Copyright 2010 EmbVue Inc. All rights reserved. 
....................  * 
....................  */ 
....................   
....................  typedef struct 
.................... { 
.................... 	unsigned int8 red; 
.................... 	unsigned int8 green; 
.................... 	unsigned int8 blue; 
....................     unsigned int8 cntr; 
.................... } RGB; 
....................  
.................... typedef struct 
.................... { 
.................... 	int16 hue; 
.................... 	unsigned int8 saturation; 
.................... 	unsigned int8 value; 
.................... } HSV; 
....................  
.................... void RGBtoHSV      (RGB  *rgb, 
....................                     HSV  *hsv); 
....................  
.................... void HSVtoRGB      (HSV  *hsv, 
....................                     RGB  *rgb); 
....................  
.................... void UpdateRGB_Out (RGB  *rgb); 
....................  
.................... void IncreaseHue   (HSV  *hsv); 
....................  
.................... /* 
.................... int8 red = 0; 
.................... int8 green = 0; 
.................... int8 blue = 0; 
.................... int8 hue = 0; 
.................... int8 saturation = 0; 
.................... int8 value = 0; 
.................... */ 
....................  
.................... RGB rgbColor; 
.................... HSV hsvColor; 
....................  
.................... int1 moodEnable = false; 
....................  
.................... void initRGBLighting(); 
.................... void ledExample(); 
.................... //void refreshRGB(); 
....................  
.................... #define CFG_RED 1 
.................... #define CFG_BLUE 2 
.................... #define CFG_GREEN 3 
....................  
.................... int8 dimmer0 = 0; 
.................... int8 dimmer1 = 0; 
.................... int8 dimmerCtrl = 0; 
....................  
....................  
.................... #define CFG_RED_OFF  0x00 
.................... #define CFG_RED_ON   0x01 
.................... #define CFG_RED_PW0  0x02 
.................... #define CFG_RED_PW1  0x03 
....................  
.................... #define CFG_GRN_OFF  0x00 
.................... #define CFG_GRN_ON   0x04 
.................... #define CFG_GRN_PW0  0x08 
.................... #define CFG_GRN_PW1  0x0C 
....................  
.................... #define CFG_BLU_OFF  0x00 
.................... #define CFG_BLU_ON   0x10 
.................... #define CFG_BLU_PW0  0x20 
.................... #define CFG_BLU_PW1  0x30 
....................  
.................... #define I2C_MAX_TRIAL   5u 
....................  
.................... //TMR4 CLOCK DEFINITION 
.................... #word TMR5  = 0x0118 
.................... #word PR5   = 0x011C 
.................... #word T5CON = 0x0120  
....................  
.................... #bit T5TON    = T5CON.15 
.................... #bit T5TGATE  = T5CON.6 
.................... #bit T5TCKPS1 = T5CON.4 
.................... #bit T5TCKPS0 = T5CON.3 
.................... #bit T5TCS    = T5CON.1 
....................  
.................... #define  T5CON_INIT  0x8000 
.................... #define  PR5_INIT    0x0793 
....................  
.................... #endif 
....................  
....................  
.................... #include <Chime.h> 
.................... #ifndef __CHIME__ 
.................... #define __CHIME__ 
....................  
.................... //TIMER3 DECLARATIONS 
.................... #word TMR3	= 0x010A 
.................... #word PR3	= 0x010E 
.................... #word T3CON	= 0x0112 
....................  
.................... #bit TMR3TON	= T3CON.15 
.................... #bit TMR3TSIDL	= T3CON.13 
.................... #bit TMR3TGATE	= T3CON.6 
.................... #bit TMR3TCKPS1	= T3CON.5 
.................... #bit TMR3TCKPS0	= T3CON.4 
.................... #bit TMR3TCS	= T3CON.1 
....................  
.................... //PWM DECLARATIONS 
.................... #word PTCON		= 0x01C0 
.................... #word PTMR		= 0x01C2 
.................... #word PTPER		= 0x01C4 
.................... #word PWMCON1 	= 0x01C8 
.................... #word PDC1		= 0x01D6 
.................... #word PDC2		= 0x01D8 
....................  
.................... #bit  PTEN  = PTCON.15 
.................... #bit  PWM1H = PWMCON1.4 
.................... #bit  PWM1L = PWMCON1.0 
.................... #bit  PWM2L = PWMCON1.1 
.................... #bit  PTCKPS0 = PTCON.2 
.................... #bit  PTCKPS1 = PTCON.3 
....................  
....................  
.................... #define INITIAL_T3CON 0x8030 
.................... #define TMR3_BASE (0x87C6 / 8)		// 300 ms * 118.6622 MHz / 4 / 256 
....................  
.................... #define CHIMESIZE 14 
....................  
.................... #define TONE_COUNT 1 
.................... #define MIN_VOLUME 1 
.................... #define MAX_VOLUME 100 
....................  
.................... int1 ChimePattern[] = {1,0,1,0,1,0,1,0,0,0,0,0,0,0}; 
2F84:  MOV     #55,W4
2F86:  MOV     W4,8BC
.................... int8 chimeState = 0; 
.................... int1 carillon = false; 
.................... int8 chimeVolume = MAX_VOLUME; 
.................... int8 toneSelect = 1; 
.................... int1 chimeOn = false; 
....................  
.................... #define CHIME_FREQ_PERIOD 0x3894 
.................... #define CHIME_DUTY 50 
.................... #define CHIME_ON_TIME (CHIME_FREQ_PERIOD * CHIME_DUTY / 100) 
....................  
.................... //float32 frequencyPWM = 2000; 
....................  
.................... void initChime(); 
....................  
.................... #endif 
....................  
.................... #include <LCDDriver.h> 
.................... #ifndef __LCDDRIVER__ 
.................... #define __LCDDRIVER__ 
....................  
.................... void initLCD(); 
.................... void shutdownLCD(void); 
.................... void writeByte(byte b); 
.................... void writeToLCD(byte MSB, byte LSB); 
.................... void writeToDDRAM(byte *arrayPtr, byte arraySize); 
.................... void setLCDLine(int lineNo, char * lineData, int lineSize); 
.................... void clearLCDLines(); 
....................  
.................... #define LCD_WRITE_CFG   0xF8 
.................... #define LCD_WRITE_MEM   0xFA 
.................... #define LCD_CLEAR       0x01 
.................... #define LCD_CSR_HM      0x02 
.................... #define LCD_EMS_DFLT    0x06 
....................  
.................... #define LCD_DSPL_DFLT   0x0F 
.................... #define LCD_DSPL_BOFF   0x0C 
.................... #define LCD_DSPL_OFF    0x08 
....................  
.................... #define LCD_CSR_LEFT	0x10 
.................... #define LCD_CSR_RIGHT	0x14 
.................... #define LCD_ADDR_SET    0x80 
....................  
.................... #define LCD_FCT_DFT     0x28 
.................... #define LCD_FCT_100     0x00 
.................... #define LCD_FCT_75      0x01 
.................... #define LCD_FCT_50      0x02 
.................... #define LCD_FCT_25      0x03 
....................  
....................  
.................... #define LCD_TIME_MULT 40 
....................  
.................... #define STB_L_HOLDTIME 4*LCD_TIME_MULT  // 04 cycles == 140 ns 
.................... #define STB_H_HOLDTIME 15*LCD_TIME_MULT // 15 cycles == 525 ns 
.................... #define SCK_L_HOLDTIME 8*LCD_TIME_MULT  // 08 cycles == 280 ns 
.................... #define SCK_H_HOLDTIME 8*LCD_TIME_MULT  // 08 cycles == 280 ns 
....................  
.................... #define LINE1 0 
.................... #define LINE2 1 
....................  
.................... //byte bonjour[] = {'B','l','o','w',' ','G','o','d'}; 
.................... #define LCD_LINE_SIZE 16 
.................... char LCD_Line1[LCD_LINE_SIZE]; 
.................... char LCD_Line2[LCD_LINE_SIZE]; 
.................... int1 enableLCD = true; 
....................  
.................... #define LUM_LCD_OFF_THRESHOLD_LOW  1024 
.................... #define LUM_LCD_OFF_THRESHOLD_HIGH 2048 
....................  
....................  
.................... #endif 
....................  
.................... #include <LoadControl.h> 
.................... #ifndef __LOADCONTROL__ 
.................... #define __LOADCONTROL__ 
....................  
.................... #word CNEN1  = 0x00C0 
.................... #word CNPU1  = 0x00C4 
.................... #bit  CN5IE  = CNEN1.5 
.................... #bit  CN5PUE = CNPU1.5 
....................  
.................... //TMR2 CLOCK DEFINITION 
.................... #word TMR2  = 0x0106 
.................... #word PR2   = 0x010C 
.................... #word T2CON = 0x0110 
....................  
.................... #bit TMR2TON = T2CON.15 
.................... #bit TMR2TSIDL = T2CON.13 
.................... #bit TMR2TGATE = T2CON.6 
.................... #bit TMR2TCKPS1 = T2CON.5 
.................... #bit TMR2TCKPS0 = T2CON.4 
.................... #bit TMR2TCS = T2CON.1 
....................  
.................... //TMR4 CLOCK DEFINITION 
.................... #word TMR4  = 0x0114 
.................... #word PR4   = 0x011A 
.................... #word T4CON = 0x011E  
....................  
.................... #bit T4TON    = T4CON.15 
.................... #bit T4TGATE  = T4CON.6 
.................... #bit T4TCKPS1 = T4CON.4 
.................... #bit T4TCKPS0 = T4CON.3 
.................... #bit T4TCS    = T4CON.1 
....................  
.................... #define  T4CON_INIT  0x8010  
....................  
.................... //Interrupt Priority Definitions 
....................  
....................  
.................... #define  LS_OFF               0 
.................... #define  LS_OFF_WAIT_TURN_ON  1 
.................... #define  LS_ON                2 
.................... #define  LS_OFF_WAIT_ZERO_X   3 
....................  
.................... #define  LS_MAX_DELAY         25000 
....................  
.................... void  InitLoadControl     (void); 
.................... void  monitorSync         (void); 
.................... int16 getTMRLoadValue     (int16 grade); 
.................... void  TurnTriacOn         (void); 
.................... void  TurnTriacOff        (void); 
.................... void  TurnLoadCtrlLow     (void); 
.................... void  TurnLoadCtrlHigh    (void); 
.................... void  CalculateLuminosity (void); 
.................... void  SetLampIntensity    (float intensity); 
....................  
.................... int8 maxLoadLighting   = 100; 
.................... int8 delayLoadLighting =  30; 
....................  
.................... typedef struct  
.................... { 
.................... 	unsigned  int16  PhaseOffset;                       /* Delay to turn triac on.                  */ 
....................     unsigned  int16  PulseWidth;                        /* Triac pulse duration.                    */ 
....................     unsigned  int8   LoadState;                         /* Gate State:                              */ 
....................                                                         /*      0 - Off (Power <= 0%)               */ 
....................                                                         /*      1 - Off Wait for turn on            */ 
....................                                                         /*      2 - On                              */ 
....................                                                         /*      3 - Off Wait for zero cross.        */ 
....................     unsigned  int1   TriacState;                        /* State of the Triac.                      */ 
.................... } load_struct; 
....................  
.................... load_struct      LoadStruct; 
.................... unsigned  int16  TMR4IntrCnt1 = 0; 
.................... unsigned  int16  TMR4IntrCnt2 = 0; 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include <LumMonitor.h> 
.................... #ifndef __LUMCONTROL__ 
.................... #define __LUMCONTROL__ 
....................  
.................... void initLumMonitor(); 
....................  
.................... #endif 
....................  
.................... #include <RTCC.h> 
.................... #ifndef __RTCC__ 
.................... #define __RTCC__ 
....................  
.................... #include "customTime.c" 
.................... // this structure is just the local version of Visual C tm_structure in time.h 
....................  
.................... typedef struct  
.................... { 
.................... 	int tm_sec;		/* seconds after the minute - [0,59]   */ 
.................... 	int tm_min;		/* minutes after the hour   - [0,59]   */ 
.................... 	int tm_hour;	/* hours since midnight     - [0,23]   */ 
.................... 	int tm_mday;	/* day of the month         - [1,31]   */ 
.................... 	int tm_mon;		/* months since January     - [0,11]   */ 
.................... 	int tm_year;	/* years since 1900					   */ 
.................... 	int tm_wday;	/* days since Sunday         - [0,6]   */ 
.................... 	int tm_yday;	/* days since January 1      - [0,365] */ 
.................... 	int tm_isdst;	/* daylight savings time flag NOT USED */ 
.................... } tm_struct; 
....................  
.................... unsigned long DaysToMonth[13] = {0,31,59,90,120,151,181,212,243,273,304,334,365}; 
2F88:  CLR     8EC
2F8A:  CLR     8EE
2F8C:  MOV     #1F,W4
2F8E:  MOV     W4,8F0
2F90:  CLR     8F2
2F92:  MOV     #3B,W4
2F94:  MOV     W4,8F4
2F96:  CLR     8F6
2F98:  MOV     #5A,W4
2F9A:  MOV     W4,8F8
2F9C:  CLR     8FA
2F9E:  MOV     #78,W4
2FA0:  MOV     W4,8FC
2FA2:  CLR     8FE
2FA4:  MOV     #97,W4
2FA6:  MOV     W4,900
2FA8:  CLR     902
2FAA:  MOV     #B5,W4
2FAC:  MOV     W4,904
2FAE:  CLR     906
2FB0:  MOV     #D4,W4
2FB2:  MOV     W4,908
2FB4:  CLR     90A
2FB6:  MOV     #F3,W4
2FB8:  MOV     W4,90C
2FBA:  CLR     90E
2FBC:  MOV     #111,W4
2FBE:  MOV     W4,910
2FC0:  CLR     912
2FC2:  MOV     #130,W4
2FC4:  MOV     W4,914
2FC6:  CLR     916
2FC8:  MOV     #14E,W4
2FCA:  MOV     W4,918
2FCC:  CLR     91A
2FCE:  MOV     #16D,W4
2FD0:  MOV     W4,91C
2FD2:  CLR     91E
....................  
.................... unsigned long DS1371_DateToBinary(tm_struct *datetime) 
.................... { 
*
091E:  MOV     W5,[W15++]
0920:  MOV     W6,[W15++]
0922:  MOV     W7,[W15++]
0924:  MOV     W8,[W15++]
.................... 	unsigned long iday; 
.................... 	unsigned long val; 
.................... 	 
.................... 	iday = 365 * (datetime->tm_year - 70) + DaysToMonth[datetime->tm_mon-1] + (datetime->tm_mday - 1); 
0926:  MOV     #A,W0
0928:  ADD     99C,W0
092A:  MOV     [W0],W5
092C:  MOV     #46,W4
092E:  SUB     W5,W4,W0
0930:  MOV     #16D,W4
0932:  MUL.SS  W4,W0,W0
0934:  MOV     W0,W5
0936:  MOV     #8,W0
0938:  ADD     99C,W0
093A:  MOV     [W0],W6
093C:  SUB     W6,#1,W6
093E:  MOV     W6,W4
0940:  MUL.UU  W4,#4,W0
0942:  MOV     #8EC,W4
0944:  ADD     W0,W4,W0
0946:  MOV     W0,W4
0948:  MOV     #0,W3
094A:  MOV     [W4++],[W3++]
094C:  MOV     [W4++],[W3++]
094E:  ADD     W0,W5,W5
0950:  ADDC    W1,#0,W1
0952:  MOV     W1,W6
0954:  MOV     #6,W0
0956:  ADD     99C,W0
0958:  MOV     [W0],W7
095A:  SUB     W7,#1,W0
095C:  CLR     W1
095E:  BTSC    W0.F
0960:  SETM    W1
0962:  ADD     W0,W5,W0
0964:  MOV     W0,99E
0966:  ADDC    W1,W6,W0
0968:  MOV     W0,9A0
.................... 	iday = iday + (datetime->tm_year - 69) / 4; 
096A:  MOV     #A,W0
096C:  ADD     99C,W0
096E:  MOV     [W0],W5
0970:  SUB     #45,W5
0972:  MOV     W5,W4
0974:  MOV     #4,W3
0976:  REPEAT  #11
0978:  DIV.S   W4,W3
097A:  CLR     W1
097C:  BTSC    W0.F
097E:  SETM    W1
0980:  ADD     99E
0982:  MOV     W1,W0
0984:  ADDC    9A0,W0
0986:  MOV     W0,9A0
.................... 	if ((datetime->tm_mon > 2) && ((datetime->tm_year % 4) == 0)) { 
0988:  MOV     #8,W0
098A:  ADD     99C,W0
098C:  MOV     [W0],W5
098E:  CP      W5,#2
0990:  BRA     LE,9AC
0992:  MOV     #A,W0
0994:  ADD     99C,W0
0996:  MOV     [W0],W5
0998:  MOV     W5,W4
099A:  MOV     #4,W3
099C:  REPEAT  #11
099E:  DIV.S   W4,W3
09A0:  MOV     W1,W5
09A2:  CP0     W5
09A4:  BRA     NZ,9AC
.................... 		iday++; 
09A6:  INC     099E
09A8:  BTSC.B  42.1
09AA:  INC     09A0
.................... 	} 
.................... 	val = datetime->tm_sec + 60 * datetime->tm_min + 3600 * (datetime->tm_hour + 24 * iday); 
09AC:  MOV     #0,W0
09AE:  ADD     99C,W0
09B0:  MOV     [W0],W5
09B2:  MOV     #2,W0
09B4:  ADD     99C,W0
09B6:  MOV     W0,W4
09B8:  MOV     [W4],W0
09BA:  MOV     #3C,W4
09BC:  MUL.SS  W4,W0,W0
09BE:  ADD     W0,W5,W5
09C0:  MOV     #4,W0
09C2:  ADD     99C,W0
09C4:  MOV     [W0],W6
09C6:  CLR     W7
09C8:  BTSC    W6.F
09CA:  SETM    W7
09CC:  PUSH    42
09CE:  SETM.B  42
09D0:  MOV     #18,W0
09D2:  MOV     #0,W1
09D4:  MOV     99E,W2
09D6:  MOV     9A0,W3
09D8:  CALL    50A
09DC:  POP     42
09DE:  ADD     W0,W6,W0
09E0:  ADDC    W1,W7,W1
09E2:  MOV     W0,W2
09E4:  MOV     W1,W3
09E6:  MOV     #E10,W0
09E8:  MOV     #0,W1
09EA:  CALL    8DC
09EE:  ADD     W0,W5,W0
09F0:  MOV     W0,9A2
09F2:  ADDC    W1,#0,W1
09F4:  MOV     W1,9A4
.................... 	return val; 
09F6:  MOV     9A2,W0
09F8:  MOV     9A4,W1
.................... } 
09FA:  MOV     [--W15],W8
09FC:  MOV     [--W15],W7
09FE:  MOV     [--W15],W6
0A00:  MOV     [--W15],W5
0A02:  RETURN  
....................  
.................... void DS1371_BinaryToDate(unsigned long binary,tm_struct *datetime) 
.................... { 
*
053A:  MOV     W5,[W15++]
053C:  MOV     W6,[W15++]
.................... 	unsigned long hour; 
.................... 	unsigned long day; 
.................... 	unsigned long minute; 
.................... 	unsigned long second; 
.................... 	unsigned long month; 
.................... 	unsigned long year; 
.................... 	unsigned long whole_minutes; 
.................... 	unsigned long whole_hours; 
.................... 	unsigned long whole_days; 
.................... 	unsigned long whole_days_since_1968; 
.................... 	unsigned long leap_year_periods; 
.................... 	unsigned long days_since_current_lyear; 
.................... 	unsigned long whole_years; 
.................... 	unsigned long days_since_first_of_year; 
.................... 	unsigned long days_to_month; 
.................... 	unsigned long day_of_week; 
.................... 	 
.................... 	whole_minutes = binary / 60; 
053E:  BCLR.B  43.0
0540:  MOV     A50,W0
0542:  MOV     A52,W1
0544:  MOV     #3C,W2
0546:  MOV     #0,W3
0548:  CALL    4B6
054C:  MOV     W0,A6E
054E:  MOV     W1,A70
.................... 	second = binary - (60 * whole_minutes);			// leftover seconds 
0550:  MOV     #3C,W0
0552:  MOV     #0,W1
0554:  MOV     A6E,W2
0556:  MOV     A70,W3
0558:  CALL    50A
055C:  MOV     A50,W4
055E:  SUB     W4,W0,W0
0560:  MOV     W0,A62
0562:  MOV     A52,W4
0564:  SUBB    W4,W1,W0
0566:  MOV     W0,A64
.................... 	whole_hours = whole_minutes / 60; 
0568:  BCLR.B  43.0
056A:  MOV     A6E,W0
056C:  MOV     A70,W1
056E:  MOV     #3C,W2
0570:  MOV     #0,W3
0572:  CALL    4B6
0576:  MOV     W0,A72
0578:  MOV     W1,A74
.................... 	minute = whole_minutes - (60 * whole_hours);	// leftover minutes 
057A:  MOV     #3C,W0
057C:  MOV     #0,W1
057E:  MOV     A72,W2
0580:  MOV     A74,W3
0582:  CALL    50A
0586:  MOV     A6E,W4
0588:  SUB     W4,W0,W0
058A:  MOV     W0,A5E
058C:  MOV     A70,W4
058E:  SUBB    W4,W1,W0
0590:  MOV     W0,A60
.................... 	whole_days	= whole_hours / 24; 
0592:  BCLR.B  43.0
0594:  MOV     A72,W0
0596:  MOV     A74,W1
0598:  MOV     #18,W2
059A:  MOV     #0,W3
059C:  CALL    4B6
05A0:  MOV     W0,A76
05A2:  MOV     W1,A78
.................... 	hour	= whole_hours - (24 * whole_days);		// leftover hours 
05A4:  MOV     #18,W0
05A6:  MOV     #0,W1
05A8:  MOV     A76,W2
05AA:  MOV     A78,W3
05AC:  CALL    50A
05B0:  MOV     A72,W4
05B2:  SUB     W4,W0,W0
05B4:  MOV     W0,A56
05B6:  MOV     A74,W4
05B8:  SUBB    W4,W1,W0
05BA:  MOV     W0,A58
.................... 	 
.................... 	   
.................... 	whole_days_since_1968 = whole_days + 365 + 366;  
05BC:  MOV     #16D,W4
05BE:  MOV     A76,W3
05C0:  ADD     W3,W4,W5
05C2:  MOV     A78,W4
05C4:  ADDC    W4,#0,W4
05C6:  MOV     W4,W6
05C8:  MOV     #16E,W4
05CA:  ADD     W5,W4,W0
05CC:  MOV     W0,A7A
05CE:  ADDC    W6,#0,W6
05D0:  MOV     W6,A7C
.................... 	leap_year_periods = whole_days_since_1968 / ((4 * 365) + 1);	 
05D2:  BCLR.B  43.0
05D4:  MOV     A7A,W0
05D6:  MOV     A7C,W1
05D8:  MOV     #5B5,W2
05DA:  MOV     #0,W3
05DC:  CALL    4B6
05E0:  MOV     W0,A7E
05E2:  MOV     W1,A80
.................... 	days_since_current_lyear = whole_days_since_1968 % ((4 * 365) + 1); 
05E4:  BSET.B  43.0
05E6:  MOV     A7A,W0
05E8:  MOV     A7C,W1
05EA:  MOV     #5B5,W2
05EC:  MOV     #0,W3
05EE:  CALL    4B6
05F2:  MOV     W0,A82
05F4:  MOV     W1,A84
.................... 	 
.................... 	// if days are after a current leap year then add a leap year period 
.................... 	if ((days_since_current_lyear >= (31 + 29))) 
05F6:  MOV     A84,W4
05F8:  CP      W4,#0
05FA:  BRA     NC,60C
05FC:  BRA     GTU,606
05FE:  MOV     A82,W4
0600:  MOV     #3C,W3
0602:  CP      W3,W4
0604:  BRA     GTU,60C
.................... 	{ 
.................... 		leap_year_periods++; 
0606:  INC     0A7E
0608:  BTSC.B  42.1
060A:  INC     0A80
.................... 	}  
.................... 	 
.................... 	whole_years = (whole_days_since_1968 - leap_year_periods) / 365; 
060C:  MOV     A7A,W4
060E:  MOV     A7E,W3
0610:  SUB     W4,W3,W5
0612:  MOV     A7C,W4
0614:  MOV     A80,W3
0616:  SUBB    W4,W3,W6
0618:  BCLR.B  43.0
061A:  MOV     W5,W0
061C:  MOV     W6,W1
061E:  MOV     #16D,W2
0620:  MOV     #0,W3
0622:  CALL    4B6
0626:  MOV     W0,A86
0628:  MOV     W1,A88
.................... 	days_since_first_of_year = whole_days_since_1968 - (whole_years * 365) - leap_year_periods; 
062A:  MOV     A86,W0
062C:  MOV     A88,W1
062E:  MOV     #16D,W2
0630:  MOV     #0,W3
0632:  CALL    50A
0636:  MOV     A7A,W4
0638:  SUB     W4,W0,W5
063A:  MOV     A7C,W4
063C:  SUBB    W4,W1,W6
063E:  MOV     A7E,W4
0640:  SUB     W5,W4,W0
0642:  MOV     W0,A8A
0644:  MOV     A80,W4
0646:  SUBB    W6,W4,W0
0648:  MOV     W0,A8C
....................  
.................... 	if ((days_since_current_lyear <= 365) && (days_since_current_lyear >= 60)) 
064A:  MOV     A84,W4
064C:  CP      W4,#0
064E:  BRA     GTU,670
0650:  BRA     NC,65A
0652:  MOV     A82,W4
0654:  MOV     #16D,W3
0656:  CP      W3,W4
0658:  BRA     NC,670
065A:  MOV     A84,W4
065C:  CP      W4,#0
065E:  BRA     NC,670
0660:  BRA     GTU,66A
0662:  MOV     A82,W4
0664:  MOV     #3C,W3
0666:  CP      W3,W4
0668:  BRA     GTU,670
.................... 	{ 
.................... 		days_since_first_of_year++; 
066A:  INC     0A8A
066C:  BTSC.B  42.1
066E:  INC     0A8C
.................... 	} 
.................... 	 
.................... 	year = whole_years + 68; 
0670:  MOV     #44,W4
0672:  MOV     A86,W3
0674:  ADD     W3,W4,W0
0676:  MOV     W0,A6A
0678:  MOV     A88,W4
067A:  ADDC    W4,#0,W4
067C:  MOV     W4,A6C
....................  
.................... 	// setup for a search for what month it is based on how many days have past 
.................... 	//	within the current year 
.................... 	month = 13; 
067E:  MOV     #D,W4
0680:  MOV     W4,A66
0682:  CLR     A68
.................... 	days_to_month = 366; 
0684:  MOV     #16E,W4
0686:  MOV     W4,A8E
0688:  CLR     A90
.................... 	 
.................... 	while (days_since_first_of_year < days_to_month) 
.................... 	{ 
068A:  MOV     A8C,W0
068C:  MOV     A90,W4
068E:  CP      W4,W0
0690:  BRA     NC,71E
0692:  BRA     GTU,69C
0694:  MOV     A8A,W0
0696:  MOV     A8E,W4
0698:  CP      W4,W0
069A:  BRA     LEU,71E
.................... 		month--; 
069C:  DEC     0A66
069E:  BTSS.B  42.0
06A0:  DEC     0A68
.................... 		days_to_month = DaysToMonth[month-1]; 
06A2:  MOV     A66,W4
06A4:  SUB     W4,#1,W5
06A6:  MOV     A68,W4
06A8:  SUBB    W4,#0,W6
06AA:  MOV     #2,W4
06AC:  CLR.B   9
06AE:  MOV     W5,W0
06B0:  MOV     W6,W1
06B2:  INC     W4,W4
06B4:  DEC     W4,W4
06B6:  BRA     Z,6BE
06B8:  SL      W0,W0
06BA:  RLC     W1,W1
06BC:  BRA     6B4
06BE:  MOV     #8EC,W4
06C0:  ADD     W0,W4,W0
06C2:  MOV     #A8E,W4
06C4:  MOV     [W0++],[W4++]
06C6:  MOV     [W0++],[W4++]
.................... 		if ((month > 2) && ((year % 4) == 0)) 
06C8:  MOV     A68,W4
06CA:  CP      W4,#0
06CC:  BRA     NC,6EA
06CE:  BRA     GTU,6D6
06D0:  MOV     A66,W4
06D2:  CP      W4,#2
06D4:  BRA     LEU,6EA
06D6:  MOV     A6A,W0
06D8:  AND     W0,#3,W5
06DA:  CLR     W6
06DC:  CP0     W5
06DE:  BRA     NZ,6EA
06E0:  CP0     W6
06E2:  BRA     NZ,6EA
.................... 		{ 
.................... 			days_to_month++; 
06E4:  INC     0A8E
06E6:  BTSC.B  42.1
06E8:  INC     0A90
.................... 		} 
.................... 		 
.................... 		day = days_since_first_of_year - days_to_month + 1; 
06EA:  MOV     A8A,W4
06EC:  MOV     A8E,W3
06EE:  SUB     W4,W3,W5
06F0:  MOV     A8C,W4
06F2:  MOV     A90,W3
06F4:  SUBB    W4,W3,W6
06F6:  ADD     W5,#1,W5
06F8:  MOV     W5,A5A
06FA:  ADDC    W6,#0,W6
06FC:  MOV     W6,A5C
.................... 		day_of_week = (whole_days + 4) % 7; 
06FE:  MOV     A76,W4
0700:  ADD     W4,#4,W4
0702:  MOV     W4,W5
0704:  MOV     A78,W4
0706:  ADDC    W4,#0,W4
0708:  MOV     W4,W6
070A:  BSET.B  43.0
070C:  MOV     W5,W0
070E:  MOV     W6,W1
0710:  MOV     #7,W2
0712:  MOV     #0,W3
0714:  CALL    4B6
0718:  MOV     W0,A92
071A:  MOV     W1,A94
.................... 	} 
071C:  BRA     68A
.................... 	 
.................... 	datetime->tm_yday = days_since_first_of_year;	/* days since January 1 - [0,365]	*/ 
071E:  MOV     #E,W0
0720:  ADD     A54,W0
0722:  MOV     W0,W5
0724:  MOV     A8A,W4
0726:  MOV     W4,[W5+#0]
.................... 	datetime->tm_sec = second;						/* seconds after the minute - [0,59]	*/ 
0728:  MOV     #0,W0
072A:  ADD     A54,W0
072C:  MOV     W0,W5
072E:  MOV     A62,W4
0730:  MOV     W4,[W5+#0]
.................... 	datetime->tm_min = minute;						/* minutes after the hour - [0,59]	*/ 
0732:  MOV     #2,W0
0734:  ADD     A54,W0
0736:  MOV     W0,W5
0738:  MOV     A5E,W4
073A:  MOV     W4,[W5+#0]
.................... 	datetime->tm_hour = hour;						/* hours since midnight - [0,23]	*/ 
073C:  MOV     #4,W0
073E:  ADD     A54,W0
0740:  MOV     W0,W5
0742:  MOV     A56,W4
0744:  MOV     W4,[W5+#0]
.................... 	datetime->tm_mday = day;						/* day of the month - [1,31]	*/ 
0746:  MOV     #6,W0
0748:  ADD     A54,W0
074A:  MOV     W0,W5
074C:  MOV     A5A,W4
074E:  MOV     W4,[W5+#0]
.................... 	datetime->tm_wday = day_of_week;				/* days since Sunday - [0,6]	*/ 
0750:  MOV     #C,W0
0752:  ADD     A54,W0
0754:  MOV     W0,W5
0756:  MOV     A92,W4
0758:  MOV     W4,[W5+#0]
.................... 	datetime->tm_mon = month;						/* months since January - [0,11]	*/ 
075A:  MOV     #8,W0
075C:  ADD     A54,W0
075E:  MOV     W0,W5
0760:  MOV     A66,W4
0762:  MOV     W4,[W5+#0]
.................... 	datetime->tm_year = year;						/* years since 1900	*/ 
0764:  MOV     #A,W0
0766:  ADD     A54,W0
0768:  MOV     W0,W5
076A:  MOV     A6A,W4
076C:  MOV     W4,[W5+#0]
.................... } 
076E:  MOV     [--W15],W6
0770:  MOV     [--W15],W5
0772:  RETURN  
....................  
....................  
.................... /* 
.................... typedef struct { 
.................... 	int tm_sec; 
.................... 	int tm_min; 
.................... 	int tm_hour; 
.................... 	int tm_mday; 
.................... 	int tm_mon; 
.................... 	int tm_year; 
.................... 	int tm_wday; 
.................... 	int tm_yday; 
.................... 	int tm_isdst; 
.................... } tm_struct; 
....................  
....................  typedef struct { 
.................... 	int8    year; 
.................... 	int8    month; 
.................... 	int8    day; 
.................... 	int8	hour; 
.................... 	int8	minute; 
.................... 	int8	second; 
.................... } date; 
.................... */ 
....................  
.................... #define MM_JAN 1 
.................... #define MM_FEB 2 
.................... #define MM_MAR 3 
.................... #define MM_APR 4 
.................... #define MM_MAY 5 
.................... #define MM_JUN 6 
.................... #define MM_JUL 7 
.................... #define MM_AUG 8 
.................... #define MM_SEP 9 
.................... #define MM_OCT 10 
.................... #define MM_NOV 11 
.................... #define MM_DEC 12 
....................  
.................... #define ALARM_WAKE_TIMEOUT_SEC     60 
.................... #define ALARM_MAX_SNOOZE_COUNT      3 
.................... #define RTCC_MAX_DAY_LOOKAHEAD      7 
.................... #define SEC_IN_A_DAY            86400 
.................... #define RTCC_STANDBY_TIMEOUT      180 
.................... #define RTCC_PW_TH_MAX (DEFAULT_PULSE_WIDTH_DEFAULT + 10)              
....................  
....................          int8 ALARM_DAYS[]    = {0,1,1,1,1,1,0}; 
*
2FD4:  MOV     #100,W4
2FD6:  MOV     W4,920
2FD8:  MOV     #101,W4
2FDA:  MOV     W4,922
2FDC:  MOV     #101,W4
2FDE:  MOV     W4,924
2FE0:  CLR.B   926
.................... unsigned int8 AlarmSnoozeTime = 7; 
....................          int1 ALARM_ENABLED   = false; 
....................          int1 AlarmLampOn     = true; 
....................    
.................... void RTCC_IncSecond(); 
.................... void setDateAndTime(int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second); 
.................... boolean isDateTimeEqualTo(int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second); 
.................... void timeToStruct(tm_struct * returnTimeStruct, int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second); 
.................... void testRTCC(); 
.................... void InitRTCC(); 
.................... void RTCC_CheckForWake(); 
.................... void RTCC_CheckForEnablingAlarm(); 
.................... long timeStructToMinute(struct date * timeStruct); 
.................... float PowerToTimeOn(float x); 
.................... void AlarmStateMachine (void); 
.................... void RTCC_TransitionToSTANDBY(void); 
.................... void FindNextAlarmTime(void); 
....................  
.................... tm_struct CurrentTime; 
.................... tm_struct AlarmTime; 
.................... tm_struct SnoozeTime; 
....................  
....................  
....................  
....................  
.................... //enum ALARM_STATE alarmState = ALARM_STANDBY; 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include <Userinput.h> 
.................... #ifndef __USERINPUT__ 
.................... #define __USERINPUT__ 
....................  
.................... #word QEICON = 0x0122 
.................... #word POSCNT = 0x0126 
....................  
.................... #bit UPDN = QEICON.11 
....................  
.................... #define WAIT_PHASE_SEL 0 
.................... #define WAIT_PULSE_SEL 1 
.................... #define SEL_COUNT 2 
....................  
.................... #define PUSH_BUTTON_TIMEOUT_SEC 10 
....................  
.................... void initUserInput(); 
.................... void encoderMonitoring(); 
.................... void switchInputContext(); 
....................  
.................... unsigned long lastUserPush = 0; 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#include "i2c.c" 
.................... #include "uart.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... #ifdef USE_UART_2 
.................... void transmitTLV(int8 *arrayToSend, int8 length) 
.................... { 
.................... 	volatile int8 j = 0; 
.................... 	putc(0xAA); 
.................... 	for(j = 0 ; j < length ; j++) 
.................... 	{ 
.................... 		putc(arrayToSend[j]); 
.................... 	} 
.................... 	putc(0x55); 
.................... } 
....................  
.................... void transmitTLV(int8 *arrayToSend, int8 length, int8 tlvID) 
.................... { 
*
1B86:  MOV     W5,[W15++]
1B88:  CLR.B   986
....................     volatile int8 j = 0; 
.................... 	putc(0xAA);	 
1B8A:  MOV.B   #AA,W0L
1B8C:  BTSC.B  219.1
1B8E:  BRA     1B8C
1B90:  MOV.B   W0L,21A
1B92:  CLR.B   21B
....................     putc(tlvID); 
1B94:  MOV.B   985,W0L
1B96:  BTSC.B  219.1
1B98:  BRA     1B96
1B9A:  MOV.B   W0L,21A
1B9C:  CLR.B   21B
....................     putc(length); 
1B9E:  MOV.B   984,W0L
1BA0:  BTSC.B  219.1
1BA2:  BRA     1BA0
1BA4:  MOV.B   W0L,21A
1BA6:  CLR.B   21B
.................... 	for(j = 0 ; j < length ; j++) 
1BA8:  CLR.B   986
1BAA:  MOV.B   986,W0L
1BAC:  MOV     984,W4
1BAE:  CP.B    W4L,W0L
1BB0:  BRA     LE,1BCA
....................     { 
.................... 	    putc(arrayToSend[j]); 
1BB2:  MOV.B   986,W0L
1BB4:  SE      W0,W0
1BB6:  MOV     982,W4
1BB8:  ADD     W0,W4,W0
1BBA:  MOV.B   [W0],W5L
1BBC:  MOV.B   W5L,W0L
1BBE:  BTSC.B  219.1
1BC0:  BRA     1BBE
1BC2:  MOV.B   W0L,21A
1BC4:  CLR.B   21B
....................     } 
1BC6:  INC.B   0986
1BC8:  BRA     1BAA
.................... 	putc(0x55); 
1BCA:  MOV.B   #55,W0L
1BCC:  BTSC.B  219.1
1BCE:  BRA     1BCC
1BD0:  MOV.B   W0L,21A
1BD2:  CLR.B   21B
.................... } 
1BD4:  MOV     [--W15],W5
1BD6:  RETURN  
....................  
.................... void TransmitDataStreaming(void) 
.................... { 
....................     transmitTLV((int8  *)&alarmData, 
....................                 (int8   ) sizeof(ALARM_DATA), 
....................                 (int8   ) ALARM_DATA_ID); 
1BD8:  MOV     #85E,W0
1BDA:  MOV     W0,982
1BDC:  MOV.B   #1A,W0L
1BDE:  MOV.B   W0L,984
1BE0:  MOV.B   #3,W0L
1BE2:  MOV.B   W0L,985
1BE4:  CALL    1B86
.................... } 
1BE8:  RETURN  
....................  
.................... #endif 
....................  
.................... #include "RBGLighting.c" 
.................... /* 
....................  *  RBGLighting.c 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 10-12-09. 
....................  *  Copyright 2010 EmbVue Inc. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... #int_TIMER5 
.................... void TIMER5_isr(void) 
.................... { 
*
02B8:  PUSH    42
02BA:  PUSH    36
02BC:  MOV     W0,[W15++]
02BE:  MOV     #2,W0
02C0:  REPEAT  #C
02C2:  MOV     [W0++],[W15++]
....................     rgbColor.cntr++; 
02C4:  INC.B   08B7
....................      
....................     if ((rgbColor.red == 0)             || 
....................         (rgbColor.red  < rgbColor.cntr)) { 
02C6:  CP0.B   8B4
02C8:  BRA     Z,2D4
02CA:  MOV.B   8B4,W0L
02CC:  MOV     8B6,W4
02CE:  LSR     W4,#8,W4
02D0:  CP.B    W4L,W0L
02D2:  BRA     LEU,2DA
....................         output_low(LED_R); 
02D4:  BCLR.B  2C6.7
02D6:  BCLR.B  2CA.7
....................     } else { 
02D8:  BRA     2DE
....................         output_high(LED_R); 
02DA:  BCLR.B  2C6.7
02DC:  BSET.B  2CA.7
....................     } 
....................      
....................     if ((rgbColor.green == 0)             || 
....................         (rgbColor.green  < rgbColor.cntr)) { 
02DE:  CP0.B   8B5
02E0:  BRA     Z,2EC
02E2:  MOV.B   8B5,W0L
02E4:  MOV     8B6,W4
02E6:  LSR     W4,#8,W4
02E8:  CP.B    W4L,W0L
02EA:  BRA     LEU,2F2
....................         output_low(LED_G); 
02EC:  BCLR.B  2C6.1
02EE:  BCLR.B  2CA.1
....................     } else { 
02F0:  BRA     2F6
....................         output_high(LED_G); 
02F2:  BCLR.B  2C6.1
02F4:  BSET.B  2CA.1
....................     } 
....................      
....................     if ((rgbColor.blue == 0)             || 
....................         (rgbColor.blue  < rgbColor.cntr)) { 
02F6:  CP0.B   8B6
02F8:  BRA     Z,304
02FA:  MOV.B   8B6,W0L
02FC:  MOV     8B6,W4
02FE:  LSR     W4,#8,W4
0300:  CP.B    W4L,W0L
0302:  BRA     LEU,30A
....................         output_low(LED_B); 
0304:  BCLR.B  2C6.0
0306:  BCLR.B  2CA.0
....................     } else { 
0308:  BRA     30E
....................         output_high(LED_B); 
030A:  BCLR.B  2C6.0
030C:  BSET.B  2CA.0
....................     } 
.................... } 
....................  
030E:  BCLR.B  86.6
0310:  MOV     #1A,W0
0312:  REPEAT  #C
0314:  MOV     [--W15],[W0--]
0316:  MOV     [--W15],W0
0318:  POP     36
031A:  POP     42
031C:  RETFIE  
.................... void initRGBLighting() 
.................... { 
.................... 	T5CON = T5CON_INIT; 
*
150C:  MOV     #8000,W4
150E:  MOV     W4,120
....................     PR5   = PR5_INIT; 
1510:  MOV     #793,W4
1512:  MOV     W4,11C
....................      
.................... 	hsvColor.hue        = 0; 
1514:  CLR     8B8
.................... 	hsvColor.saturation = 255; 
1516:  SETM.B  8BA
.................... 	hsvColor.value      = 255; 
1518:  MOV.B   #FF,W0L
151A:  MOV.B   W0L,8BB
....................      
....................     rgbColor.red        = 0; 
151C:  CLR.B   8B4
....................     rgbColor.green      = 0; 
151E:  CLR.B   8B5
....................     rgbColor.blue       = 0; 
1520:  CLR.B   8B6
....................     rgbColor.cntr       = 0; 
1522:  CLR.B   8B7
.................... 	 
.................... 	HSVtoRGB(&hsvColor,&rgbColor); 
1524:  MOV     #8B8,W4
1526:  MOV     W4,9AC
1528:  MOV     #8B4,W4
152A:  MOV     W4,9AE
152C:  CALL    1288
.................... 	 
....................     UpdateRGB_Out(&rgbColor); 
1530:  MOV     #8B4,W4
1532:  MOV     W4,9AC
1534:  CALL    1492
....................      
....................     enable_interrupts(INT_TIMER5); 
1538:  BSET.B  8E.6
.................... } 
153A:  RETURN  
....................  
.................... //void updatePCA9533() 
.................... //{ 
.................... //	i2c_start(); 
.................... //	i2c_out_byte(0xC4); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(0x11); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(0x00); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(dimmer0); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(0x00); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(dimmer1); 
.................... //	i2c_nack(); 
.................... //	i2c_out_byte(dimmerCtrl); 
.................... //	i2c_nack(); 
.................... //	i2c_stop(); 
.................... //} 
....................  
.................... void RGBtoHSV(RGB* rgb, HSV* hsv) 
.................... { 
....................  
.................... } 
....................  
.................... void HSVtoRGB(HSV* hsv, RGB* rgb) 
.................... { 
*
1288:  MOV     W5,[W15++]
128A:  MOV     W6,[W15++]
128C:  MOV     #3,W0
128E:  ADD     9AC,W0
1290:  MOV.B   [W0],W5L
1292:  CLR.B   B
1294:  MOV     #2,W0
1296:  ADD     9AC,W0
1298:  MOV     W0,W4
129A:  MOV.B   [W4],W0L
129C:  CLR.B   1
129E:  MUL.UU  W5,W0,W0
12A0:  MOV     W0,9B0
12A2:  MOV     9B0,W0
12A4:  CALL    C3E
*
12B8:  MOV     W0,9B2
12BA:  MOV     W1,9B4
12BC:  MOV     #0,W0
12BE:  ADD     9AC,W0
12C0:  MOV     W0,W4
12C2:  MOV     [W4],W0
12C4:  CALL    D42
*
12D8:  MOV     W0,9B6
12DA:  MOV     W1,9B8
12DC:  PUSH    9B6
12DE:  POP     9D2
12E0:  PUSH    9B8
12E2:  POP     9D4
12E4:  CLR     9D6
12E6:  MOV     #4000,W4
12E8:  MOV     W4,9D8
12EA:  CALL    11FC
*
1304:  MOV     W5,W0
1306:  MOV     W6,W1
1308:  BCLR    W1.F
130A:  BSET.B  43.0
130C:  MOV     W0,W2
130E:  MOV     W1,W3
1310:  MOV     #0,W0
1312:  MOV     #3F80,W1
1314:  CALL    E20
1318:  MOV     W0,W2
131A:  MOV     W1,W3
131C:  MOV     9B2,W0
131E:  MOV     9B4,W1
1320:  CALL    FC0
1324:  MOV     W0,9BA
1326:  MOV     W1,9BC
1328:  CLR     9BE
132A:  CLR     9C0
132C:  CLR     9C2
132E:  CLR     9C4
1330:  CLR     9C6
1332:  CLR     9C8
.................... 	unsigned int cc = (unsigned int)(hsv->value) * (unsigned int)(hsv->saturation); 
.................... 	float c = (float)cc / 65025.0; 
.................... 	float h1 = (float)hsv->hue / 60.0; 
.................... 	//float h2 = h1 / 2; 
.................... 	//h2 -= (int)h2; 
.................... 	float x  = c * (1 - fabs(fmod(h1,2.0) - 1)); 
.................... 	float r1 = 0; 
.................... 	float g1 = 0; 
.................... 	float b1 = 0; 
.................... 	 
.................... 	if (hsv->hue < 60) 
1334:  MOV     #0,W0
1336:  ADD     9AC,W0
1338:  MOV     [W0],W5
133A:  MOV     #3C,W4
133C:  CP      W4,W5
133E:  BRA     LE,1352
.................... 	{ 
.................... 		r1 = c; 
1340:  PUSH    9B2
1342:  POP     9BE
1344:  PUSH    9B4
1346:  POP     9C0
.................... 		g1 = x; 
1348:  PUSH    9BA
134A:  POP     9C2
134C:  PUSH    9BC
134E:  POP     9C4
.................... 	} 
.................... 	else if (hsv->hue < 120) 
1350:  BRA     13E6
1352:  MOV     #0,W0
1354:  ADD     9AC,W0
1356:  MOV     [W0],W5
1358:  MOV     #78,W4
135A:  CP      W4,W5
135C:  BRA     LE,1370
.................... 	{ 
.................... 		r1 = x; 
135E:  PUSH    9BA
1360:  POP     9BE
1362:  PUSH    9BC
1364:  POP     9C0
.................... 		g1 = c; 
1366:  PUSH    9B2
1368:  POP     9C2
136A:  PUSH    9B4
136C:  POP     9C4
.................... 	} 
.................... 	else if (hsv->hue < 180) 
136E:  BRA     13E6
1370:  MOV     #0,W0
1372:  ADD     9AC,W0
1374:  MOV     [W0],W5
1376:  MOV     #B4,W4
1378:  CP      W4,W5
137A:  BRA     LE,138E
.................... 	{ 
.................... 		g1 = c; 
137C:  PUSH    9B2
137E:  POP     9C2
1380:  PUSH    9B4
1382:  POP     9C4
.................... 		b1 = x; 
1384:  PUSH    9BA
1386:  POP     9C6
1388:  PUSH    9BC
138A:  POP     9C8
....................  
.................... 	} 
.................... 	else if (hsv->hue < 240) 
138C:  BRA     13E6
138E:  MOV     #0,W0
1390:  ADD     9AC,W0
1392:  MOV     [W0],W5
1394:  MOV     #F0,W4
1396:  CP      W4,W5
1398:  BRA     LE,13AC
.................... 	{ 
.................... 		g1 = x; 
139A:  PUSH    9BA
139C:  POP     9C2
139E:  PUSH    9BC
13A0:  POP     9C4
.................... 		b1 = c; 
13A2:  PUSH    9B2
13A4:  POP     9C6
13A6:  PUSH    9B4
13A8:  POP     9C8
.................... 	} 
.................... 	else if (hsv->hue < 300) 
13AA:  BRA     13E6
13AC:  MOV     #0,W0
13AE:  ADD     9AC,W0
13B0:  MOV     [W0],W5
13B2:  MOV     #12C,W4
13B4:  CP      W4,W5
13B6:  BRA     LE,13CA
.................... 	{ 
.................... 		r1 = x; 
13B8:  PUSH    9BA
13BA:  POP     9BE
13BC:  PUSH    9BC
13BE:  POP     9C0
.................... 		b1 = c; 
13C0:  PUSH    9B2
13C2:  POP     9C6
13C4:  PUSH    9B4
13C6:  POP     9C8
.................... 	} 
.................... 	else if (hsv->hue <= 360) 
13C8:  BRA     13E6
13CA:  MOV     #0,W0
13CC:  ADD     9AC,W0
13CE:  MOV     [W0],W5
13D0:  MOV     #168,W4
13D2:  CP      W4,W5
13D4:  BRA     LT,13E6
.................... 	{ 
.................... 		r1 = c; 
13D6:  PUSH    9B2
13D8:  POP     9BE
13DA:  PUSH    9B4
13DC:  POP     9C0
.................... 		b1 = x; 
13DE:  PUSH    9BA
13E0:  POP     9C6
13E2:  PUSH    9BC
13E4:  POP     9C8
.................... 	} 
.................... 	 
.................... 	float m = ((float)(hsv->value) / 255) - c; 
13E6:  MOV     #3,W0
13E8:  ADD     9AC,W0
13EA:  MOV     W0,W4
13EC:  MOV.B   [W4],W0L
13EE:  CLR.B   1
13F0:  CALL    C3E
*
1416:  MOV     W0,9CA
1418:  MOV     W1,9CC
.................... 	 
.................... 	rgb->red   = (unsigned int)(255.0 * (r1+m)); 
141A:  MOV     #0,W0
141C:  ADD     9AE,W0
141E:  MOV     W0,W5
1420:  BCLR.B  43.0
1422:  MOV     9BE,W0
1424:  MOV     9C0,W1
1426:  MOV     9CA,W2
1428:  MOV     9CC,W3
142A:  CALL    E20
142E:  MOV     W0,W2
1430:  MOV     W1,W3
1432:  MOV     #0,W0
1434:  MOV     #437F,W1
1436:  CALL    FC0
143A:  CALL    DF4
143E:  MOV.B   W0L,[W5]
.................... 	rgb->green = (unsigned int)(255.0 * (g1+m)); 
1440:  MOV     #1,W0
1442:  ADD     9AE,W0
1444:  MOV     W0,W5
1446:  BCLR.B  43.0
1448:  MOV     9C2,W0
144A:  MOV     9C4,W1
144C:  MOV     9CA,W2
144E:  MOV     9CC,W3
1450:  CALL    E20
1454:  MOV     W0,W2
1456:  MOV     W1,W3
1458:  MOV     #0,W0
145A:  MOV     #437F,W1
145C:  CALL    FC0
1460:  CALL    DF4
1464:  MOV.B   W0L,[W5]
.................... 	rgb->blue  = (unsigned int)(255.0 * (b1+m)); 
1466:  MOV     #2,W0
1468:  ADD     9AE,W0
146A:  MOV     W0,W5
146C:  BCLR.B  43.0
146E:  MOV     9C6,W0
1470:  MOV     9C8,W1
1472:  MOV     9CA,W2
1474:  MOV     9CC,W3
1476:  CALL    E20
147A:  MOV     W0,W2
147C:  MOV     W1,W3
147E:  MOV     #0,W0
1480:  MOV     #437F,W1
1482:  CALL    FC0
1486:  CALL    DF4
148A:  MOV.B   W0L,[W5]
....................  
.................... } 
148C:  MOV     [--W15],W6
148E:  MOV     [--W15],W5
1490:  RETURN  
....................  
.................... void UpdateRGB_Out(RGB* rgb) 
.................... { 
1492:  MOV     W5,[W15++]
....................     rgb->cntr++; 
1494:  MOV     #3,W0
1496:  ADD     9AC,W0
1498:  MOV     W0,W5
149A:  INC.B   [W5],[W5]
....................      
....................     if ((rgb->red == 0)         && 
....................         (rgb->red  < rgb->cntr)) { 
149C:  MOV     #0,W0
149E:  ADD     9AC,W0
14A0:  CP0.B   [W0]
14A2:  BRA     NZ,14BC
14A4:  MOV     #0,W0
14A6:  ADD     9AC,W0
14A8:  MOV.B   [W0],W5L
14AA:  MOV     #3,W0
14AC:  ADD     9AC,W0
14AE:  MOV     W0,W4
14B0:  MOV.B   [W4],W0L
14B2:  CP.B    W5L,W0L
14B4:  BRA     C,14BC
....................         output_low(LED_R); 
14B6:  BCLR.B  2C6.7
14B8:  BCLR.B  2CA.7
....................     } else { 
14BA:  BRA     14C0
....................         output_high(LED_R); 
14BC:  BCLR.B  2C6.7
14BE:  BSET.B  2CA.7
....................     } 
....................      
....................     if ((rgb->green == 0)         && 
....................         (rgb->green  < rgb->cntr)) { 
14C0:  MOV     #1,W0
14C2:  ADD     9AC,W0
14C4:  CP0.B   [W0]
14C6:  BRA     NZ,14E0
14C8:  MOV     #1,W0
14CA:  ADD     9AC,W0
14CC:  MOV.B   [W0],W5L
14CE:  MOV     #3,W0
14D0:  ADD     9AC,W0
14D2:  MOV     W0,W4
14D4:  MOV.B   [W4],W0L
14D6:  CP.B    W5L,W0L
14D8:  BRA     C,14E0
....................         output_low(LED_G); 
14DA:  BCLR.B  2C6.1
14DC:  BCLR.B  2CA.1
....................     } else { 
14DE:  BRA     14E4
....................         output_high(LED_G); 
14E0:  BCLR.B  2C6.1
14E2:  BSET.B  2CA.1
....................     } 
....................      
....................     if ((rgb->blue == 0)         && 
....................         (rgb->blue  < rgb->cntr)) { 
14E4:  MOV     #2,W0
14E6:  ADD     9AC,W0
14E8:  CP0.B   [W0]
14EA:  BRA     NZ,1504
14EC:  MOV     #2,W0
14EE:  ADD     9AC,W0
14F0:  MOV.B   [W0],W5L
14F2:  MOV     #3,W0
14F4:  ADD     9AC,W0
14F6:  MOV     W0,W4
14F8:  MOV.B   [W4],W0L
14FA:  CP.B    W5L,W0L
14FC:  BRA     C,1504
....................         output_low(LED_B); 
14FE:  BCLR.B  2C6.0
1500:  BCLR.B  2CA.0
....................     } else { 
1502:  BRA     1508
....................         output_high(LED_B); 
1504:  BCLR.B  2C6.0
1506:  BSET.B  2CA.0
....................     } 
....................      
.................... } 
1508:  MOV     [--W15],W5
150A:  RETURN  
....................  
.................... void IncreaseHue(HSV* hsv) 
.................... { 
*
2E72:  MOV     W5,[W15++]
2E74:  MOV     W6,[W15++]
....................     hsv->hue = (++hsv->hue)%360; 
2E76:  MOV     #0,W0
2E78:  ADD     97E,W0
2E7A:  MOV     W0,W5
2E7C:  MOV     #0,W0
2E7E:  ADD     97E,W0
2E80:  MOV     W0,W6
2E82:  INC     [W6],[W6]
2E84:  MOV     [W6],W4
2E86:  MOV     #168,W3
2E88:  REPEAT  #11
2E8A:  DIV.S   W4,W3
2E8C:  MOV     W1,W0
2E8E:  MOV     W0,[W5]
.................... } 
2E90:  MOV     [--W15],W6
2E92:  MOV     [--W15],W5
2E94:  RETURN  
....................  
.................... //void refreshRGB() 
.................... //{ 
.................... //	int8 lowColor = 0; 
.................... //    int8 trial    = 0; 
.................... //     
.................... //	HSVtoRGB(&hsvColor,&rgbColor); 
.................... //	 
.................... //	unsigned int8 minimum = 255; 
.................... //	 
.................... //	if (rgbColor.red < minimum)   minimum = rgbColor.red; 
.................... //	if (rgbColor.green < minimum) minimum = rgbColor.green; 
.................... //	if (rgbColor.blue < minimum) 
.................... //	{ 
.................... //		minimum = rgbColor.blue; 
.................... //		lowColor = CFG_BLUE; 
.................... //	} 
.................... //	else if (rgbColor.green == minimum) 
.................... //	{ 
.................... //		lowColor = CFG_GREEN; 
.................... //	} 
.................... //	else 
.................... //	{ 
.................... //		lowColor = CFG_RED; 
.................... //	} 
.................... //	 
.................... //	switch(lowColor) 
.................... //	{ 
.................... //		case CFG_RED: 
.................... //			dimmer0 = rgbColor.green; 
.................... //			dimmer1 = rgbColor.blue; 
.................... //			if (rgbColor.red < 128) 
.................... //			{ 
.................... //				dimmerCtrl = CFG_RED_OFF | CFG_GRN_PW0 | CFG_BLU_PW1; 
.................... //			} 
.................... //			else { 
.................... //				dimmerCtrl = CFG_RED_ON  | CFG_GRN_PW0 | CFG_BLU_PW1; 
.................... //			} 
.................... //			break; 
.................... //		case CFG_GREEN: 
.................... //			dimmer0 = rgbColor.red; 
.................... //			dimmer1 = rgbColor.blue; 
.................... //			if (rgbColor.green < 128) 
.................... //			{ 
.................... //				dimmerCtrl = CFG_RED_PW0 | CFG_GRN_OFF | CFG_BLU_PW1; 
.................... //			} 
.................... //			else { 
.................... //				dimmerCtrl = CFG_RED_PW0 | CFG_GRN_ON  | CFG_BLU_PW1; 
.................... //			} 
.................... //			break; 
.................... //		case CFG_BLUE: 
.................... //			dimmer0 = rgbColor.red; 
.................... //			dimmer1 = rgbColor.green; 
.................... //			if (rgbColor.blue < 128) 
.................... //			{ 
.................... //				dimmerCtrl = CFG_RED_PW0 | CFG_GRN_PW1 | CFG_BLU_OFF; 
.................... //			} 
.................... //			else { 
.................... //				dimmerCtrl = CFG_RED_PW0 | CFG_GRN_PW1 | CFG_BLU_ON; 
.................... //			} 
.................... //			break; 
.................... //	} 
.................... //	 
.................... //	//update PCA9533 chip 
.................... //     
.................... //    //for (trial = 0 ; trial < I2C_MAX_TRIAL ; trial++) { 
.................... //    //    updatePCA9533();    
.................... //    //} 
.................... //     
.................... //    UpdateRGB_Out(); 
.................... //} 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "LumMonitor.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... unsigned int16 ADC_LUM_AMB = 0; 
.................... //int16 ADC_BAT_MON = 0; 
....................  
.................... void initLumMonitor() 
.................... { 
.................... 	SETUP_ADC(ADC_CLOCK_INTERNAL); 
*
0ADC:  MOV     #80,W4
0ADE:  MOV     W4,2A4
0AE0:  MOV     #80E0,W4
0AE2:  MOV     W4,2A0
.................... 	SETUP_ADC_PORTS(sAN6|sAN7	,VSS_VDD); 
0AE4:  MOV     #FF3F,W4
0AE6:  MOV     W4,2A8
0AE8:  CLR     2A2
.................... } 
0AEA:  RETURN  
....................  
.................... void readLumMonitor() 
.................... { 
.................... 	set_adc_channel(6); 
*
1C00:  MOV     #6,W4
1C02:  MOV     W4,2A6
.................... 	delay_us(100); 
1C04:  REPEAT  #B94
1C06:  NOP     
.................... 	ADC_LUM_AMB = read_adc(); 
1C08:  BCLR.B  2A0.0
1C0A:  BSET.B  2A0.1
1C0C:  BTSS.B  2A0.0
1C0E:  BRA     1C0C
1C10:  MOV     280,W0
1C12:  SL      W0,#6,W0
1C14:  MOV     W0,962
....................      
....................     if ((enableLCD)                                                             && 
....................         (ADC_LUM_AMB < LUM_LCD_OFF_THRESHOLD_LOW)                               && 
....................         !insideMenu                                                             && 
....................         (alarmData.CurrentBinaryTime >= (lastUserPush + PUSH_BUTTON_TIMEOUT_SEC))) { 
1C16:  BTSS.B  885.4
1C18:  BRA     1C46
1C1A:  MOV     962,W4
1C1C:  MOV     #400,W3
1C1E:  CP      W3,W4
1C20:  BRA     LEU,1C46
1C22:  BTSC.B  885.0
1C24:  BRA     1C46
1C26:  MOV     95E,W4
1C28:  ADD     W4,#A,W4
1C2A:  MOV     W4,W0
1C2C:  MOV     960,W4
1C2E:  ADDC    W4,#0,W4
1C30:  MOV     W4,W1
1C32:  MOV     868,W4
1C34:  CP      W4,W1
1C36:  BRA     NC,1C46
1C38:  BRA     GTU,1C40
1C3A:  MOV     866,W4
1C3C:  CP      W4,W0
1C3E:  BRA     NC,1C46
....................         shutdownLCD(); 
1C40:  CALL    1BF2
....................     } else if (!enableLCD                                  &&  
1C44:  BRA     1C70
....................                ((ADC_LUM_AMB > LUM_LCD_OFF_THRESHOLD_HIGH) || 
....................                 (alarmData.CurrentBinaryTime < (lastUserPush + PUSH_BUTTON_TIMEOUT_SEC)))) { 
1C46:  BTSC.B  885.4
1C48:  BRA     1C70
1C4A:  MOV     962,W4
1C4C:  MOV     #800,W3
1C4E:  CP      W3,W4
1C50:  BRA     NC,1C6C
1C52:  MOV     95E,W4
1C54:  ADD     W4,#A,W4
1C56:  MOV     W4,W0
1C58:  MOV     960,W4
1C5A:  ADDC    W4,#0,W4
1C5C:  MOV     W4,W1
1C5E:  MOV     868,W4
1C60:  CP      W4,W1
1C62:  BRA     GTU,1C70
1C64:  BRA     NC,1C6C
1C66:  MOV     866,W4
1C68:  CP      W4,W0
1C6A:  BRA     C,1C70
....................         initLCD(); 
1C6C:  CALL    B74
....................     } 
.................... } 
1C70:  RETURN  
....................  
.................... #include "LoadControl.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... //#define timeArraySize 1 
.................... #define PHASE_STATS_SIZE 16 
....................  
.................... //int1  firstRun = true; 
.................... //int16 phaseStats [PHASE_STATS_SIZE]; 
.................... int8  phaseStatsIndex     = 0; 
.................... int1  previousSyncSatus   = 0; 
.................... int16 syncTransitions     = 0; 
.................... int1  currentSyncStatus   = 0; 
.................... int1  pushButtonStates[3] = {0, 0, 0}; 
*
2FE2:  CLR     967
.................... int1  pushAck             = false; 
.................... int1  pushLongAck         = false; 
....................  
.................... //int16 highTime[timeArraySize]; 
.................... //int16 lowTime[timeArraySize]; 
....................  
.................... //int16 highTime; 
.................... //int16 lowTime; 
....................  
.................... //int16 lowTimeMon = 0; 
.................... //int16 highTimeMon = 0; 
....................  
.................... //int8 highTimeIndex = 0; 
.................... //int8 lowTimeIndex = 0; 
....................  
.................... //int32 highTimeSum = 0; 
.................... //int32 lowTimeSum = 0; 
....................  
.................... WORD_VAL highTimeLocal; 
.................... WORD_VAL  lowTimeLocal; 
....................  
.................... //const int16 PowerLUT[11] = 	{35075, 42970, 45310, 47156, 
.................... //48764, 50307, 51842, 53461, 55293, 57650, 65535}; 
.................... 						  
.................... #define DEFAULT_PULSE_PHASE_OFFSET  0 
.................... #define DEFAULT_PULSE_WIDTH_DEFAULT 93                  /* 25 us.                               */ 
....................  
.................... #define PHASE_WAIT 0 
.................... #define PULSE_WAIT 1 
....................  
.................... int1 pulseState = PHASE_WAIT; 
....................  
.................... /* 
....................  unsigned int16 pulseWidth  = PMW_PULSE_WIDTH_DEFAULT; 
....................  unsigned int16 phaseOffset = PWM_PULSE_PHASE_OFFSET; 
.................... */ 
.................... static   float  light_t_on = 0.0f;                      /* 0 to 8.6 ms scale.						*/ 
.................... unsigned long   light_on_time; 
....................          float  light_power;                            /* 0 to 1 scale.							*/ 
.................... 						  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                              CNI_isr() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description  : Provides reference for the Zero-Crossing of the AC sector signal. 
....................  * 
....................  * Arguments    : none. 
....................  *  
....................  * Caller       : External Interrupt. 
....................  * 
....................  * Returns      : none. 
....................  *  
....................  * Notes        : (1)   currentSyncStatus provides status on AC phase location: 
....................  *                          LOW     Enters Zero-Crossing 
....................  *                          HIGH    Leaves Zero-Crossing 
....................  * 
....................  *                (2)   If  
....................  ***************************************************************************************************** 
....................  */  
.................... #int_CNI HIGH 
.................... void  CNI_isr(void)  
.................... { 
*
031E:  PUSH    42
0320:  PUSH    36
0322:  MOV     W0,[W15++]
0324:  MOV     #2,W0
0326:  REPEAT  #C
0328:  MOV     [W0++],[W15++]
.................... 	currentSyncStatus = input(SYNC); 
032A:  BSET.B  2C6.3
032C:  BCLR.B  966.0
032E:  BTSC.B  2C8.3
0330:  BSET.B  966.0
.................... 	 
.................... 	//Load Control 
.................... 	pulseState = PHASE_WAIT;                            /* TODO: Depricate pulseState           */ 
0332:  BCLR.B  966.3
....................                                                         /* Setup TMR4 & PR4 to wait for trigg.  */ 
....................     TMR4 = 0; 
0334:  CLR     114
.................... 	PR4  = LoadStruct.PhaseOffset; 
0336:  PUSH    8E2
0338:  POP     11A
....................      
....................     TMR4IntrCnt2++; 
033A:  INC     08EA
....................      
....................     if(currentSyncStatus) { 
033C:  BTSS.B  966.0
033E:  BRA     346
....................         LoadStruct.LoadState = LS_OFF_WAIT_TURN_ON; 
0340:  MOV.B   #1,W0L
0342:  MOV.B   W0L,8E6
....................         enable_interrupts(INT_TIMER4); 
0344:  BSET.B  8E.5
.................... 	}  
....................     //else { 
....................     //    TurnTriacOff(); 
....................     //} 
....................  
....................                                                         /* Evaluate Pushbutton state.           */ 
....................     pushButtonStates[2] = pushButtonStates[1]; 
0346:  BCLR.B  967.2
0348:  BTSC.B  967.1
034A:  BSET.B  967.2
....................     pushButtonStates[1] = pushButtonStates[0]; 
034C:  BCLR.B  967.1
034E:  BTSC.B  967.0
0350:  BSET.B  967.1
....................     pushButtonStates[0] = input(PUSH); 
0352:  BSET.B  2C6.2
0354:  BCLR.B  967.0
0356:  BTSC.B  2C8.2
0358:  BSET.B  967.0
....................      
....................     if ((pushButtonStates[0] == false) &&  
....................         (pushButtonStates[1] == false) &&  
....................         (pushButtonStates[2] == true)) {                /* On push up.                          */ 
035A:  BTSC.B  967.0
035C:  BRA     38E
035E:  BTSC.B  967.1
0360:  BRA     38E
0362:  BTSS.B  967.2
0364:  BRA     38E
....................      
....................         if (alarmData.ButtonDownTick >= RTCC_STANDBY_TIMEOUT) { 
0366:  MOV     874,W4
0368:  CP      W4,#0
036A:  BRA     NC,37C
036C:  BRA     GTU,376
036E:  MOV     872,W4
0370:  MOV     #B4,W3
0372:  CP      W3,W4
0374:  BRA     GTU,37C
....................             pushLongAck = true; 
0376:  BSET.B  966.2
....................             pushAck     = false; 
0378:  BCLR.B  966.1
....................         } else { 
037A:  BRA     384
....................             pushLongAck = false; 
037C:  BCLR.B  966.2
....................             pushAck     = true; 
037E:  BSET.B  966.1
....................             alarmData.ButtonDownTick = 0; 
0380:  CLR     872
0382:  CLR     874
....................         } 
....................         lastUserPush = alarmData.CurrentBinaryTime; 
0384:  PUSH    866
0386:  POP     95E
0388:  PUSH    868
038A:  POP     960
....................          
....................     } else if ((pushButtonStates[0] == true) &&  
038C:  BRA     3A0
....................                (pushButtonStates[1] == true) &&  
....................                (pushButtonStates[2] == true)) { 
038E:  BTSS.B  967.0
0390:  BRA     3A0
0392:  BTSS.B  967.1
0394:  BRA     3A0
0396:  BTSS.B  967.2
0398:  BRA     3A0
....................          
....................         alarmData.ButtonDownTick++; 
039A:  INC     0872
039C:  BTSC.B  42.1
039E:  INC     0874
....................          
....................     } 
.................... 	 
.................... 	phaseStatsIndex = (++phaseStatsIndex)%PHASE_STATS_SIZE; 
03A0:  INC.B   0927
03A2:  MOV.B   927,W0L
03A4:  CLR.B   1
03A6:  CLR.B   1
03A8:  MOV     #10,W4
03AA:  SE      W0,W0
03AC:  REPEAT  #11
03AE:  DIV.S   W0,W4
03B0:  MOV.B   W1L,W0L
03B2:  MOV.B   W0L,927
....................  
.................... } 
....................  
03B4:  BCLR.B  85.7
03B6:  MOV     #1A,W0
03B8:  REPEAT  #C
03BA:  MOV     [--W15],[W0--]
03BC:  MOV     [--W15],W0
03BE:  POP     36
03C0:  POP     42
03C2:  RETFIE  
.................... #int_TIMER4 HIGH 
.................... void TIMER4_isr(void) 
.................... { 
*
03FC:  PUSH    42
03FE:  PUSH    36
0400:  MOV     W0,[W15++]
0402:  MOV     #2,W0
0404:  REPEAT  #C
0406:  MOV     [W0++],[W15++]
....................     TMR4IntrCnt1++; 
0408:  INC     08E8
....................      
....................     switch (LoadStruct.LoadState) { 
040A:  MOV.B   8E6,W0L
040C:  CLR.B   1
040E:  XOR     #0,W0
0410:  BRA     Z,420
0412:  XOR     #1,W0
0414:  BRA     Z,424
0416:  XOR     #3,W0
0418:  BRA     Z,434
041A:  XOR     #1,W0
041C:  BRA     Z,44C
041E:  BRA     44E
....................         case LS_OFF: 
....................             disable_interrupts(INT_TIMER4); 
0420:  BCLR.B  8E.5
....................             break; 
0422:  BRA     44E
....................         case LS_OFF_WAIT_TURN_ON: 
....................             PR4  = LoadStruct.PulseWidth;                
0424:  PUSH    8E4
0426:  POP     11A
....................             TMR2 = 0; 
0428:  CLR     106
....................             TurnTriacOn();;                      /* Turn Triac On.                           */ 
042A:  CALL    3CA
....................             LoadStruct.LoadState = LS_ON;               /* Change LoadState to LS_ON.               */ 
042E:  MOV.B   #2,W0L
0430:  MOV.B   W0L,8E6
....................             break; 
0432:  BRA     44E
....................         case LS_ON: 
....................             if (TMR2 >= RTCC_PW_TH_MAX) { 
0434:  MOV     106,W4
0436:  MOV     #67,W3
0438:  CP      W3,W4
043A:  BRA     GTU,442
....................                 alarmData.PulseWidthErr++; 
043C:  INC     086E
043E:  BTSC.B  42.1
0440:  INC     0870
....................             } 
....................             TurnTriacOff();                     /* Turn Triac Off.                          */ 
0442:  CALL    3E6
....................             LoadStruct.LoadState = LS_OFF_WAIT_ZERO_X;  /* Change LoadState to LS_OFF_WAIT_ZERO_X.  */ 
0446:  MOV.B   #3,W0L
0448:  MOV.B   W0L,8E6
....................             break; 
044A:  BRA     44E
....................         case LS_OFF_WAIT_ZERO_X: 
....................             break; 
044C:  BRA     44E
....................     } 
.................... } 
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                              InitRTCC() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Initialize the output load controller. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : main(). 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */  
044E:  BCLR.B  86.5
0450:  MOV     #1A,W0
0452:  REPEAT  #C
0454:  MOV     [--W15],[W0--]
0456:  MOV     [--W15],W0
0458:  POP     36
045A:  POP     42
045C:  RETFIE  
.................... void InitLoadControl(void) 
.................... { 
....................     TurnTriacOff();                                     /* Turn Triac Off.                          */ 
*
0850:  PUSH    42
0852:  SETM.B  42
0854:  CALL    3E6
0858:  POP     42
....................                                                         /* Init. TimeLocal vars for phase stats.    */ 
.................... 	lowTimeLocal.Val = 0; 
085A:  CLR     96A
.................... 	highTimeLocal.Val = 0; 
085C:  CLR     968
....................                                                         /* Enable interrupt on change.              */ 
.................... 	CN5IE = true; 
085E:  BSET.B  C0.5
....................                                                         /* Disable pin pull-up.                     */ 
.................... 	CN5PUE = false; 
0860:  BCLR.B  C4.5
....................  
.................... 	setup_timer2(TMR_INTERNAL |TMR_DIV_BY_8 , 0xFFFF); 
0862:  CLR     110
0864:  SETM    10C
0866:  MOV     #A010,W4
0868:  MOV     W4,110
.................... 	 
....................                                                         /* Init TMR4 with lowest freq. possible.    */ 
.................... 	TMR4  = 0; 
086A:  CLR     114
.................... 	PR4   = 0xFFFF; 
086C:  SETM    11A
.................... 	T4CON = T4CON_INIT; 
086E:  MOV     #8010,W4
0870:  MOV     W4,11E
....................      
....................     TMR2  = TMR4; 
0872:  PUSH    114
0874:  POP     106
....................     PR2   = 0xFFFF; 
0876:  SETM    10C
....................     T2CON = T4CON_INIT; 
0878:  MOV     #8010,W4
087A:  MOV     W4,110
....................      
....................     LoadStruct.PhaseOffset = DEFAULT_PULSE_PHASE_OFFSET; 
087C:  CLR     8E2
....................     LoadStruct.PulseWidth  = DEFAULT_PULSE_WIDTH_DEFAULT; 
087E:  MOV     #5D,W4
0880:  MOV     W4,8E4
....................     LoadStruct.LoadState   = LS_OFF; 
0882:  CLR.B   8E6
....................     LoadStruct.TriacState  = false; 
0884:  BCLR.B  8E7.0
.................... } 
0886:  RETURN  
....................  
.................... void CalculateLuminosity() 
.................... { 
*
1678:  MOV     W5,[W15++]
167A:  MOV     W6,[W15++]
....................                                                         /* ---------- COMPUTE LIGHT POWER --------- */ 
....................                                                         /* Check if light should be on              */ 
.................... 	light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul; 
167C:  MOV     8E0,W5
167E:  SE      W5,W5
1680:  CLR     W6
1682:  BTSC    W5.F
1684:  SETM    W6
1686:  PUSH    42
1688:  SETM.B  42
168A:  MOV     W5,W0
168C:  MOV     W6,W1
168E:  MOV     #3C,W2
1690:  MOV     #0,W3
1692:  CALL    50A
1696:  POP     42
1698:  MOV     85E,W4
169A:  SUB     W4,W0,W0
169C:  MOV     W0,970
169E:  MOV     860,W4
16A0:  SUBB    W4,W1,W0
16A2:  MOV     W0,972
.................... 	 
....................     /* If the time is within the ramp section.	*/ 
.................... 	if ((alarmData.CurrentBinaryTime >= light_on_time) && 
.................... 	    (alarmData.CurrentBinaryTime <= alarmData.SnoozeBinaryTime)) { 
16A4:  MOV     972,W0
16A6:  MOV     868,W4
16A8:  CP      W4,W0
16AA:  BRA     NC,17A4
16AC:  BRA     GTU,16B6
16AE:  MOV     970,W0
16B0:  MOV     866,W4
16B2:  CP      W4,W0
16B4:  BRA     NC,17A4
16B6:  MOV     868,W0
16B8:  MOV     860,W4
16BA:  CP      W4,W0
16BC:  BRA     NC,17A4
16BE:  BRA     GTU,16C8
16C0:  MOV     866,W0
16C2:  MOV     85E,W4
16C4:  CP      W4,W0
16C6:  BRA     NC,17A4
....................          
....................                                                         /* Compute ramp location.					*/ 
....................         light_power  = (float)(alarmData.CurrentBinaryTime - light_on_time); 
16C8:  MOV     866,W4
16CA:  MOV     970,W3
16CC:  SUB     W4,W3,W0
16CE:  MOV     868,W4
16D0:  MOV     972,W3
16D2:  SUBB    W4,W3,W1
16D4:  CALL    1554
16D8:  MOV     W0,974
16DA:  MOV     W1,976
....................         light_power /= 60.0;                            /* Ramp power.								*/ 
16DC:  MOV     974,W0
16DE:  MOV     976,W1
16E0:  MOV     #0,W2
16E2:  MOV     #4270,W3
16E4:  CALL    C78
16E8:  MOV     W0,974
16EA:  MOV     W1,976
....................         light_power /= (float)delayLoadLighting; 
16EC:  MOV.B   8E0,W0L
16EE:  SE      W0,W0
16F0:  CALL    D42
16F4:  MOV     W0,W2
16F6:  MOV     W1,W3
16F8:  MOV     974,W0
16FA:  MOV     976,W1
16FC:  CALL    C78
1700:  MOV     W0,974
1702:  MOV     W1,976
....................         light_power *= (float)maxLoadLighting;          /* Adjust for user defined max power.       */ 
1704:  MOV.B   8BF,W0L
1706:  SE      W0,W0
1708:  CALL    D42
170C:  MOV     W0,W2
170E:  MOV     W1,W3
1710:  MOV     974,W0
1712:  MOV     976,W1
1714:  CALL    FC0
1718:  MOV     W0,974
171A:  MOV     W1,976
....................         light_power /= 100.0f; 
171C:  MOV     974,W0
171E:  MOV     976,W1
1720:  MOV     #0,W2
1722:  MOV     #42C8,W3
1724:  CALL    C78
1728:  MOV     W0,974
172A:  MOV     W1,976
....................                                                         /* Equivalent Triac On-Time.				*/ 
....................         light_t_on = PowerToTimeOn(light_power); 
172C:  PUSH    974
172E:  POP     99A
1730:  PUSH    976
1732:  POP     99C
1734:  CALL    158C
1738:  MOV     W0,96C
173A:  MOV     W1,96E
....................                                                         /* Delay in ms to sustain such On-Time.		*/ 
....................         light_t_on = 8.3333333f - light_t_on; 
173C:  BSET.B  43.0
173E:  MOV     #5555,W0
1740:  MOV     #4105,W1
1742:  MOV     96C,W2
1744:  MOV     96E,W3
1746:  CALL    E20
174A:  MOV     W0,96C
174C:  MOV     W1,96E
....................      
....................                                                         /* Convert Delay to PR4 Value where:        */ 
....................                                                         /* ... fosc    = 118.6622 MHz               */ 
....................                                                         /* ... TMR4scr = fosc / 4                   */ 
....................                                                         /* ... TMR4scr =  29.6655 MHz               */ 
....................                                                         /* ... TMR4tck = TMR4scr / 8                */ 
....................                                                         /* ... TMR4tck =  3.708   MHz = 269.673 ns. */ 
....................      
....................                                                         /* PR4 max per = 8.333 ms (120 Hz)          */ 
....................                                                         /* PR4 max per = 30901 ticks.               */ 
....................          
....................          
....................          
....................         if ((alarmData.CurrentBinaryTime - light_on_time) >= 10) { 
174E:  MOV     866,W4
1750:  MOV     970,W3
1752:  SUB     W4,W3,W5
1754:  MOV     868,W4
1756:  MOV     972,W3
1758:  SUBB    W4,W3,W6
175A:  CP      W6,#0
175C:  BRA     NC,17A4
175E:  BRA     GTU,1764
1760:  CP      W5,#A
1762:  BRA     NC,17A4
....................             if (light_t_on <= 0.0f) {                   /* Underflow.                               */ 
1764:  MOV     96C,W0
1766:  MOV     96E,W1
1768:  MOV     #0,W2
176A:  MOV     #0,W3
176C:  CALL    D8C
1770:  BRA     C,1774
1772:  BRA     NZ,177E
....................                 LoadStruct.PhaseOffset = LS_MAX_DELAY; 
1774:  MOV     #61A8,W4
1776:  MOV     W4,8E2
....................                 LoadStruct.LoadState   = LS_OFF_WAIT_TURN_ON; 
1778:  MOV.B   #1,W0L
177A:  MOV.B   W0L,8E6
....................             } else if (light_t_on > 8.33333f) {         /* Overflow.                                */ 
177C:  BRA     17A4
177E:  MOV     #5552,W0
1780:  MOV     #4105,W1
1782:  MOV     96C,W2
1784:  MOV     96E,W3
1786:  CALL    D8C
178A:  BRA     NC,1792
....................                 LoadStruct.PhaseOffset = 10;            /* Always On.                               */ 
178C:  MOV     #A,W4
178E:  MOV     W4,8E2
....................             } else { 
1790:  BRA     17A4
....................                 LoadStruct.PhaseOffset = (unsigned int16)(light_t_on * 3708f); 
1792:  MOV     96C,W0
1794:  MOV     96E,W1
1796:  MOV     #C000,W2
1798:  MOV     #4567,W3
179A:  CALL    FC0
179E:  CALL    DF4
17A2:  MOV     W0,8E2
....................             } 
....................         } 
....................     } 
.................... } 
17A4:  MOV     [--W15],W6
17A6:  MOV     [--W15],W5
17A8:  RETURN  
....................  
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                            SetLampIntensity() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Set the lamp intensity. 
....................  * 
....................  * Arguments   : intensity      Lamp intensity [0, 1] 
....................  *  
....................  * Caller      : various. 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */  
.................... void SetLampIntensity(float intensity) 
.................... { 
17AA:  MOV     W5,[W15++]
17AC:  MOV     W6,[W15++]
17AE:  MOV.B   8BF,W0L
17B0:  SE      W0,W0
17B2:  CALL    D42
*
17D6:  MOV     W0,992
17D8:  MOV     W1,994
....................     float userDefinedPower = (float)maxLoadLighting * intensity / 100.0f; 
....................     light_t_on = PowerToTimeOn(userDefinedPower); 
17DA:  PUSH    992
17DC:  POP     99A
17DE:  PUSH    994
17E0:  POP     99C
17E2:  CALL    158C
17E6:  MOV     W0,96C
17E8:  MOV     W1,96E
....................     light_t_on = 8.3333333f - light_t_on; 
17EA:  BSET.B  43.0
17EC:  MOV     #5555,W0
17EE:  MOV     #4105,W1
17F0:  MOV     96C,W2
17F2:  MOV     96E,W3
17F4:  CALL    E20
17F8:  MOV     W0,96C
17FA:  MOV     W1,96E
....................     LoadStruct.PhaseOffset = (unsigned int16)(light_t_on * 3708f); 
17FC:  MOV     96C,W0
17FE:  MOV     96E,W1
1800:  MOV     #C000,W2
1802:  MOV     #4567,W3
1804:  CALL    FC0
1808:  CALL    DF4
180C:  MOV     W0,8E2
.................... } 
180E:  MOV     [--W15],W6
1810:  MOV     [--W15],W5
1812:  RETURN  
....................  
.................... void monitorSync() 
.................... { 
.................... 	int1 currentSyncSatus = input(SYNC); 
.................... 	if (currentSyncSatus != previousSyncSatus) 
.................... 	{ 
.................... 		syncTransitions++; 
.................... 		previousSyncSatus = currentSyncSatus; 
.................... 	} 
.................... } 
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                            TurnTriacOn() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Turn Triac On. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : various. 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */ 
.................... void TurnTriacOn(void) 
.................... { 
*
03CA:  MOV     W5,[W15++]
....................     if (LoadStruct.TriacState == true) { 
03CC:  BTSS.B  8E7.0
03CE:  BRA     3D6
....................         alarmData.PulseWidthErr++; 
03D0:  INC     086E
03D2:  BTSC.B  42.1
03D4:  INC     0870
....................     } 
....................     TurnLoadCtrlLow(); 
03D6:  CALL    3C4
....................     LoadStruct.TriacState = true; 
03DA:  BSET.B  8E7.0
.................... } 
03DC:  MOV     [--W15],W5
03DE:  RETURN  
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                         TurnLoadCtrlLow() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Turn Triac On. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : various. 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */ 
.................... void TurnLoadCtrlLow(void) 
.................... { 
....................     output_low(LOAD_CTRL); 
*
03C4:  BCLR.B  2D8.0
03C6:  BCLR.B  2DC.0
....................     //output_low(ENCA); 
.................... } 
03C8:  RETURN  
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                         TurnLoadCtrlLow() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Turn Triac On. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : various. 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */ 
.................... void TurnLoadCtrlHigh(void) 
.................... { 
....................     output_high(LOAD_CTRL); 
*
03E0:  BCLR.B  2D8.0
03E2:  BSET.B  2DC.0
....................     //output_high(ENCA); 
.................... } 
03E4:  RETURN  
....................  
.................... /* 
....................  ***************************************************************************************************** 
....................  *                                            TurnTriacOff() 
....................  ***************************************************************************************************** 
....................  * 
....................  * Description : Turn Triac Off. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : various. 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ***************************************************************************************************** 
....................  */ 
.................... void TurnTriacOff(void) 
.................... { 
03E6:  MOV     W5,[W15++]
....................     if (LoadStruct.TriacState == false) { 
03E8:  BTSC.B  8E7.0
03EA:  BRA     3F2
....................         alarmData.PulseWidthErr++; 
03EC:  INC     086E
03EE:  BTSC.B  42.1
03F0:  INC     0870
....................     } 
....................     TurnLoadCtrlHigh(); 
03F2:  CALL    3E0
....................     LoadStruct.TriacState = false; 
03F6:  BCLR.B  8E7.0
.................... } 
03F8:  MOV     [--W15],W5
03FA:  RETURN  
....................  
.................... //void calculateSyncDuty() 
.................... //{ 
.................... //	int i; 
.................... //	lowTimeSum = 0; 
.................... //	highTimeSum = 0; 
.................... //	 
.................... //	for ( i = 0 ; i < timeArraySize ; i++) 
.................... //	{ 
.................... //		lowTimeSum+=((int32)lowTime[i]); 
.................... //		highTimeSum+=((int32)highTime[i]); 
.................... //	} 
.................... //	//if (PUSH_value) 
.................... //	//{ 
.................... //	// 
.................... //	//} 
.................... //} 
....................  
.................... //int16 getTMRLoadValue(int16 grade) 
.................... //{ 
.................... //	if((grade < 11) & (grade >=0)) 
.................... //		return PowerLUT[grade]; 
.................... //	else 
.................... //		return PowerLUT[5]; 
.................... //} 
....................  
.................... /* 
.................... PWM DRIVE 
.................... //	PTCKPS0 = 1; 
.................... //	PTCKPS1 = 1; 
.................... //		 
.................... //	PTPER = 0x0411; 
.................... //	//PDC1  = 0x0080; 
.................... //	PWM1H = 1; 
.................... //	PTEN = 1; 
.................... */ 
....................  
.................... #include "LCDDriver.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... void initLCD() 
.................... { 
....................                                                         /* Power on the LCD.                        */ 
....................     output_low(SHDN_5V); 
*
0B74:  BCLR.B  2C7.0
0B76:  BCLR.B  2CB.0
....................      
....................     //output_high(SHDN_5V);                               /* Disable LCD (DEBUG)                      */ 
....................      
....................     delay_ms(500); 
0B78:  MOV     #1F4,W0
0B7A:  CALL    AEC
....................     enableLCD = true; 
0B7E:  BSET.B  885.4
....................      
.................... 	//Init LCD IO 
.................... 	output_high(STB); 
0B80:  BCLR.B  2D8.5
0B82:  BSET.B  2DC.5
.................... 	output_high(SCK); 
0B84:  BCLR.B  2D8.3
0B86:  BSET.B  2DC.3
.................... 	output_high(SISO); 
0B88:  BCLR.B  2D8.4
0B8A:  BSET.B  2DC.4
.................... 	 
.................... 	delay_us(1); 
0B8C:  REPEAT  #1B
0B8E:  NOP     
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_FCT_DFT|LCD_FCT_25); 
0B90:  MOV.B   #F8,W0L
0B92:  MOV.B   W0L,9B4
0B94:  MOV.B   #2B,W0L
0B96:  MOV.B   W0L,9B5
0B98:  CALL    B2C
....................     delay_us(1); 
0B9C:  REPEAT  #1B
0B9E:  NOP     
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_CLEAR); //CLEAR LCD 
0BA0:  MOV.B   #F8,W0L
0BA2:  MOV.B   W0L,9B4
0BA4:  MOV.B   #1,W0L
0BA6:  MOV.B   W0L,9B5
0BA8:  CALL    B2C
.................... 	delay_ms(40); 
0BAC:  MOV     #28,W0
0BAE:  CALL    AEC
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM); //SET CURSOR TO HOME  
0BB2:  MOV.B   #F8,W0L
0BB4:  MOV.B   W0L,9B4
0BB6:  MOV.B   #2,W0L
0BB8:  MOV.B   W0L,9B5
0BBA:  CALL    B2C
.................... 	//delay_us(1); 
.................... 	//writeToLCD(LCD_WRITE_CFG,LCD_CSR_BHV); 
.................... 	delay_us(1); 
0BBE:  REPEAT  #1B
0BC0:  NOP     
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_EMS_DFLT); //SET DEFAULT ENTRY MODE 
0BC2:  MOV.B   #F8,W0L
0BC4:  MOV.B   W0L,9B4
0BC6:  MOV.B   #6,W0L
0BC8:  MOV.B   W0L,9B5
0BCA:  CALL    B2C
.................... 	delay_us(1); 
0BCE:  REPEAT  #1B
0BD0:  NOP     
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_BOFF); //SET DISPLAY  
0BD2:  MOV.B   #F8,W0L
0BD4:  MOV.B   W0L,9B4
0BD6:  MOV.B   #C,W0L
0BD8:  MOV.B   W0L,9B5
0BDA:  CALL    B2C
.................... 	delay_us(1); 
0BDE:  REPEAT  #1B
0BE0:  NOP     
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_ADDR_SET);  //SET ADDR to 0x00 
0BE2:  MOV.B   #F8,W0L
0BE4:  MOV.B   W0L,9B4
0BE6:  MOV.B   #80,W0L
0BE8:  MOV.B   W0L,9B5
0BEA:  CALL    B2C
.................... 	 
.................... 	delay_us(1); 
0BEE:  REPEAT  #1B
0BF0:  NOP     
....................  
.................... 	int i; 
....................  
.................... 	//Clear LCD DDRAM 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM); 
0BF2:  MOV.B   #F8,W0L
0BF4:  MOV.B   W0L,9B4
0BF6:  MOV.B   #2,W0L
0BF8:  MOV.B   W0L,9B5
0BFA:  CALL    B2C
.................... 	for (i = 0 ; i < 0xFF ; i++) 
0BFE:  CLR     97E
0C00:  MOV     97E,W4
0C02:  MOV     #FF,W3
0C04:  CP      W3,W4
0C06:  BRA     LE,C1C
.................... 	{ 
.................... 		writeToLCD(LCD_WRITE_MEM, ' '); 
0C08:  MOV.B   #FA,W0L
0C0A:  MOV.B   W0L,9B4
0C0C:  MOV.B   #20,W0L
0C0E:  MOV.B   W0L,9B5
0C10:  CALL    B2C
.................... 		delay_us(5); 
0C14:  REPEAT  #92
0C16:  NOP     
.................... 	} 
0C18:  INC     097E
0C1A:  BRA     C00
....................  
.................... 	clearLCDLines(); 
0C1C:  CALL    B4E
.................... } 
0C20:  RETURN  
....................  
.................... void shutdownLCD(void) 
.................... { 
....................     enableLCD = false; 
*
1BF2:  BCLR.B  885.4
....................     output_high(SHDN_5V); 
1BF4:  BCLR.B  2C7.0
1BF6:  BSET.B  2CB.0
....................     delay_ms(500); 
1BF8:  MOV     #1F4,W0
1BFA:  CALL    AEC
.................... } 
1BFE:  RETURN  
....................  
.................... void writeToLCD(byte MSB, byte LSB) 
.................... { 
.................... 	output_low(STB); 
*
0B2C:  BCLR.B  2D8.5
0B2E:  BCLR.B  2DC.5
.................... 	delay_cycles(STB_L_HOLDTIME); 
0B30:  REPEAT  #9E
0B32:  NOP     
.................... 	writeByte(MSB); 
0B34:  MOV.B   9B4,W0L
0B36:  MOV.B   W0L,9B8
0B38:  CALL    B00
.................... 	writeByte(LSB); 
0B3C:  MOV.B   9B5,W0L
0B3E:  MOV.B   W0L,9B8
0B40:  CALL    B00
.................... 	delay_cycles(STB_H_HOLDTIME); 
0B44:  REPEAT  #256
0B46:  NOP     
.................... 	output_high(STB); 
0B48:  BCLR.B  2D8.5
0B4A:  BSET.B  2DC.5
.................... } 
0B4C:  RETURN  
....................  
.................... void writeByte(byte b) 
.................... { 
.................... 	int i; 
.................... 	//Most significant bit first 
.................... 	for (i = 0 ; i < 8 ; i++) 
*
0B00:  CLR     9BA
0B02:  MOV     9BA,W4
0B04:  CP      W4,#8
0B06:  BRA     GE,B2A
.................... 	{ 
.................... 		output_low(SCK); 
0B08:  BCLR.B  2D8.3
0B0A:  BCLR.B  2DC.3
.................... 		output_bit(SISO,shift_left(&b,1,0)); 
0B0C:  BCLR.B  42.0
0B0E:  RLC.B   9B8
0B10:  BRA     C,B16
0B12:  BCLR.B  2DC.4
0B14:  BRA     B18
0B16:  BSET.B  2DC.4
0B18:  BCLR.B  2D8.4
.................... 		delay_cycles(SCK_L_HOLDTIME); 
0B1A:  REPEAT  #13E
0B1C:  NOP     
.................... 		output_high(SCK); 
0B1E:  BCLR.B  2D8.3
0B20:  BSET.B  2DC.3
.................... 		delay_cycles(SCK_H_HOLDTIME); 
0B22:  REPEAT  #13E
0B24:  NOP     
.................... 	} 
0B26:  INC     09BA
0B28:  BRA     B02
.................... } 
0B2A:  RETURN  
....................  
.................... void writeToDDRAM(byte *arrayPtr, byte arraySize) 
.................... { 
*
1D56:  MOV     W5,[W15++]
.................... 	//byte testByte; 
.................... 	 
.................... 	//output_low(STB); 
.................... 	//delay_cycles(STB_L_HOLDTIME); 
.................... 	//writeByte(LCD_WRITE_MEM); 
.................... 	while(arraySize--) 
....................      { 
1D58:  MOV.B   9AE,W0L
1D5A:  DEC.B   09AE
1D5C:  CP0.B   W0L
1D5E:  BRA     Z,1D74
....................  		writeToLCD(LCD_WRITE_MEM,*arrayPtr); 
1D60:  MOV     9AC,W0
1D62:  MOV.B   [W0],W5L
1D64:  MOV.B   #FA,W0L
1D66:  MOV.B   W0L,9B4
1D68:  MOV.B   W5L,W0L
1D6A:  MOV.B   W0L,9B5
1D6C:  CALL    B2C
.................... 		//delay_us(100); 
.................... 		arrayPtr++; 
1D70:  INC     09AC
....................      } 
1D72:  BRA     1D58
.................... 	 
.................... 	//delay_cycles(STB_H_HOLDTIME); 
....................     //	output_high(STB); 
.................... } 
1D74:  MOV     [--W15],W5
1D76:  RETURN  
....................  
.................... void writeToDDRAM(byte b, byte arraySize) 
.................... { 
.................... 	while(arraySize--) 
....................      { 
1D78:  MOV.B   9AD,W0L
1D7A:  DEC.B   09AD
1D7C:  CP0.B   W0L
1D7E:  BRA     Z,1D8E
....................  		writeToLCD(LCD_WRITE_MEM,b); 
1D80:  MOV.B   #FA,W0L
1D82:  MOV.B   W0L,9B4
1D84:  MOV.B   9AC,W0L
1D86:  MOV.B   W0L,9B5
1D88:  CALL    B2C
....................      } 
1D8C:  BRA     1D78
.................... } 
1D8E:  RETURN  
....................  
.................... void refreshLCD() 
.................... { 
....................     if (enableLCD) 
1D90:  BTSS.B  885.4
1D92:  BRA     1DC2
....................     { 
....................         writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM); 
1D94:  MOV.B   #F8,W0L
1D96:  MOV.B   W0L,9B4
1D98:  MOV.B   #2,W0L
1D9A:  MOV.B   W0L,9B5
1D9C:  CALL    B2C
....................         writeToDDRAM(&LCD_Line1, LCD_LINE_SIZE); 
1DA0:  MOV.B   #10,W0L
1DA2:  MOV.B   W0L,9AE
1DA4:  MOV     #8C0,W4
1DA6:  MOV     W4,9AC
1DA8:  CALL    1D56
....................         writeToDDRAM(0, 24);	//Go to line2 
1DAC:  CLR.B   9AC
1DAE:  MOV.B   #18,W0L
1DB0:  MOV.B   W0L,9AD
1DB2:  CALL    1D78
....................         writeToDDRAM(&LCD_Line2, LCD_LINE_SIZE); 
1DB6:  MOV.B   #10,W0L
1DB8:  MOV.B   W0L,9AE
1DBA:  MOV     #8D0,W4
1DBC:  MOV     W4,9AC
1DBE:  CALL    1D56
....................     } 
.................... } 
1DC2:  RETURN  
....................  
.................... void clearLCDLines() 
.................... { 
*
0B4E:  MOV     W5,[W15++]
.................... 	//initialize LCD lines 
.................... 	int i; 
.................... 	for (i = 0 ; i < LCD_LINE_SIZE ; i++) 
0B50:  CLR     9AC
0B52:  MOV     9AC,W4
0B54:  CP      W4,#10
0B56:  BRA     GE,B70
.................... 	{ 
.................... 		LCD_Line1[i] = ' '; 
0B58:  MOV     #8C0,W4
0B5A:  MOV     9AC,W3
0B5C:  ADD     W3,W4,W5
0B5E:  MOV.B   #20,W0L
0B60:  MOV.B   W0L,[W5]
.................... 		LCD_Line2[i] = ' '; 
0B62:  MOV     #8D0,W4
0B64:  MOV     9AC,W3
0B66:  ADD     W3,W4,W5
0B68:  MOV.B   #20,W0L
0B6A:  MOV.B   W0L,[W5]
.................... 	} 
0B6C:  INC     09AC
0B6E:  BRA     B52
.................... } 
0B70:  MOV     [--W15],W5
0B72:  RETURN  
....................  
.................... #include "Chime.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... #int_TIMER3 
.................... void TIMER3_isr(void) 
.................... { 
*
0470:  PUSH    42
0472:  PUSH    36
0474:  MOV     W0,[W15++]
0476:  MOV     #2,W0
0478:  REPEAT  #C
047A:  MOV     [W0++],[W15++]
.................... 	PWM2L = ChimePattern[chimeState]; 
047C:  BCLR.B  1C8.1
047E:  MOV.B   8AF,W0L
0480:  MOV     W0,W5
0482:  SE      W5,W5
0484:  MOV     W5,W0
0486:  MOV     #8BC,W1
0488:  CALL    45E
048C:  BTSS    W0.0
048E:  BRA     492
0490:  BSET.B  1C8.1
.................... 	++chimeState %= CHIMESIZE; 
0492:  INC.B   08AF
0494:  MOV.B   8AF,W0L
0496:  CLR.B   1
0498:  CLR.B   1
049A:  MOV     #E,W4
049C:  SE      W0,W0
049E:  REPEAT  #11
04A0:  DIV.S   W0,W4
04A2:  MOV.B   W1L,W0L
04A4:  MOV.B   W0L,8AF
.................... } 
....................  
04A6:  BCLR.B  84.7
04A8:  MOV     #1A,W0
04AA:  REPEAT  #C
04AC:  MOV     [--W15],[W0--]
04AE:  MOV     [--W15],W0
04B0:  POP     36
04B2:  POP     42
04B4:  RETFIE  
.................... void initChime() 
.................... { 
.................... 	//TMR3 INIT 
.................... 	TMR3 = 0; 
*
0C22:  CLR     10A
.................... 	PR3  = TMR3_BASE; 
0C24:  MOV     #10F8,W4
0C26:  MOV     W4,10E
.................... 	T3CON = INITIAL_T3CON; 
0C28:  MOV     #8030,W4
0C2A:  MOV     W4,112
.................... 	 
.................... 	//PWM INIT 
.................... 	PTCKPS0 = 0; 
0C2C:  BCLR.B  1C0.2
.................... 	PTCKPS1 = 0; 
0C2E:  BCLR.B  1C0.3
.................... 	//		 
.................... 	PTPER = CHIME_FREQ_PERIOD; 
0C30:  MOV     #3894,W4
0C32:  MOV     W4,1C4
.................... 	PDC2  = CHIME_ON_TIME; 
0C34:  MOV     #1C4A,W4
0C36:  MOV     W4,1D8
.................... 	 
.................... 	PWM2L = 0; 
0C38:  BCLR.B  1C8.1
.................... 	PTEN = 1; 
0C3A:  BSET.B  1C1.7
.................... 	 
.................... } 
0C3C:  RETURN  
....................  
.................... void setChime(int1 enableChime)			 
.................... { 
.................... 	chimeOn = enableChime; 
*
153C:  BCLR.B  885.3
153E:  BTSC.B  98E.0
1540:  BSET.B  885.3
.................... 	 
.................... 	if(enableChime) 
1542:  CP0.B   98E
1544:  BRA     Z,154E
.................... 	{ 
.................... 		chimeState = 0; 
1546:  CLR.B   8AF
.................... 		TMR3 = 0; 
1548:  CLR     10A
.................... 		enable_interrupts(INT_TIMER3); 
154A:  BSET.B  8C.7
.................... 	} 
.................... 	else { 
154C:  BRA     1552
.................... 		disable_interrupts(INT_TIMER3); 
154E:  BCLR.B  8C.7
....................         PWM2L = false; 
1550:  BCLR.B  1C8.1
.................... 	} 
....................  
.................... } 
1552:  RETURN  
....................  
.................... void beep(int1 state) 
.................... { 
.................... 	PWM2L = state; 
*
1E22:  BCLR.B  1C8.1
1E24:  BTSC.B  9AC.0
1E26:  BSET.B  1C8.1
.................... } 
1E28:  RETURN  
....................  
.................... #include "RTCC.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................  
.................... /* 
.................... int8	RTCC_S  = 0; 
.................... int8	RTCC_M  = 0; 
.................... int8	RTCC_H  = 0; 
.................... int8	RTCC_D  = 0; 
.................... int8	RTCC_MM = 0; 
.................... int8	RTCC_Y  = 0; 
.................... */ 
.................... //int1 debugStatus = 0; 
.................... int8 SnoozeCount; 
....................  
.................... void timeToStruct(tm_struct * returnTimeStruct, int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second) 
.................... { 
*
0888:  MOV     W5,[W15++]
088A:  MOV     W6,[W15++]
.................... 	returnTimeStruct->tm_sec  = second; 
088C:  MOV     #0,W0
088E:  ADD     97E,W0
0890:  MOV     W0,W5
0892:  MOV.B   985,W0L
0894:  SE      W0,W0
0896:  MOV     W0,[W5]
.................... 	returnTimeStruct->tm_min  = minute; 
0898:  MOV     #2,W0
089A:  ADD     97E,W0
089C:  MOV     W0,W5
089E:  MOV.B   984,W0L
08A0:  SE      W0,W0
08A2:  MOV     W0,[W5]
.................... 	returnTimeStruct->tm_hour = hour; 
08A4:  MOV     #4,W0
08A6:  ADD     97E,W0
08A8:  MOV     W0,W5
08AA:  MOV.B   983,W0L
08AC:  SE      W0,W0
08AE:  MOV     W0,[W5]
.................... 	 
.................... 	returnTimeStruct->tm_mday = day; 
08B0:  MOV     #6,W0
08B2:  ADD     97E,W0
08B4:  MOV     W0,W5
08B6:  MOV.B   982,W0L
08B8:  SE      W0,W0
08BA:  MOV     W0,[W5]
.................... 	returnTimeStruct->tm_mon  = month; 
08BC:  MOV     #8,W0
08BE:  ADD     97E,W0
08C0:  MOV     W0,W5
08C2:  MOV.B   981,W0L
08C4:  SE      W0,W0
08C6:  MOV     W0,[W5]
.................... 	returnTimeStruct->tm_year = (int16)year + 100; 
08C8:  MOV     #A,W0
08CA:  ADD     97E,W0
08CC:  MOV     W0,W5
08CE:  MOV     980,W6
08D0:  SE      W6,W6
08D2:  MOV     #64,W4
08D4:  ADD     W6,W4,[W5]
.................... 	 
.................... } 
08D6:  MOV     [--W15],W6
08D8:  MOV     [--W15],W5
08DA:  RETURN  
....................  
.................... void updateSnoozeTimeWithAlarmTime() 
.................... { 
.................... 	SnoozeTime.tm_sec  = 0; 
*
0A04:  CLR     94C
.................... 	SnoozeTime.tm_min  = AlarmTime.tm_min; 
0A06:  PUSH    93C
0A08:  POP     94E
.................... 	SnoozeTime.tm_hour = AlarmTime.tm_hour; 
0A0A:  PUSH    93E
0A0C:  POP     950
.................... 	SnoozeTime.tm_mday = CurrentTime.tm_mday; 
0A0E:  PUSH    92E
0A10:  POP     952
.................... 	SnoozeTime.tm_mon  = CurrentTime.tm_mon; 
0A12:  PUSH    930
0A14:  POP     954
.................... 	SnoozeTime.tm_year = CurrentTime.tm_year; 
0A16:  PUSH    932
0A18:  POP     956
.................... 	 
.................... 	alarmData.SnoozeBinaryTime = DS1371_DateToBinary(&SnoozeTime); 
0A1A:  MOV     #94C,W4
0A1C:  MOV     W4,99C
0A1E:  CALL    91E
0A22:  MOV     W0,85E
0A24:  MOV     W1,860
.................... } 
0A26:  RETURN  
....................  
.................... void updateAlarmTimeWithCurrentTime() 
.................... { 
.................... 	AlarmTime.tm_sec  = 0; 
*
1814:  CLR     93A
.................... 	AlarmTime.tm_mday = CurrentTime.tm_mday; 
1816:  PUSH    92E
1818:  POP     940
.................... 	AlarmTime.tm_mon  = CurrentTime.tm_mon; 
181A:  PUSH    930
181C:  POP     942
.................... 	AlarmTime.tm_year = CurrentTime.tm_year; 
181E:  PUSH    932
1820:  POP     944
.................... 	 
.................... 	alarmData.AlarmBinaryTime = DS1371_DateToBinary(&AlarmTime); 
1822:  MOV     #93A,W4
1824:  MOV     W4,99C
1826:  CALL    91E
182A:  MOV     W0,862
182C:  MOV     W1,864
.................... } 
182E:  RETURN  
....................  
.................... float PowerToTimeOn(float x) 
.................... { 
*
158C:  MOV     W5,[W15++]
158E:  MOV     W6,[W15++]
1590:  MOV     W7,[W15++]
1592:  MOV     W8,[W15++]
.................... 	return 0.98682f * x * x * x * x + 16.07637f * x * x * x - 25.78642f * x * x + 15.82152f * x + 0.63547f; 
1594:  MOV     #A03C,W0
1596:  MOV     #3F7C,W1
1598:  MOV     99A,W2
159A:  MOV     99C,W3
159C:  CALL    FC0
15A0:  MOV     W0,W5
15A2:  MOV     W1,W6
15A4:  MOV     W5,W0
15A6:  MOV     W6,W1
15A8:  MOV     99A,W2
15AA:  MOV     99C,W3
15AC:  CALL    FC0
15B0:  MOV     W0,W5
15B2:  MOV     W1,W6
15B4:  MOV     W5,W0
15B6:  MOV     W6,W1
15B8:  MOV     99A,W2
15BA:  MOV     99C,W3
15BC:  CALL    FC0
15C0:  MOV     W0,W5
15C2:  MOV     W1,W6
15C4:  MOV     W5,W0
15C6:  MOV     W6,W1
15C8:  MOV     99A,W2
15CA:  MOV     99C,W3
15CC:  CALL    FC0
15D0:  MOV     W0,W5
15D2:  MOV     W1,W6
15D4:  MOV     #9C68,W0
15D6:  MOV     #4180,W1
15D8:  MOV     99A,W2
15DA:  MOV     99C,W3
15DC:  CALL    FC0
15E0:  MOV     W0,W7
15E2:  MOV     W1,W8
15E4:  MOV     W7,W0
15E6:  MOV     W8,W1
15E8:  MOV     99A,W2
15EA:  MOV     99C,W3
15EC:  CALL    FC0
15F0:  MOV     W0,W7
15F2:  MOV     W1,W8
15F4:  MOV     W7,W0
15F6:  MOV     W8,W1
15F8:  MOV     99A,W2
15FA:  MOV     99C,W3
15FC:  CALL    FC0
1600:  BCLR.B  43.0
1602:  MOV     W0,W2
1604:  MOV     W1,W3
1606:  MOV     W5,W0
1608:  MOV     W6,W1
160A:  CALL    E20
160E:  MOV     W0,W5
1610:  MOV     W1,W6
1612:  MOV     #4A97,W0
1614:  MOV     #41CE,W1
1616:  MOV     99A,W2
1618:  MOV     99C,W3
161A:  CALL    FC0
161E:  MOV     W0,W7
1620:  MOV     W1,W8
1622:  MOV     W7,W0
1624:  MOV     W8,W1
1626:  MOV     99A,W2
1628:  MOV     99C,W3
162A:  CALL    FC0
162E:  BSET.B  43.0
1630:  MOV     W0,W2
1632:  MOV     W1,W3
1634:  MOV     W5,W0
1636:  MOV     W6,W1
1638:  CALL    E20
163C:  MOV     W0,W5
163E:  MOV     W1,W6
1640:  MOV     #24F2,W0
1642:  MOV     #417D,W1
1644:  MOV     99A,W2
1646:  MOV     99C,W3
1648:  CALL    FC0
164C:  BCLR.B  43.0
164E:  MOV     W0,W2
1650:  MOV     W1,W3
1652:  MOV     W5,W0
1654:  MOV     W6,W1
1656:  CALL    E20
165A:  MOV     W0,W5
165C:  MOV     W1,W6
165E:  BCLR.B  43.0
1660:  MOV     W5,W0
1662:  MOV     W6,W1
1664:  MOV     #AE29,W2
1666:  MOV     #3F22,W3
1668:  CALL    E20
166C:  MOV.D   W0,W0
.................... } 
166E:  MOV     [--W15],W8
1670:  MOV     [--W15],W7
1672:  MOV     [--W15],W6
1674:  MOV     [--W15],W5
1676:  RETURN  
....................  
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
*
0774:  PUSH    42
0776:  PUSH    36
0778:  MOV     W0,[W15++]
077A:  MOV     #2,W0
077C:  REPEAT  #C
077E:  MOV     [W0++],[W15++]
.................... 	 
.................... 	alarmData.CurrentBinaryTime++; 
0780:  INC     0866
0782:  BTSC.B  42.1
0784:  INC     0868
.................... 	DS1371_BinaryToDate(alarmData.CurrentBinaryTime,&CurrentTime);    // Increment time by 1 second 
0786:  PUSH    866
0788:  POP     A50
078A:  PUSH    868
078C:  POP     A52
078E:  MOV     #928,W4
0790:  MOV     W4,A54
0792:  CALL    53A
....................  
.................... } 
....................  
0796:  BCLR.B  84.3
0798:  MOV     #1A,W0
079A:  REPEAT  #C
079C:  MOV     [--W15],[W0--]
079E:  MOV     [--W15],W0
07A0:  POP     36
07A2:  POP     42
07A4:  RETFIE  
.................... void setDateAndTime(int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second) 
.................... {	   
.................... 	 CurrentTime.tm_sec  = second; 
.................... 	 CurrentTime.tm_min  = minute; 
.................... 	 CurrentTime.tm_hour = hour; 
.................... 	 CurrentTime.tm_mday = day; 
.................... 	 CurrentTime.tm_mon  = month; 
.................... 	 CurrentTime.tm_year = (int)year + 2000; 
.................... 	  
.................... 	 CurrentTime = DS1371_DateToBinary(&CurrentTime); 
.................... } 
....................  
.................... /* 
.................... ****************************************************************************************************** 
.................... *                                              InitRTCC() 
.................... ****************************************************************************************************** 
.................... * 
.................... * Description : Initialize the Real-Time Clock Calendar Timer. 
.................... * 
.................... * Arguments   : none. 
.................... *  
.................... * Caller      : main(). 
.................... * 
.................... * Returns     : none. 
.................... *  
.................... * Notes       : none. 
.................... ****************************************************************************************************** 
.................... */  
.................... void InitRTCC() 
.................... { 
....................                                                         /* Setup timer for 1 intr. per sec.         */ 
.................... 	SETUP_TIMER1(T1_EXTERNAL_RTC); 
*
0A28:  CLR     104
0A2A:  MOV     #742,W1
0A2C:  MOV     #2,W4
0A2E:  MOV     #46,W2
0A30:  MOV     #57,W3
0A32:  MOV.B   W2L,[W1]
0A34:  MOV.B   W3L,[W1]
0A36:  MOV.B   W4L,[W1]
0A38:  SETM    102
0A3A:  BSET.B  2CD.6
0A3C:  MOV     #C002,W4
0A3E:  MOV     W4,104
.................... 	PR1 = 32768;                                        /* 32768                                    */ 
0A40:  MOV     #8000,W4
0A42:  MOV     W4,102
....................   	enable_interrupts(INT_TIMER1); 
0A44:  BSET.B  8C.3
....................                                                         /* Init Current Time, Alarm Time and ...    */ 
....................     timeToStruct(&CurrentTime,11,9,29,18,00,0);         /* ... Snooze Time for Debuging.            */ 
0A46:  MOV.B   #B,W0L
0A48:  MOV.B   W0L,980
0A4A:  MOV.B   #9,W0L
0A4C:  MOV.B   W0L,981
0A4E:  MOV.B   #1D,W0L
0A50:  MOV.B   W0L,982
0A52:  MOV.B   #12,W0L
0A54:  MOV.B   W0L,983
0A56:  CLR.B   984
0A58:  CLR.B   985
0A5A:  MOV     #928,W4
0A5C:  MOV     W4,97E
0A5E:  CALL    888
.................... 	timeToStruct(&AlarmTime,  11,9,29,18,30,0); 
0A62:  MOV.B   #B,W0L
0A64:  MOV.B   W0L,980
0A66:  MOV.B   #9,W0L
0A68:  MOV.B   W0L,981
0A6A:  MOV.B   #1D,W0L
0A6C:  MOV.B   W0L,982
0A6E:  MOV.B   #12,W0L
0A70:  MOV.B   W0L,983
0A72:  MOV.B   #1E,W0L
0A74:  MOV.B   W0L,984
0A76:  CLR.B   985
0A78:  MOV     #93A,W4
0A7A:  MOV     W4,97E
0A7C:  CALL    888
....................     timeToStruct(&SnoozeTime, 11,9,29,18,30,0); 
0A80:  MOV.B   #B,W0L
0A82:  MOV.B   W0L,980
0A84:  MOV.B   #9,W0L
0A86:  MOV.B   W0L,981
0A88:  MOV.B   #1D,W0L
0A8A:  MOV.B   W0L,982
0A8C:  MOV.B   #12,W0L
0A8E:  MOV.B   W0L,983
0A90:  MOV.B   #1E,W0L
0A92:  MOV.B   W0L,984
0A94:  CLR.B   985
0A96:  MOV     #94C,W4
0A98:  MOV     W4,97E
0A9A:  CALL    888
....................                                                         /* Calc. current binary date & time.        */ 
.................... 	alarmData.CurrentBinaryTime = DS1371_DateToBinary(&CurrentTime); 
0A9E:  MOV     #928,W4
0AA0:  MOV     W4,99C
0AA2:  CALL    91E
0AA6:  MOV     W0,866
0AA8:  MOV     W1,868
....................     alarmData.AlarmBinaryTime   = DS1371_DateToBinary(&AlarmTime); 
0AAA:  MOV     #93A,W4
0AAC:  MOV     W4,99C
0AAE:  CALL    91E
0AB2:  MOV     W0,862
0AB4:  MOV     W1,864
....................      
....................                                                         /* Calc. next alarm ringing.                */ 
.................... 	updateSnoozeTimeWithAlarmTime(); 
0AB6:  CALL    A04
....................      
....................     alarmData.AlarmState     = ALARM_STANDBY; 
0ABA:  MOV.B   #1,W0L
0ABC:  MOV.B   W0L,876
....................     alarmData.MainLoops      = 0; 
0ABE:  CLR     86A
0AC0:  CLR     86C
....................     alarmData.PulseWidthErr  = 0; 
0AC2:  CLR     86E
0AC4:  CLR     870
....................     alarmData.ButtonDownTick = 0; 
0AC6:  CLR     872
0AC8:  CLR     874
.................... } 
0ACA:  RETURN  
....................  
.................... /* 
....................  ****************************************************************************************************** 
....................  *                                          AlarmStateMachine() 
....................  ****************************************************************************************************** 
....................  * 
....................  * Description : Processed the alarm state machine for ringing, lamp power and snoozes 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : TIMER1_isr(). 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ****************************************************************************************************** 
....................  */  
.................... void AlarmStateMachine (void) 
.................... { 
*
18BC:  MOV     W5,[W15++]
18BE:  MOV     W6,[W15++]
....................     switch (alarmData.AlarmState) { 
18C0:  MOV.B   876,W0L
18C2:  CLR.B   1
18C4:  XOR     #1,W0
18C6:  BRA     Z,18DE
18C8:  XOR     #3,W0
18CA:  BRA     Z,1930
18CC:  XOR     #1,W0
18CE:  BRA     Z,19AE
18D0:  XOR     #7,W0
18D2:  BRA     Z,19FC
18D4:  XOR     #1,W0
18D6:  BRA     Z,1AA6
18D8:  XOR     #3,W0
18DA:  BRA     Z,1B28
18DC:  BRA     1B7E
....................         case ALARM_STANDBY:                             /* ------------ ALARM_STANDBY ------------- */ 
....................                                                         /* CONDITION1 - Now is within TdelayRamp .. */ 
....................             light_on_time = alarmData.AlarmBinaryTime - ((unsigned long) delayLoadLighting) * 60ul; 
18DE:  MOV     8E0,W5
18E0:  SE      W5,W5
18E2:  CLR     W6
18E4:  BTSC    W5.F
18E6:  SETM    W6
18E8:  PUSH    42
18EA:  SETM.B  42
18EC:  MOV     W5,W0
18EE:  MOV     W6,W1
18F0:  MOV     #3C,W2
18F2:  MOV     #0,W3
18F4:  CALL    50A
18F8:  POP     42
18FA:  MOV     862,W4
18FC:  SUB     W4,W0,W0
18FE:  MOV     W0,970
1900:  MOV     864,W4
1902:  SUBB    W4,W1,W0
1904:  MOV     W0,972
....................                                                         /* .. of Talarm.                            */ 
....................                                                         /* If the time is within the ramp section.  */ 
....................             if ((alarmData.CurrentBinaryTime >= light_on_time) && 
....................                 (alarmData.CurrentBinaryTime <  alarmData.AlarmBinaryTime)) { 
1906:  MOV     972,W0
1908:  MOV     868,W4
190A:  CP      W4,W0
190C:  BRA     NC,192E
190E:  BRA     GTU,1918
1910:  MOV     970,W0
1912:  MOV     866,W4
1914:  CP      W4,W0
1916:  BRA     NC,192E
1918:  MOV     868,W0
191A:  MOV     864,W4
191C:  CP      W4,W0
191E:  BRA     NC,192E
1920:  BRA     GTU,192A
1922:  MOV     866,W0
1924:  MOV     862,W4
1926:  CP      W4,W0
1928:  BRA     LEU,192E
....................                                                         /* Set the next state to ALARM_RAMP.        */ 
....................                 alarmData.AlarmState = ALARM_RAMP; 
192A:  MOV.B   #2,W0L
192C:  MOV.B   W0L,876
....................             } 
....................             break; 
192E:  BRA     1B80
....................              
....................         case ALARM_RAMP:                                /* -------------- ALARM_RAMP -------------- */ 
....................              
....................             CalculateLuminosity();                      /* Evaluate Lamp Intensity.                 */ 
1930:  CALL    1678
....................              
....................                                                         /* CONDITION1 - Now is Talarm.              */ 
....................             light_on_time = alarmData.AlarmBinaryTime - ((unsigned long) delayLoadLighting) * 60ul; 
1934:  MOV     8E0,W5
1936:  SE      W5,W5
1938:  CLR     W6
193A:  BTSC    W5.F
193C:  SETM    W6
193E:  PUSH    42
1940:  SETM.B  42
1942:  MOV     W5,W0
1944:  MOV     W6,W1
1946:  MOV     #3C,W2
1948:  MOV     #0,W3
194A:  CALL    50A
194E:  POP     42
1950:  MOV     862,W4
1952:  SUB     W4,W0,W0
1954:  MOV     W0,970
1956:  MOV     864,W4
1958:  SUBB    W4,W1,W0
195A:  MOV     W0,972
....................              
....................             if (alarmData.CurrentBinaryTime == alarmData.AlarmBinaryTime) { 
195C:  MOV     866,W0
195E:  CP      862
1960:  BRA     NZ,1984
1962:  MOV     868,W0
1964:  CP      864
1966:  BRA     NZ,1984
....................                      
....................                 /// TODO : Add transition actions 
....................                                                         /* Set SnoozeCount to 0.                    */ 
....................                 SnoozeCount = 0; 
1968:  CLR.B   978
....................                                                         /* Start Chime.                             */ 
....................                 setChime(true); 
196A:  MOV.B   #1,W0L
196C:  MOV.B   W0L,98E
196E:  CALL    153C
....................                                                         /* Set SnoozeTime to AlarmTime.             */ 
....................                 alarmData.SnoozeBinaryTime = alarmData.AlarmBinaryTime; 
1972:  PUSH    862
1974:  POP     85E
1976:  PUSH    864
1978:  POP     860
....................                 pushAck = false; 
197A:  BCLR.B  966.1
....................                 pushLongAck = false; 
197C:  BCLR.B  966.2
....................                  
....................                                                         /* Set the next state to ALARM_WAKE.        */ 
....................                 alarmData.AlarmState = ALARM_WAKE; 
197E:  MOV.B   #3,W0L
1980:  MOV.B   W0L,876
....................             } else if ((alarmData.CurrentBinaryTime < light_on_time) || 
1982:  BRA     19AC
....................                        (alarmData.CurrentBinaryTime > alarmData.AlarmBinaryTime)) { 
1984:  MOV     868,W0
1986:  MOV     972,W4
1988:  CP      W4,W0
198A:  BRA     GTU,19A8
198C:  BRA     NC,1996
198E:  MOV     866,W0
1990:  MOV     970,W4
1992:  CP      W4,W0
1994:  BRA     GTU,19A8
1996:  MOV     864,W0
1998:  MOV     868,W4
199A:  CP      W4,W0
199C:  BRA     NC,19AC
199E:  BRA     GTU,19A8
19A0:  MOV     862,W0
19A2:  MOV     866,W4
19A4:  CP      W4,W0
19A6:  BRA     LEU,19AC
....................                                                         /* CONDITION2 - Now is not w/in TdelayRamp. */ 
....................                 RTCC_TransitionToSTANDBY(); 
19A8:  CALL    18A0
....................             } 
....................              
....................             break; 
19AC:  BRA     1B80
....................   
....................         case ALARM_WAKE:                                /* -------------- ALARM_WAKE -------------- */ 
....................                                                         /* CONDITION1 - Button  is pushed.          */ 
....................                                                         /* CONDITION2 - Timeout is expired.         */ 
....................             if (pushAck ||  
....................                (alarmData.CurrentBinaryTime >= (alarmData.SnoozeBinaryTime + ALARM_WAKE_TIMEOUT_SEC))) { 
19AE:  BTSC.B  966.1
19B0:  BRA     19CC
19B2:  MOV     #3C,W4
19B4:  MOV     85E,W3
19B6:  ADD     W3,W4,W0
19B8:  MOV     860,W4
19BA:  ADDC    W4,#0,W4
19BC:  MOV     W4,W1
19BE:  MOV     868,W4
19C0:  CP      W4,W1
19C2:  BRA     NC,19FA
19C4:  BRA     GTU,19CC
19C6:  MOV     866,W4
19C8:  CP      W4,W0
19CA:  BRA     NC,19FA
....................                 pushAck = false;                        /* Consume pushbutton acknowledge.          */ 
19CC:  BCLR.B  966.1
....................                  
....................                                                         /* Shutdown the buzzer.                     */ 
....................                 setChime(false); 
19CE:  CLR.B   98E
19D0:  CALL    153C
....................                                                         /* Add SnoozeTime to SnoozeBinaryTime.      */ 
....................                 alarmData.SnoozeBinaryTime += 60 * (unsigned long)AlarmSnoozeTime; 
19D4:  MOV.B   8E1,W0L
19D6:  CLR.B   1
19D8:  MOV     #0,W1
19DA:  PUSH    42
19DC:  SETM.B  42
19DE:  MOV     W0,W2
19E0:  MOV     W1,W3
19E2:  MOV     #3C,W0
19E4:  MOV     #0,W1
19E6:  CALL    50A
19EA:  POP     42
19EC:  ADD     85E
19EE:  MOV     W1,W0
19F0:  ADDC    860,W0
19F2:  MOV     W0,860
....................                                                         /* TODO : Inclrease SnoozeCount.            */ 
....................                 SnoozeCount++; 
19F4:  INC.B   0978
....................                  
....................                 alarmData.AlarmState = ALARM_SNOOZE; 
19F6:  MOV.B   #4,W0L
19F8:  MOV.B   W0L,876
....................             } 
....................                                                          
....................              
....................             break; 
19FA:  BRA     1B80
....................              
....................         case ALARM_SNOOZE:                              /* ------------- ALARM_SNOOZE ------------- */ 
....................             light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul; 
19FC:  MOV     8E0,W5
19FE:  SE      W5,W5
1A00:  CLR     W6
1A02:  BTSC    W5.F
1A04:  SETM    W6
1A06:  PUSH    42
1A08:  SETM.B  42
1A0A:  MOV     W5,W0
1A0C:  MOV     W6,W1
1A0E:  MOV     #3C,W2
1A10:  MOV     #0,W3
1A12:  CALL    50A
1A16:  POP     42
1A18:  MOV     85E,W4
1A1A:  SUB     W4,W0,W0
1A1C:  MOV     W0,970
1A1E:  MOV     860,W4
1A20:  SUBB    W4,W1,W0
1A22:  MOV     W0,972
....................                                                         /* CONDITION1 - AlarmLampOn is true.        */ 
....................             if (AlarmLampOn) { 
1A24:  BTSS.B  885.6
1A26:  BRA     1A38
....................                  
....................                                                         /* Set Lamp to maximum intensity.           */ 
....................                 SetLampIntensity(0.50f); 
1A28:  CLR     98E
1A2A:  MOV     #3F00,W4
1A2C:  MOV     W4,990
1A2E:  CALL    17AA
....................                  
....................                 alarmData.AlarmState = ALARM_LAMP_ON; 
1A32:  MOV.B   #6,W0L
1A34:  MOV.B   W0L,876
....................             } 
....................              
....................                                                         /* CONDITION2 - Now is within TdelayRamp .. */ 
....................                                                         /* .. of Tsnooze.                           */ 
....................             else if ((alarmData.CurrentBinaryTime > light_on_time) && 
1A36:  BRA     1AA4
....................                     (alarmData.CurrentBinaryTime < alarmData.SnoozeBinaryTime)) { 
1A38:  MOV     972,W0
1A3A:  MOV     868,W4
1A3C:  CP      W4,W0
1A3E:  BRA     NC,1A62
1A40:  BRA     GTU,1A4A
1A42:  MOV     970,W0
1A44:  MOV     866,W4
1A46:  CP      W4,W0
1A48:  BRA     LEU,1A62
1A4A:  MOV     868,W0
1A4C:  MOV     860,W4
1A4E:  CP      W4,W0
1A50:  BRA     NC,1A62
1A52:  BRA     GTU,1A5C
1A54:  MOV     866,W0
1A56:  MOV     85E,W4
1A58:  CP      W4,W0
1A5A:  BRA     LEU,1A62
....................                  
....................                 alarmData.AlarmState = ALARM_SNOOZE_RAMP; 
1A5C:  MOV.B   #5,W0L
1A5E:  MOV.B   W0L,876
....................             } 
....................                                                         /* CONDITION3 - Now ain't w/i TdelayRamp .. */ 
....................                                                         /* .. of Tsnooze.                           */ 
....................                                                         /* CONDITION4 - Snooze Count Limit Reached. */ 
....................             else if ((alarmData.CurrentBinaryTime  < light_on_time)              || 
1A60:  BRA     1AA4
....................                      (alarmData.CurrentBinaryTime  > alarmData.SnoozeBinaryTime) || 
....................                      (SnoozeCount                 == ALARM_MAX_SNOOZE_COUNT)     ||  
....................                      (pushLongAck                 == true)) { 
1A62:  MOV     868,W0
1A64:  MOV     972,W4
1A66:  CP      W4,W0
1A68:  BRA     GTU,1A90
1A6A:  BRA     NC,1A74
1A6C:  MOV     866,W0
1A6E:  MOV     970,W4
1A70:  CP      W4,W0
1A72:  BRA     GTU,1A90
1A74:  MOV     860,W0
1A76:  MOV     868,W4
1A78:  CP      W4,W0
1A7A:  BRA     GTU,1A90
1A7C:  BRA     NC,1A86
1A7E:  MOV     85E,W0
1A80:  MOV     866,W4
1A82:  CP      W4,W0
1A84:  BRA     GTU,1A90
1A86:  MOV     978,W4
1A88:  CP.B    W4L,#3
1A8A:  BRA     Z,1A90
1A8C:  BTSS.B  966.2
1A8E:  BRA     1A96
....................  
....................                 RTCC_TransitionToSTANDBY(); 
1A90:  CALL    18A0
....................             } 
....................                                                         /* CONDITION5 - PushLongAck is true.        */ 
....................             else if (pushLongAck == true) { 
1A94:  BRA     1AA4
1A96:  BTSS.B  966.2
1A98:  BRA     1AA4
....................                                                         /* Consume pushLongAck.                     */ 
....................                 pushLongAck = false; 
1A9A:  BCLR.B  966.2
....................                 alarmData.ButtonDownTick = 0; 
1A9C:  CLR     872
1A9E:  CLR     874
....................                  
....................                 RTCC_TransitionToSTANDBY(); 
1AA0:  CALL    18A0
....................             } 
....................              
....................             break; 
1AA4:  BRA     1B80
....................      
....................         case ALARM_SNOOZE_RAMP:                         /* ---------- ALARM_SNOOZE_RAMP ----------- */ 
....................         	light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul; 
1AA6:  MOV     8E0,W5
1AA8:  SE      W5,W5
1AAA:  CLR     W6
1AAC:  BTSC    W5.F
1AAE:  SETM    W6
1AB0:  PUSH    42
1AB2:  SETM.B  42
1AB4:  MOV     W5,W0
1AB6:  MOV     W6,W1
1AB8:  MOV     #3C,W2
1ABA:  MOV     #0,W3
1ABC:  CALL    50A
1AC0:  POP     42
1AC2:  MOV     85E,W4
1AC4:  SUB     W4,W0,W0
1AC6:  MOV     W0,970
1AC8:  MOV     860,W4
1ACA:  SUBB    W4,W1,W0
1ACC:  MOV     W0,972
....................              
....................             CalculateLuminosity();                      /* Evaluate Lamp Intensity.                 */ 
1ACE:  CALL    1678
....................              
....................                                                         /* CONDITION1 - Tnow is Tsnooze.            */ 
....................             if (alarmData.CurrentBinaryTime == alarmData.SnoozeBinaryTime) { 
1AD2:  MOV     866,W0
1AD4:  CP      85E
1AD6:  BRA     NZ,1AF0
1AD8:  MOV     868,W0
1ADA:  CP      860
1ADC:  BRA     NZ,1AF0
....................                  
....................                                                         /* Activate the buzzer.                     */ 
....................                 setChime(true); 
1ADE:  MOV.B   #1,W0L
1AE0:  MOV.B   W0L,98E
1AE2:  CALL    153C
....................                 pushAck = false; 
1AE6:  BCLR.B  966.1
....................                 pushLongAck = false; 
1AE8:  BCLR.B  966.2
....................                  
....................                 alarmData.AlarmState = ALARM_WAKE; 
1AEA:  MOV.B   #3,W0L
1AEC:  MOV.B   W0L,876
....................             } 
....................                                                         /* CONDITION2 - Now ain't w/i TdelayRamp .. */ 
....................                                                         /* .. of Tsnooze.                           */ 
....................                                                         /* CONDITION3 - pushLongAck is true.        */ 
....................             else if ((alarmData.CurrentBinaryTime  < light_on_time)    || 
1AEE:  BRA     1B26
....................                      (alarmData.CurrentBinaryTime  > alarmData.SnoozeBinaryTime) || 
....................                      (pushLongAck       == true)) 
1AF0:  MOV     868,W0
1AF2:  MOV     972,W4
1AF4:  CP      W4,W0
1AF6:  BRA     GTU,1B18
1AF8:  BRA     NC,1B02
1AFA:  MOV     866,W0
1AFC:  MOV     970,W4
1AFE:  CP      W4,W0
1B00:  BRA     GTU,1B18
1B02:  MOV     860,W0
1B04:  MOV     868,W4
1B06:  CP      W4,W0
1B08:  BRA     GTU,1B18
1B0A:  BRA     NC,1B14
1B0C:  MOV     85E,W0
1B0E:  MOV     866,W4
1B10:  CP      W4,W0
1B12:  BRA     GTU,1B18
1B14:  BTSS.B  966.2
1B16:  BRA     1B26
....................             { 
....................                if (pushLongAck == true) { 
1B18:  BTSS.B  966.2
1B1A:  BRA     1B22
....................                                                         /* Consume pushLongAck.                     */ 
....................                    pushLongAck = false; 
1B1C:  BCLR.B  966.2
....................                    alarmData.ButtonDownTick = 0; 
1B1E:  CLR     872
1B20:  CLR     874
....................                } 
....................                RTCC_TransitionToSTANDBY(); 
1B22:  CALL    18A0
....................             } 
....................              
....................             break; 
1B26:  BRA     1B80
....................              
....................         case ALARM_LAMP_ON:                             /* ------------ ALARM_LAMP_ON ------------- */ 
....................                                                         /* CONDITION 1 - Now is SnoozeTime.         */ 
....................             if (alarmData.CurrentBinaryTime == alarmData.SnoozeBinaryTime) { 
1B28:  MOV     866,W0
1B2A:  CP      85E
1B2C:  BRA     NZ,1B46
1B2E:  MOV     868,W0
1B30:  CP      860
1B32:  BRA     NZ,1B46
....................                  
....................                                                         /* Activate the buzzer.                     */ 
....................                 setChime(true); 
1B34:  MOV.B   #1,W0L
1B36:  MOV.B   W0L,98E
1B38:  CALL    153C
....................                 pushAck = false; 
1B3C:  BCLR.B  966.1
....................                 pushLongAck = false; 
1B3E:  BCLR.B  966.2
....................                  
....................                 alarmData.AlarmState = ALARM_WAKE; 
1B40:  MOV.B   #3,W0L
1B42:  MOV.B   W0L,876
....................             } 
....................                                                         /* CONDITION2 - Now ain't w/i TdelayRamp .. */ 
....................                                                         /* .. of Tsnooze.                           */ 
....................             else if ((alarmData.CurrentBinaryTime < light_on_time)    || 
1B44:  BRA     1B7C
....................                      (alarmData.CurrentBinaryTime > alarmData.SnoozeBinaryTime) || 
....................                      (pushLongAck == true)) { 
1B46:  MOV     868,W0
1B48:  MOV     972,W4
1B4A:  CP      W4,W0
1B4C:  BRA     GTU,1B6E
1B4E:  BRA     NC,1B58
1B50:  MOV     866,W0
1B52:  MOV     970,W4
1B54:  CP      W4,W0
1B56:  BRA     GTU,1B6E
1B58:  MOV     860,W0
1B5A:  MOV     868,W4
1B5C:  CP      W4,W0
1B5E:  BRA     GTU,1B6E
1B60:  BRA     NC,1B6A
1B62:  MOV     85E,W0
1B64:  MOV     866,W4
1B66:  CP      W4,W0
1B68:  BRA     GTU,1B6E
1B6A:  BTSS.B  966.2
1B6C:  BRA     1B7C
....................                  
....................                 if (pushLongAck == true) { 
1B6E:  BTSS.B  966.2
1B70:  BRA     1B78
....................                                                         /* Consume pushLongAck.                     */ 
....................                     pushLongAck = false; 
1B72:  BCLR.B  966.2
....................                     alarmData.ButtonDownTick = 0; 
1B74:  CLR     872
1B76:  CLR     874
....................                 } 
....................                  
....................                 RTCC_TransitionToSTANDBY(); 
1B78:  CALL    18A0
....................             } 
....................              
....................             break; 
1B7C:  BRA     1B80
....................              
....................         default: 
....................             break; 
1B7E:  BRA     1B80
....................     } 
.................... } 
1B80:  MOV     [--W15],W6
1B82:  MOV     [--W15],W5
1B84:  RETURN  
....................  
.................... /* 
....................  ****************************************************************************************************** 
....................  *                                         FindNextAlarmTime() 
....................  ****************************************************************************************************** 
....................  * 
....................  * Description : Calculates the next AlarmBinaryTime based on the enabled days in ???. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : RTCC_TransitionToSTANDBY(). 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ****************************************************************************************************** 
....................  */  
.................... void FindNextAlarmTime(void) 
.................... { 
*
1830:  MOV     W5,[W15++]
....................              int1 valid_alarm_time; 
....................     unsigned long temp_alarm_time; 
....................                   int8 day_counter; 
....................      
....................     valid_alarm_time = false; 
1832:  BCLR.B  996.0
....................     day_counter      = 0; 
1834:  CLR.B   997
....................                                                         /* Calculate today's AlarmBinaryTime.       */ 
....................     updateAlarmTimeWithCurrentTime(); 
1836:  CALL    1814
....................      
....................                                                         /* While !validAlarmTime & dayCounter < 7:  */ 
....................     while ((valid_alarm_time == false) &&  
....................            (day_counter       < RTCC_MAX_DAY_LOOKAHEAD)) { 
183A:  BTSC.B  996.0
183C:  BRA     189C
183E:  MOV     996,W4
1840:  LSR     W4,#8,W4
1842:  CP.B    W4L,#7
1844:  BRA     GE,189C
....................          
....................          
....................      
....................                                                         /* TempAlarm = AlarmBinaryTime + ...        */ 
....................                                                         /* ... dayCounter * 24h.                    */ 
....................         temp_alarm_time = alarmData.AlarmBinaryTime + (day_counter * SEC_IN_A_DAY); 
1846:  MOV.B   997,W0L
1848:  SE      W0,W0
184A:  CLR     W1
184C:  BTSC    W0.F
184E:  SETM    W1
1850:  MOV     #5180,W2
1852:  MOV     #1,W3
1854:  CALL    8DC
1858:  MOV     862,W4
185A:  ADD     W0,W4,W0
185C:  MOV     W0,998
185E:  MOV     864,W4
1860:  ADDC    W1,W4,W0
1862:  MOV     W0,99A
....................         DS1371_BinaryToDate(temp_alarm_time, &AlarmTime); 
1864:  PUSH    42
1866:  SETM.B  42
1868:  PUSH    998
186A:  POP     A50
186C:  PUSH    99A
186E:  POP     A52
1870:  MOV     #93A,W4
1872:  MOV     W4,A54
1874:  CALL    53A
1878:  POP     42
....................                                                         /* If dayOfTheWeek of TempAlarm is true :   */   
....................         if (ALARM_DAYS[AlarmTime.tm_wday] == true) { 
187A:  MOV     #920,W4
187C:  MOV     946,W3
187E:  ADD     W3,W4,W0
1880:  MOV.B   [W0],W4L
1882:  CP.B    W4L,#1
1884:  BRA     NZ,1898
....................                                                         /* validAlarmTime = true.                   */ 
....................             valid_alarm_time = true; 
1886:  BSET.B  996.0
....................                                                         /* AlarmBinaryTime = TempAlarm.             */ 
....................             alarmData.AlarmBinaryTime  = temp_alarm_time; 
1888:  PUSH    998
188A:  POP     862
188C:  PUSH    99A
188E:  POP     864
....................             alarmData.SnoozeBinaryTime = alarmData.AlarmBinaryTime; 
1890:  PUSH    862
1892:  POP     85E
1894:  PUSH    864
1896:  POP     860
....................         } 
....................     	day_counter++; 
1898:  INC.B   0997
....................     } 
189A:  BRA     183A
.................... } 
189C:  MOV     [--W15],W5
189E:  RETURN  
....................  
.................... /* 
....................  ****************************************************************************************************** 
....................  *                                         RTCC_TransitionToSTANDBY() 
....................  ****************************************************************************************************** 
....................  * 
....................  * Description : Actions to execute when transitioning from any state to ALARM_STANDBY. 
....................  * 
....................  * Arguments   : none. 
....................  *  
....................  * Caller      : AlarmStateMachine(). 
....................  * 
....................  * Returns     : none. 
....................  *  
....................  * Notes       : none. 
....................  ****************************************************************************************************** 
....................  */  
.................... void RTCC_TransitionToSTANDBY (void) 
.................... { 
....................     SetLampIntensity(0.0f); 
18A0:  CLR     98E
18A2:  CLR     990
18A4:  CALL    17AA
....................     InitLoadControl(); 
18A8:  CALL    850
....................     setChime(false); 
18AC:  CLR.B   98E
18AE:  CALL    153C
....................     FindNextAlarmTime(); 
18B2:  CALL    1830
....................      
....................     alarmData.AlarmState = ALARM_STANDBY; 
18B6:  MOV.B   #1,W0L
18B8:  MOV.B   W0L,876
.................... } 
18BA:  RETURN  
....................  
....................  
....................  
....................  
....................  
.................... #include "UserInput.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
....................   
.................... int1 ENCA_value = 0; 
.................... int1 ENCB_value = 0; 
.................... int1 PUSH_value = 0; 
....................  
.................... int1 previous_PUSH = 0; 
.................... int16 contextEnum = WAIT_PHASE_SEL; 
....................  
.................... #int_QEI 
.................... void  QEI_isr(void)  
.................... { 
*
07A6:  PUSH    42
07A8:  PUSH    36
07AA:  MOV     W0,[W15++]
07AC:  MOV     #2,W0
07AE:  REPEAT  #C
07B0:  MOV     [W0++],[W15++]
....................  
.................... } 
....................   
07B2:  BCLR.B  89.0
07B4:  MOV     #1A,W0
07B6:  REPEAT  #C
07B8:  MOV     [--W15],[W0--]
07BA:  MOV     [--W15],W0
07BC:  POP     36
07BE:  POP     42
07C0:  RETFIE  
.................... void initUserInput() 
.................... {  
.................... 	setup_qei(QEI_MODE_X4|QEI_TIMER_INTERNAL,QEI_FILTER_DIV_2,0xFFFF); 
*
0ACC:  MOV     #600,W4
0ACE:  MOV     W4,122
0AD0:  MOV     #10,W4
0AD2:  MOV     W4,124
0AD4:  SETM    128
0AD6:  CLR     126
....................  
....................  	enable_interrupts(INT_QEI); 
0AD8:  BSET.B  91.0
....................  	 
.................... } 
0ADA:  RETURN  
....................   
.................... void encoderMonitoring() 
.................... { 
.................... 	previous_PUSH = PUSH_value; 
*
1BEA:  BCLR.B  966.7
1BEC:  BTSC.B  966.6
1BEE:  BSET.B  966.7
....................  	 
.................... } 
1BF0:  RETURN  
....................  
.................... void switchInputContext() 
.................... { 
.................... 	contextEnum = (contextEnum + 1) % SEL_COUNT; 
.................... } 
....................  
.................... void addSelector() 
.................... { 
.................... 	switch(contextEnum) 
.................... 	{ 
*
1D3C:  MOV     97A,W0
1D3E:  XOR     #0,W0
1D40:  BRA     Z,1D48
1D42:  XOR     #1,W0
1D44:  BRA     Z,1D4E
1D46:  BRA     1D54
.................... 		case WAIT_PHASE_SEL: 
.................... 			LCD_Line1[15] = 0x1E; 
1D48:  MOV.B   #1E,W0L
1D4A:  MOV.B   W0L,8CF
.................... 			break; 
1D4C:  BRA     1D54
.................... 		case WAIT_PULSE_SEL: 
.................... 			LCD_Line2[15] = 0x1E;  
1D4E:  MOV.B   #1E,W0L
1D50:  MOV.B   W0L,8DF
.................... 			break; 
1D52:  BRA     1D54
.................... 	} 
.................... } 
1D54:  RETURN  
....................  
.................... #include "EEPROM.c" 
.................... ///* 
.................... // *  EEPROM.c 
.................... // *  DawnStar 
.................... // * 
.................... // *  Created by Alexis Ouellet-Patenaude on 10-12-12. 
.................... // *  Copyright 2010 EmbVue Inc. All rights reserved. 
.................... // * 
.................... // */ 
.................... // 
.................... //#include "includes.h" 
.................... // 
.................... //void saveConfigToEEPROM() 
.................... //{ 
.................... //	//Prepare Alarm Days array to int8 
.................... //	int8 daysArray = 0; 
.................... //	int i; 
.................... //	for (i = 0 ; i < 7 ; i++) 
.................... //	{ 
.................... //		daysArray += (ALARM_DAYS[i] & 0x01) << i; 
.................... //	} 
.................... //	 
.................... //	//Erase EEPROM 
.................... //	/* 
.................... //	for (i = 0 ; i <= EE_LOAD_DELAY ; i++) 
.................... //	{ 
.................... //		erase_eeprom(i); 
.................... //		//erase_eeprom(i); 
.................... //	} 
.................... //	 */ 
.................... //	 
.................... //	//Begin Write Cycle 
.................... //	write_eeprom(EE_ALARM_H, AlarmTime.tm_hour); 
.................... //	write_eeprom(EE_ALARM_M, AlarmTime.tm_min); 
.................... //	write_eeprom(EE_ALARM_DAYS, daysArray); 
.................... //	write_eeprom(EE_ALARM_SNOOZE, AlarmSnoozeTime); 
.................... //	write_eeprom(EE_ALARM_ENABLE, ALARM_ENABLED ); 
.................... //	 
.................... //	//Address locations RGBLighting 
.................... //	write_eeprom(EE_HUE, hsvColor.hue); 
.................... //	write_eeprom(EE_SAT, hsvColor.saturation); 
.................... //	write_eeprom(EE_VAL, hsvColor.value); 
.................... //	write_eeprom(EE_MOOD_ENABLE, moodEnable); 
.................... //	 
.................... //	//Address locations Chime 
.................... //	write_eeprom(EE_CARILLON, carillon); 
.................... //	write_eeprom(EE_VOLUME, chimeVolume); 
.................... //	write_eeprom(EE_TONE, toneSelect); 
.................... //	 
.................... //	//Address locations Load Lighting 
.................... //	write_eeprom(EE_MAX_LOAD, maxLoadLighting); 
.................... //	write_eeprom(EE_LOAD_DELAY, delayLoadLighting); 
.................... //	 
.................... //	 
.................... //} 
.................... // 
.................... //void readConfigFromEEPROM() 
.................... //{ 
.................... //	//int16 workingWord; 
.................... //	int8 daysArray = 0; 
.................... //	 
.................... //	AlarmTime.tm_hour = read_eeprom (EE_ALARM_H); 
.................... //	AlarmTime.tm_min = read_eeprom (EE_ALARM_M); 
.................... //	 
.................... //	daysArray = read_eeprom (EE_ALARM_DAYS);		//Need Post Processing				 
.................... //	AlarmSnoozeTime = read_eeprom (EE_ALARM_SNOOZE); 
.................... //	 
.................... //	ALARM_ENABLED = read_eeprom (EE_ALARM_ENABLE); 
.................... //	hsvColor.hue = read_eeprom (EE_HUE); 
.................... //	 
.................... //	hsvColor.saturation = read_eeprom (EE_SAT); 
.................... //	hsvColor.value = read_eeprom (EE_VAL); 
.................... //	 
.................... //	moodEnable = read_eeprom (EE_MOOD_ENABLE); 
.................... //	carillon = read_eeprom (EE_CARILLON); 
.................... //	 
.................... //	chimeVolume = read_eeprom (EE_VOLUME); 
.................... //	toneSelect = read_eeprom (EE_TONE); 
.................... //	 
.................... //	maxLoadLighting = read_eeprom (EE_MAX_LOAD); 
.................... //	delayLoadLighting = read_eeprom (EE_LOAD_DELAY); 
.................... //	 
.................... //	//Alarm Days Post Processing 
.................... //	 
.................... //} 
.................... // 
.................... //void loadEEPROMinRAM() 
.................... //{ 
.................... //	int i; 
.................... //	for (i = 0; i < 13; i++) { 
.................... //		eepromContent[i] = read_eeprom (i*2); 
.................... //	} 
.................... //} 
....................  
.................... #include "Menu.c" 
.................... #include "includes.h" 
.................... #ifndef __INCLUDES__ 
.................... #define __INCLUDES__ 
....................  
....................  
.................... /* 
....................  *  includes.h 
....................  *  DawnStar 
....................  * 
....................  *  Created by Alexis Ouellet-Patenaude on 11-09-12. 
....................  *  Copyright 2011 __MyCompanyName__. All rights reserved. 
....................  * 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <math.h> 
.................... #include <uart.h> 
.................... #include <i2c.h> 
.................... #include <EEPROM.h> 
.................... #include <Menu.h> 
.................... #include <RBGLighting.h> 
.................... #include <Chime.h> 
.................... #include <LCDDriver.h> 
.................... #include <LoadControl.h> 
.................... #include <LumMonitor.h> 
.................... #include <RTCC.h> 
.................... #include <Userinput.h> 
....................  
.................... #endif 
....................  
.................... #define SET_CURSOR_HOME (writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM)) 
.................... #DEFINE DISABLE_BLINKING_AND_CURSOR (writeToLCD(LCD_WRITE_CFG,LCD_DSPL_BOFF)) 
.................... #DEFINE ENABLE_BLINKING_AND_CURSOR (writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFTL)) 
....................  
....................  
.................... void EditMenu() 
.................... { 
*
2D42:  MOV     W5,[W15++]
2D44:  CLR     980
2D46:  BCLR.B  982.0
2D48:  MOV.B   886,W0L
2D4A:  MOV.B   W0L,983
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_ALARM_OPTIONS_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
2D4C:  MOV.B   #F8,W0L
2D4E:  MOV.B   W0L,9B4
2D50:  MOV.B   #F,W0L
2D52:  MOV.B   W0L,9B5
2D54:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
2D58:  BSET.B  982.1
2D5A:  BSET.B  982.2
....................  
....................     insideMenu = true; 
2D5C:  BSET.B  885.0
.................... 	 
.................... 	while (!exitMenu){ 
2D5E:  BTSC.B  982.0
2D60:  BRA     2E60
.................... 		 
.................... 		currentPOS = POSCNT; 
2D62:  PUSH    126
2D64:  POP     97E
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2D66:  MOV     97E,W0
2D68:  CP      980
2D6A:  BRA     NZ,2D70
2D6C:  BTSS.B  982.2
2D6E:  BRA     2DE6
.................... 			 
.................... 			if (!firstLoopRun) 
2D70:  BTSC.B  982.2
2D72:  BRA     2DAE
.................... 			{ 
.................... 				direction = UPDN; 
2D74:  BCLR.B  982.1
2D76:  BTSC.B  123.3
2D78:  BSET.B  982.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
2D7A:  CLR.B   W0
2D7C:  BTSC.B  123.3
2D7E:  INC     W0,W0
2D80:  MOV.B   W0L,W4L
2D82:  CLR.B   9
2D84:  MUL.UU  W4,#2,W0
2D86:  SUB.B   W0L,#1,W0L
2D88:  ADD.B   983
.................... 				cursorLocation %= EDIT_ALARM_OPTIONS_PH_LOCATION; 
2D8A:  MOV.B   983,W0L
2D8C:  CLR.B   1
2D8E:  CLR.B   1
2D90:  MOV     #9,W4
2D92:  SE      W0,W0
2D94:  REPEAT  #11
2D96:  DIV.S   W0,W4
2D98:  MOV.B   W1L,W0L
2D9A:  MOV.B   W0L,983
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_OPTIONS_PH_LOCATION; 
2D9C:  MOV     982,W4
2D9E:  LSR     W4,#8,W4
2DA0:  CP.B    W4L,#0
2DA2:  BRA     GE,2DAE
2DA4:  MOV     982,W4
2DA6:  LSR     W4,#8,W4
2DA8:  ADD.B   W4L,#9,W4L
2DAA:  MOV.B   W4L,W0L
2DAC:  MOV.B   W0L,983
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
2DAE:  BCLR.B  982.2
.................... 			 
.................... 			displayEditAlarmOptions(); 
2DB0:  CALL    1DC4
.................... 			 
.................... 			SET_CURSOR_HOME; 
2DB4:  MOV.B   #F8,W0L
2DB6:  MOV.B   W0L,9B4
2DB8:  MOV.B   #2,W0L
2DBA:  MOV.B   W0L,9B5
2DBC:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_ALARM_OPTIONS_LOCATION[cursorLocation] ; i++) 
2DC0:  CLR     984
2DC2:  MOV.B   983,W0L
2DC4:  SE      W0,W0
2DC6:  MOV     #886,W4
2DC8:  ADD     W0,W4,W0
2DCA:  MOV     W0,W4
2DCC:  MOV.B   [W4],W0L
2DCE:  SE      W0,W0
2DD0:  MOV     984,W4
2DD2:  CP      W4,W0
2DD4:  BRA     GE,2DE6
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2DD6:  MOV.B   #F8,W0L
2DD8:  MOV.B   W0L,9B4
2DDA:  MOV.B   #14,W0L
2DDC:  MOV.B   W0L,9B5
2DDE:  CALL    B2C
.................... 			} 
2DE2:  INC     0984
2DE4:  BRA     2DC2
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2DE6:  BTSS.B  966.1
2DE8:  BRA     2E5A
.................... 		{ 
....................             pushAck = false; 
2DEA:  BCLR.B  966.1
....................             
.................... 			beep(true); 
2DEC:  MOV.B   #1,W0L
2DEE:  MOV.B   W0L,9AC
2DF0:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2DF4:  MOV     #32,W0
2DF6:  CALL    AEC
.................... 			beep(false); 
2DFA:  CLR.B   9AC
2DFC:  CALL    1E22
....................  
....................              
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2E00:  MOV.B   983,W0L
2E02:  CLR.B   1
2E04:  XOR     #0,W0
2E06:  BRA     Z,2E2A
2E08:  XOR     #1,W0
2E0A:  BRA     Z,2E30
2E0C:  XOR     #3,W0
2E0E:  BRA     Z,2E36
2E10:  XOR     #1,W0
2E12:  BRA     Z,2E3C
2E14:  XOR     #7,W0
2E16:  BRA     Z,2E42
2E18:  XOR     #1,W0
2E1A:  BRA     Z,2E48
2E1C:  XOR     #3,W0
2E1E:  BRA     Z,2E4E
2E20:  XOR     #1,W0
2E22:  BRA     Z,2E50
2E24:  XOR     #F,W0
2E26:  BRA     Z,2E56
2E28:  BRA     2E5A
.................... 				case 0: 
.................... 					EditAlarmTime(); 
2E2A:  CALL    2464
.................... 					break; 
2E2E:  BRA     2E5A
.................... 				case 1: 
.................... 					EditCarillon(); 
2E30:  CALL    2604
.................... 					break; 
2E34:  BRA     2E5A
.................... 				case 2: 
.................... 					EditDateAndTime(); 
2E36:  CALL    26E4
.................... 					break; 
2E3A:  BRA     2E5A
.................... 				case 3: 
.................... 					EditLoadLighting(); 
2E3C:  CALL    2882
.................... 					break; 
2E40:  BRA     2E5A
.................... 				case 4: 
.................... 					EditRGBLighting(); 
2E42:  CALL    2994
.................... 					break; 
2E46:  BRA     2E5A
.................... 				case 5: 
.................... 					EditVolume(); 
2E48:  CALL    2ACE
.................... 					break; 
2E4C:  BRA     2E5A
.................... 				case 6: 
.................... 					//EditBattery(); 
.................... 					break; 
2E4E:  BRA     2E5A
.................... 				case 7: 
.................... 					EditPowerCtrls(); 
2E50:  CALL    2C62
.................... 					break; 
2E54:  BRA     2E5A
.................... 				case 8: 
.................... 					exitMenu = true; 
2E56:  BSET.B  982.0
.................... 					break; 
2E58:  BRA     2E5A
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2E5A:  PUSH    97E
2E5C:  POP     980
.................... 	} 
2E5E:  BRA     2D5E
.................... 	 
.................... 	DISABLE_BLINKING_AND_CURSOR; 
2E60:  MOV.B   #F8,W0L
2E62:  MOV.B   W0L,9B4
2E64:  MOV.B   #C,W0L
2E66:  MOV.B   W0L,9B5
2E68:  CALL    B2C
.................... 	 
.................... 	insideMenu = false; 
2E6C:  BCLR.B  885.0
.................... } 
2E6E:  MOV     [--W15],W5
2E70:  RETURN  
....................  
.................... void EditDateAndTime() 
.................... { 
*
26E4:  MOV     W5,[W15++]
.................... 	disable_interrupts(INT_TIMER1); 
26E6:  BCLR.B  8C.3
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS; 
.................... 	int1 exitEditDateAndTime = false; 
.................... 	int8 cursorLocation = 0; 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
26E8:  BCLR.B  98A.0
26EA:  CLR.B   98B
26EC:  BSET.B  98A.1
26EE:  BSET.B  98A.2
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
26F0:  MOV.B   #F8,W0L
26F2:  MOV.B   W0L,9B4
26F4:  MOV.B   #F,W0L
26F6:  MOV.B   W0L,9B5
26F8:  CALL    B2C
.................... 	 
.................... 	while (!exitEditDateAndTime){ 
26FC:  BTSC.B  98A.0
26FE:  BRA     286C
.................... 		 
.................... 		 
.................... 		currentPOS = POSCNT; 
2700:  PUSH    126
2702:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2704:  MOV     986,W0
2706:  CP      988
2708:  BRA     NZ,270E
270A:  BTSS.B  98A.2
270C:  BRA     2784
.................... 			 
.................... 			 
.................... 			if (!firstLoopRun) 
270E:  BTSC.B  98A.2
2710:  BRA     274C
.................... 			{ 
.................... 				direction = UPDN; 
2712:  BCLR.B  98A.1
2714:  BTSC.B  123.3
2716:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
2718:  CLR.B   W0
271A:  BTSC.B  123.3
271C:  INC     W0,W0
271E:  MOV.B   W0L,W4L
2720:  CLR.B   9
2722:  MUL.UU  W4,#2,W0
2724:  SUB.B   W0L,#1,W0L
2726:  ADD.B   98B
.................... 				cursorLocation %= EDIT_DATE_TIME_PH_COUNT; 
2728:  MOV.B   98B,W0L
272A:  CLR.B   1
272C:  CLR.B   1
272E:  MOV     #7,W4
2730:  SE      W0,W0
2732:  REPEAT  #11
2734:  DIV.S   W0,W4
2736:  MOV.B   W1L,W0L
2738:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_DATE_TIME_PH_COUNT; 
273A:  MOV     98A,W4
273C:  LSR     W4,#8,W4
273E:  CP.B    W4L,#0
2740:  BRA     GE,274C
2742:  MOV     98A,W4
2744:  LSR     W4,#8,W4
2746:  ADD.B   W4L,#7,W4L
2748:  MOV.B   W4L,W0L
274A:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
274C:  BCLR.B  98A.2
.................... 			 
.................... 			displayEditDateAndTime(); 
274E:  CALL    1EA8
.................... 			 
.................... 			SET_CURSOR_HOME; 
2752:  MOV.B   #F8,W0L
2754:  MOV.B   W0L,9B4
2756:  MOV.B   #2,W0L
2758:  MOV.B   W0L,9B5
275A:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_DATE_TIME_PH_LOCATION[cursorLocation] ; i++) 
275E:  CLR     98C
2760:  MOV.B   98B,W0L
2762:  SE      W0,W0
2764:  MOV     #87E,W4
2766:  ADD     W0,W4,W0
2768:  MOV     W0,W4
276A:  MOV.B   [W4],W0L
276C:  SE      W0,W0
276E:  MOV     98C,W4
2770:  CP      W4,W0
2772:  BRA     GE,2784
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2774:  MOV.B   #F8,W0L
2776:  MOV.B   W0L,9B4
2778:  MOV.B   #14,W0L
277A:  MOV.B   W0L,9B5
277C:  CALL    B2C
.................... 			} 
2780:  INC     098C
2782:  BRA     2760
....................  
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2784:  BTSS.B  966.1
2786:  BRA     2866
.................... 		{ 
....................             pushAck = false; 
2788:  BCLR.B  966.1
.................... 			beep(true); 
278A:  MOV.B   #1,W0L
278C:  MOV.B   W0L,9AC
278E:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2792:  MOV     #32,W0
2794:  CALL    AEC
.................... 			beep(false); 
2798:  CLR.B   9AC
279A:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE			 
.................... 			switch (cursorLocation) 
.................... 			{ 
279E:  MOV.B   98B,W0L
27A0:  CLR.B   1
27A2:  XOR     #0,W0
27A4:  BRA     Z,27C0
27A6:  XOR     #1,W0
27A8:  BRA     Z,27DA
27AA:  XOR     #3,W0
27AC:  BRA     Z,27F4
27AE:  XOR     #1,W0
27B0:  BRA     Z,280E
27B2:  XOR     #7,W0
27B4:  BRA     Z,282A
27B6:  XOR     #1,W0
27B8:  BRA     Z,2846
27BA:  XOR     #3,W0
27BC:  BRA     Z,2862
27BE:  BRA     2866
.................... 				case 0: 
.................... 					editIntField(&CurrentTime.tm_hour, 0, 23,displayEditDateAndTime); 
27C0:  NOP     
27C2:  MOV.B   W0L,1
27C4:  MOV     #1EA8,W0
27C6:  MOV     W0,W5
27C8:  CLR     994
27CA:  MOV     #17,W4
27CC:  MOV     W4,996
27CE:  MOV     #92C,W4
27D0:  MOV     W4,992
27D2:  MOV     W5,998
27D4:  CALL    20F2
.................... 					break; 
27D8:  BRA     2866
.................... 				case 1: 
.................... 					editIntField(&CurrentTime.tm_min, 0, 59,displayEditDateAndTime); 
27DA:  NOP     
27DC:  MOV.B   W0L,1
27DE:  MOV     #1EA8,W0
27E0:  MOV     W0,W5
27E2:  CLR     994
27E4:  MOV     #3B,W4
27E6:  MOV     W4,996
27E8:  MOV     #92A,W4
27EA:  MOV     W4,992
27EC:  MOV     W5,998
27EE:  CALL    20F2
.................... 					break; 
27F2:  BRA     2866
.................... 				case 2: 
.................... 					editIntField(&CurrentTime.tm_sec, 0, 59,displayEditDateAndTime); 
27F4:  NOP     
27F6:  MOV.B   W0L,1
27F8:  MOV     #1EA8,W0
27FA:  MOV     W0,W5
27FC:  CLR     994
27FE:  MOV     #3B,W4
2800:  MOV     W4,996
2802:  MOV     #928,W4
2804:  MOV     W4,992
2806:  MOV     W5,998
2808:  CALL    20F2
.................... 					break; 
280C:  BRA     2866
.................... 				case 3: 
.................... 					editIntField(&CurrentTime.tm_mday, 1, 31,displayEditDateAndTime); 
280E:  NOP     
2810:  MOV.B   W0L,1
2812:  MOV     #1EA8,W0
2814:  MOV     W0,W5
2816:  MOV     #1,W4
2818:  MOV     W4,994
281A:  MOV     #1F,W4
281C:  MOV     W4,996
281E:  MOV     #92E,W4
2820:  MOV     W4,992
2822:  MOV     W5,998
2824:  CALL    20F2
.................... 					break; 
2828:  BRA     2866
.................... 				case 4: 
.................... 					editIntField(&CurrentTime.tm_mon, 1, 12,displayEditDateAndTime); 
282A:  NOP     
282C:  MOV.B   W0L,1
282E:  MOV     #1EA8,W0
2830:  MOV     W0,W5
2832:  MOV     #1,W4
2834:  MOV     W4,994
2836:  MOV     #C,W4
2838:  MOV     W4,996
283A:  MOV     #930,W4
283C:  MOV     W4,992
283E:  MOV     W5,998
2840:  CALL    20F2
.................... 					break; 
2844:  BRA     2866
.................... 				case 5: 
.................... 					editIntField(&CurrentTime.tm_year, 2000, 2050,displayEditDateAndTime); 
2846:  NOP     
2848:  MOV.B   W0L,1
284A:  MOV     #1EA8,W0
284C:  MOV     W0,W5
284E:  MOV     #932,W4
2850:  MOV     W4,992
2852:  MOV     #7D0,W4
2854:  MOV     W4,994
2856:  MOV     #802,W4
2858:  MOV     W4,996
285A:  MOV     W5,998
285C:  CALL    20F2
.................... 					break; 
2860:  BRA     2866
.................... 				case 6: 
.................... 					exitEditDateAndTime = true; 
2862:  BSET.B  98A.0
.................... 					break; 
2864:  BRA     2866
....................  
....................  
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2866:  PUSH    986
2868:  POP     988
.................... 	} 
286A:  BRA     26FC
.................... 	//DISABLE_BLINKING_AND_CURSOR; 
....................  
.................... 	// Recalculate new current date 
.................... 	alarmData.CurrentBinaryTime = DS1371_DateToBinary(&CurrentTime); 
286C:  MOV     #928,W4
286E:  MOV     W4,99C
2870:  CALL    91E
2874:  MOV     W0,866
2876:  MOV     W1,868
....................     // Recalculate next alarm 
....................     FindNextAlarmTime(); 
2878:  CALL    1830
.................... 	// Reenable  
.................... 	enable_interrupts(INT_TIMER1); 
287C:  BSET.B  8C.3
.................... } 
287E:  MOV     [--W15],W5
2880:  RETURN  
....................  
.................... void EditAlarmDays() 
.................... { 
*
21E0:  MOV     W5,[W15++]
21E2:  CLR     990
21E4:  BCLR.B  992.0
21E6:  MOV.B   898,W0L
21E8:  MOV.B   W0L,993
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_ALARM_DAYS_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
21EA:  MOV.B   #F8,W0L
21EC:  MOV.B   W0L,9B4
21EE:  MOV.B   #F,W0L
21F0:  MOV.B   W0L,9B5
21F2:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
21F6:  BSET.B  992.1
21F8:  BSET.B  992.2
.................... 	 
.................... 	while (!exitMenu){ 
21FA:  BTSC.B  992.0
21FC:  BRA     22CE
.................... 		 
.................... 		currentPOS = POSCNT; 
21FE:  PUSH    126
2200:  POP     98E
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2202:  MOV     98E,W0
2204:  CP      990
2206:  BRA     NZ,220C
2208:  BTSS.B  992.2
220A:  BRA     2282
.................... 			 
.................... 			if (!firstLoopRun) 
220C:  BTSC.B  992.2
220E:  BRA     224A
.................... 			{ 
.................... 				direction = UPDN; 
2210:  BCLR.B  992.1
2212:  BTSC.B  123.3
2214:  BSET.B  992.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
2216:  CLR.B   W0
2218:  BTSC.B  123.3
221A:  INC     W0,W0
221C:  MOV.B   W0L,W4L
221E:  CLR.B   9
2220:  MUL.UU  W4,#2,W0
2222:  SUB.B   W0L,#1,W0L
2224:  ADD.B   993
.................... 				cursorLocation %= EDIT_ALARM_DAYS_PH_LOCATION; 
2226:  MOV.B   993,W0L
2228:  CLR.B   1
222A:  CLR.B   1
222C:  MOV     #8,W4
222E:  SE      W0,W0
2230:  REPEAT  #11
2232:  DIV.S   W0,W4
2234:  MOV.B   W1L,W0L
2236:  MOV.B   W0L,993
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_DAYS_PH_LOCATION; 
2238:  MOV     992,W4
223A:  LSR     W4,#8,W4
223C:  CP.B    W4L,#0
223E:  BRA     GE,224A
2240:  MOV     992,W4
2242:  LSR     W4,#8,W4
2244:  ADD.B   W4L,#8,W4L
2246:  MOV.B   W4L,W0L
2248:  MOV.B   W0L,993
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
224A:  BCLR.B  992.2
.................... 			 
.................... 			displayAlarmDays(); 
224C:  CALL    217A
.................... 			 
.................... 			SET_CURSOR_HOME; 
2250:  MOV.B   #F8,W0L
2252:  MOV.B   W0L,9B4
2254:  MOV.B   #2,W0L
2256:  MOV.B   W0L,9B5
2258:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_ALARM_DAYS_LOCATION[cursorLocation] ; i++) 
225C:  CLR     994
225E:  MOV.B   993,W0L
2260:  SE      W0,W0
2262:  MOV     #898,W4
2264:  ADD     W0,W4,W0
2266:  MOV     W0,W4
2268:  MOV.B   [W4],W0L
226A:  SE      W0,W0
226C:  MOV     994,W4
226E:  CP      W4,W0
2270:  BRA     GE,2282
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2272:  MOV.B   #F8,W0L
2274:  MOV.B   W0L,9B4
2276:  MOV.B   #14,W0L
2278:  MOV.B   W0L,9B5
227A:  CALL    B2C
.................... 			} 
227E:  INC     0994
2280:  BRA     225E
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2282:  BTSS.B  966.1
2284:  BRA     22C8
.................... 		{ 
....................             pushAck = false; 
2286:  BCLR.B  966.1
.................... 			beep(true); 
2288:  MOV.B   #1,W0L
228A:  MOV.B   W0L,9AC
228C:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2290:  MOV     #32,W0
2292:  CALL    AEC
.................... 			beep(false); 
2296:  CLR.B   9AC
2298:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			 
.................... 			if (cursorLocation == 7) 
229C:  MOV     992,W4
229E:  LSR     W4,#8,W4
22A0:  CP.B    W4L,#7
22A2:  BRA     NZ,22A8
.................... 			{ 
.................... 				exitMenu = true; 
22A4:  BSET.B  992.0
.................... 			} 
.................... 			else 
22A6:  BRA     22C4
.................... 			{ 
.................... 				ALARM_DAYS[cursorLocation] = !ALARM_DAYS[cursorLocation]; 
22A8:  MOV.B   993,W0L
22AA:  SE      W0,W0
22AC:  MOV     #920,W4
22AE:  ADD     W0,W4,W5
22B0:  MOV.B   993,W0L
22B2:  SE      W0,W0
22B4:  MOV     #920,W4
22B6:  ADD     W0,W4,W0
22B8:  CP0.B   [W0]
22BA:  BRA     Z,22C0
22BC:  CLR.B   W0
22BE:  BRA     22C2
22C0:  MOV.B   #1,W0L
22C2:  MOV.B   W0L,[W5]
.................... 			} 
.................... 			 
.................... 			displayAlarmDays(); 
22C4:  CALL    217A
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
22C8:  PUSH    98E
22CA:  POP     990
.................... 	} 
22CC:  BRA     21FA
....................  
....................     FindNextAlarmTime(); 
22CE:  CALL    1830
.................... } 
22D2:  MOV     [--W15],W5
22D4:  RETURN  
....................  
.................... void EditAlarmTime() 
.................... { 
*
2464:  MOV     W5,[W15++]
2466:  CLR     988
2468:  BCLR.B  98A.0
246A:  MOV.B   892,W0L
246C:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_ALARM_TIME_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
246E:  MOV.B   #F8,W0L
2470:  MOV.B   W0L,9B4
2472:  MOV.B   #F,W0L
2474:  MOV.B   W0L,9B5
2476:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
247A:  BSET.B  98A.1
247C:  BSET.B  98A.2
.................... 	 
.................... 	while (!exitMenu){ 
247E:  BTSC.B  98A.0
2480:  BRA     259C
.................... 		 
.................... 		currentPOS = POSCNT; 
2482:  PUSH    126
2484:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2486:  MOV     986,W0
2488:  CP      988
248A:  BRA     NZ,2490
248C:  BTSS.B  98A.2
248E:  BRA     2506
.................... 			 
.................... 			if (!firstLoopRun) 
2490:  BTSC.B  98A.2
2492:  BRA     24CE
.................... 			{ 
.................... 				direction = UPDN; 
2494:  BCLR.B  98A.1
2496:  BTSC.B  123.3
2498:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
249A:  CLR.B   W0
249C:  BTSC.B  123.3
249E:  INC     W0,W0
24A0:  MOV.B   W0L,W4L
24A2:  CLR.B   9
24A4:  MUL.UU  W4,#2,W0
24A6:  SUB.B   W0L,#1,W0L
24A8:  ADD.B   98B
.................... 				cursorLocation %= EDIT_ALARM_TIME_PH_LOCATION; 
24AA:  MOV.B   98B,W0L
24AC:  CLR.B   1
24AE:  CLR.B   1
24B0:  MOV     #6,W4
24B2:  SE      W0,W0
24B4:  REPEAT  #11
24B6:  DIV.S   W0,W4
24B8:  MOV.B   W1L,W0L
24BA:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_TIME_PH_LOCATION; 
24BC:  MOV     98A,W4
24BE:  LSR     W4,#8,W4
24C0:  CP.B    W4L,#0
24C2:  BRA     GE,24CE
24C4:  MOV     98A,W4
24C6:  LSR     W4,#8,W4
24C8:  ADD.B   W4L,#6,W4L
24CA:  MOV.B   W4L,W0L
24CC:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
24CE:  BCLR.B  98A.2
.................... 			 
.................... 			displayEditAlarmTime(); 
24D0:  CALL    1E2A
.................... 			 
.................... 			SET_CURSOR_HOME; 
24D4:  MOV.B   #F8,W0L
24D6:  MOV.B   W0L,9B4
24D8:  MOV.B   #2,W0L
24DA:  MOV.B   W0L,9B5
24DC:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_ALARM_TIME_LOCATION[cursorLocation] ; i++) 
24E0:  CLR     98C
24E2:  MOV.B   98B,W0L
24E4:  SE      W0,W0
24E6:  MOV     #892,W4
24E8:  ADD     W0,W4,W0
24EA:  MOV     W0,W4
24EC:  MOV.B   [W4],W0L
24EE:  SE      W0,W0
24F0:  MOV     98C,W4
24F2:  CP      W4,W0
24F4:  BRA     GE,2506
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
24F6:  MOV.B   #F8,W0L
24F8:  MOV.B   W0L,9B4
24FA:  MOV.B   #14,W0L
24FC:  MOV.B   W0L,9B5
24FE:  CALL    B2C
.................... 			} 
2502:  INC     098C
2504:  BRA     24E2
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2506:  BTSS.B  966.1
2508:  BRA     2596
.................... 		{ 
....................             pushAck = false; 
250A:  BCLR.B  966.1
.................... 			beep(true); 
250C:  MOV.B   #1,W0L
250E:  MOV.B   W0L,9AC
2510:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2514:  MOV     #32,W0
2516:  CALL    AEC
.................... 			beep(false); 
251A:  CLR.B   9AC
251C:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2520:  MOV.B   98B,W0L
2522:  CLR.B   1
2524:  XOR     #0,W0
2526:  BRA     Z,253E
2528:  XOR     #1,W0
252A:  BRA     Z,254E
252C:  XOR     #3,W0
252E:  BRA     Z,2568
2530:  XOR     #1,W0
2532:  BRA     Z,2582
2534:  XOR     #7,W0
2536:  BRA     Z,2588
2538:  XOR     #1,W0
253A:  BRA     Z,258E
253C:  BRA     2592
.................... 				case 0: 
.................... 					ALARM_ENABLED = !ALARM_ENABLED; 
253E:  BTG.B   885.5
....................                      
....................                     if (ALARM_ENABLED) { 
2540:  BTSS.B  885.5
2542:  BRA     254A
....................                         RTCC_TransitionToSTANDBY(); 
2544:  CALL    18A0
....................                     } 
....................                     else { 
2548:  BRA     254C
....................                         alarmData.AlarmState = ALARM_MASTER_OFF; 
254A:  CLR.B   876
....................                     } 
....................  
.................... 					 
.................... 					break; 
254C:  BRA     2592
.................... 				case 1: 
.................... 					editIntField(&AlarmTime.tm_hour, 0, 23,displayEditAlarmTime); 
254E:  NOP     
2550:  MOV.B   W0L,1
2552:  MOV     #1E2A,W0
2554:  MOV     W0,W5
2556:  CLR     994
2558:  MOV     #17,W4
255A:  MOV     W4,996
255C:  MOV     #93E,W4
255E:  MOV     W4,992
2560:  MOV     W5,998
2562:  CALL    20F2
.................... 					break; 
2566:  BRA     2592
.................... 				case 2: 
.................... 					editIntField(&AlarmTime.tm_min, 0, 59,displayEditAlarmTime); 
2568:  NOP     
256A:  MOV.B   W0L,1
256C:  MOV     #1E2A,W0
256E:  MOV     W0,W5
2570:  CLR     994
2572:  MOV     #3B,W4
2574:  MOV     W4,996
2576:  MOV     #93C,W4
2578:  MOV     W4,992
257A:  MOV     W5,998
257C:  CALL    20F2
.................... 					break; 
2580:  BRA     2592
.................... 				case 3: 
.................... 					EditAlarmDays(); 
2582:  CALL    21E0
.................... 					break; 
2586:  BRA     2592
.................... 				case 4: 
.................... 					EditAlarmSnooze(); 
2588:  CALL    236C
.................... 					break; 
258C:  BRA     2592
.................... 				case 5: 
.................... 					exitMenu = true; 
258E:  BSET.B  98A.0
.................... 					break; 
2590:  BRA     2592
.................... 			} 
.................... 			displayEditAlarmTime(); 
2592:  CALL    1E2A
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2596:  PUSH    986
2598:  POP     988
.................... 	} 
259A:  BRA     247E
....................  
.................... 	FindNextAlarmTime(); 
259C:  CALL    1830
....................     //updateSnoozeTimeWithAlarmTime(); 
.................... } 
25A0:  MOV     [--W15],W5
25A2:  RETURN  
....................  
.................... void EditLoadLighting() 
.................... { 
*
2882:  MOV     W5,[W15++]
2884:  CLR     988
2886:  BCLR.B  98A.0
2888:  MOV.B   8A2,W0L
288A:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_LOAD_LIGHT_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
288C:  MOV.B   #F8,W0L
288E:  MOV.B   W0L,9B4
2890:  MOV.B   #F,W0L
2892:  MOV.B   W0L,9B5
2894:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
2898:  BSET.B  98A.1
289A:  BSET.B  98A.2
.................... 	 
.................... 	while (!exitMenu){ 
289C:  BTSC.B  98A.0
289E:  BRA     2990
.................... 		 
.................... 		currentPOS = POSCNT; 
28A0:  PUSH    126
28A2:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
28A4:  MOV     986,W0
28A6:  CP      988
28A8:  BRA     NZ,28AE
28AA:  BTSS.B  98A.2
28AC:  BRA     2924
.................... 			 
.................... 			if (!firstLoopRun) 
28AE:  BTSC.B  98A.2
28B0:  BRA     28EC
.................... 			{ 
.................... 				direction = UPDN; 
28B2:  BCLR.B  98A.1
28B4:  BTSC.B  123.3
28B6:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
28B8:  CLR.B   W0
28BA:  BTSC.B  123.3
28BC:  INC     W0,W0
28BE:  MOV.B   W0L,W4L
28C0:  CLR.B   9
28C2:  MUL.UU  W4,#2,W0
28C4:  SUB.B   W0L,#1,W0L
28C6:  ADD.B   98B
.................... 				cursorLocation %= EDIT_LOAD_LIGHT_PH_LOCATION; 
28C8:  MOV.B   98B,W0L
28CA:  CLR.B   1
28CC:  CLR.B   1
28CE:  MOV     #3,W4
28D0:  SE      W0,W0
28D2:  REPEAT  #11
28D4:  DIV.S   W0,W4
28D6:  MOV.B   W1L,W0L
28D8:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_LOAD_LIGHT_PH_LOCATION; 
28DA:  MOV     98A,W4
28DC:  LSR     W4,#8,W4
28DE:  CP.B    W4L,#0
28E0:  BRA     GE,28EC
28E2:  MOV     98A,W4
28E4:  LSR     W4,#8,W4
28E6:  ADD.B   W4L,#3,W4L
28E8:  MOV.B   W4L,W0L
28EA:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
28EC:  BCLR.B  98A.2
.................... 			 
.................... 			displayLoadLighting(); 
28EE:  CALL    1F84
.................... 			 
.................... 			SET_CURSOR_HOME; 
28F2:  MOV.B   #F8,W0L
28F4:  MOV.B   W0L,9B4
28F6:  MOV.B   #2,W0L
28F8:  MOV.B   W0L,9B5
28FA:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_LOAD_LIGHT_LOCATION[cursorLocation] ; i++) 
28FE:  CLR     98C
2900:  MOV.B   98B,W0L
2902:  SE      W0,W0
2904:  MOV     #8A2,W4
2906:  ADD     W0,W4,W0
2908:  MOV     W0,W4
290A:  MOV.B   [W4],W0L
290C:  SE      W0,W0
290E:  MOV     98C,W4
2910:  CP      W4,W0
2912:  BRA     GE,2924
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2914:  MOV.B   #F8,W0L
2916:  MOV.B   W0L,9B4
2918:  MOV.B   #14,W0L
291A:  MOV.B   W0L,9B5
291C:  CALL    B2C
.................... 			} 
2920:  INC     098C
2922:  BRA     2900
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2924:  BTSS.B  966.1
2926:  BRA     298A
.................... 		{ 
....................             pushAck = false; 
2928:  BCLR.B  966.1
.................... 			beep(true); 
292A:  MOV.B   #1,W0L
292C:  MOV.B   W0L,9AC
292E:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2932:  MOV     #32,W0
2934:  CALL    AEC
.................... 			beep(false); 
2938:  CLR.B   9AC
293A:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
293E:  MOV.B   98B,W0L
2940:  CLR.B   1
2942:  XOR     #0,W0
2944:  BRA     Z,2950
2946:  XOR     #1,W0
2948:  BRA     Z,296A
294A:  XOR     #3,W0
294C:  BRA     Z,2986
294E:  BRA     298A
.................... 				case 0: 
.................... 					editField(&maxLoadLighting, 0, 100,displayLoadLighting); 
2950:  NOP     
2952:  MOV.B   W0L,1
2954:  MOV     #1F84,W0
2956:  MOV     W0,W5
2958:  CLR.B   99C
295A:  MOV.B   #64,W0L
295C:  MOV.B   W0L,99D
295E:  MOV     #8BF,W4
2960:  MOV     W4,99A
2962:  MOV     W5,99E
2964:  CALL    22D6
.................... 					break; 
2968:  BRA     298A
.................... 				case 1: 
.................... 					editField(&delayLoadLighting, 1, 59,displayLoadLighting); 
296A:  NOP     
296C:  MOV.B   W0L,1
296E:  MOV     #1F84,W0
2970:  MOV     W0,W5
2972:  MOV.B   #1,W0L
2974:  MOV.B   W0L,99C
2976:  MOV.B   #3B,W0L
2978:  MOV.B   W0L,99D
297A:  MOV     #8E0,W4
297C:  MOV     W4,99A
297E:  MOV     W5,99E
2980:  CALL    22D6
.................... 					break; 
2984:  BRA     298A
.................... 				case 2: 
.................... 					exitMenu = true; 
2986:  BSET.B  98A.0
.................... 					break; 
2988:  BRA     298A
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
298A:  PUSH    986
298C:  POP     988
.................... 	} 
298E:  BRA     289C
.................... } 
2990:  MOV     [--W15],W5
2992:  RETURN  
....................  
.................... void EditBattery() 
.................... {} 
....................  
.................... void EditVolume() 
.................... { 
*
2ACE:  MOV     W5,[W15++]
2AD0:  CLR     988
2AD2:  BCLR.B  98A.0
2AD4:  MOV.B   8AC,W0L
2AD6:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_VOLUME_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
2AD8:  MOV.B   #F8,W0L
2ADA:  MOV.B   W0L,9B4
2ADC:  MOV.B   #F,W0L
2ADE:  MOV.B   W0L,9B5
2AE0:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
2AE4:  BSET.B  98A.1
2AE6:  BSET.B  98A.2
.................... 	 
.................... 	 
.................... 	while (!exitMenu){ 
2AE8:  BTSC.B  98A.0
2AEA:  BRA     2BDE
.................... 		 
.................... 		currentPOS = POSCNT; 
2AEC:  PUSH    126
2AEE:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2AF0:  MOV     986,W0
2AF2:  CP      988
2AF4:  BRA     NZ,2AFA
2AF6:  BTSS.B  98A.2
2AF8:  BRA     2B70
.................... 			 
.................... 			if (!firstLoopRun) 
2AFA:  BTSC.B  98A.2
2AFC:  BRA     2B38
.................... 			{ 
.................... 				direction = UPDN; 
2AFE:  BCLR.B  98A.1
2B00:  BTSC.B  123.3
2B02:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
2B04:  CLR.B   W0
2B06:  BTSC.B  123.3
2B08:  INC     W0,W0
2B0A:  MOV.B   W0L,W4L
2B0C:  CLR.B   9
2B0E:  MUL.UU  W4,#2,W0
2B10:  SUB.B   W0L,#1,W0L
2B12:  ADD.B   98B
.................... 				cursorLocation %= EDIT_VOLUME_PH_LOCATION; 
2B14:  MOV.B   98B,W0L
2B16:  CLR.B   1
2B18:  CLR.B   1
2B1A:  MOV     #3,W4
2B1C:  SE      W0,W0
2B1E:  REPEAT  #11
2B20:  DIV.S   W0,W4
2B22:  MOV.B   W1L,W0L
2B24:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_VOLUME_PH_LOCATION; 
2B26:  MOV     98A,W4
2B28:  LSR     W4,#8,W4
2B2A:  CP.B    W4L,#0
2B2C:  BRA     GE,2B38
2B2E:  MOV     98A,W4
2B30:  LSR     W4,#8,W4
2B32:  ADD.B   W4L,#3,W4L
2B34:  MOV.B   W4L,W0L
2B36:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
2B38:  BCLR.B  98A.2
.................... 			 
.................... 			displayVolume(); 
2B3A:  CALL    2090
.................... 			 
.................... 			SET_CURSOR_HOME; 
2B3E:  MOV.B   #F8,W0L
2B40:  MOV.B   W0L,9B4
2B42:  MOV.B   #2,W0L
2B44:  MOV.B   W0L,9B5
2B46:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_VOLUME_LOCATION[cursorLocation] ; i++) 
2B4A:  CLR     98C
2B4C:  MOV.B   98B,W0L
2B4E:  SE      W0,W0
2B50:  MOV     #8AC,W4
2B52:  ADD     W0,W4,W0
2B54:  MOV     W0,W4
2B56:  MOV.B   [W4],W0L
2B58:  SE      W0,W0
2B5A:  MOV     98C,W4
2B5C:  CP      W4,W0
2B5E:  BRA     GE,2B70
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2B60:  MOV.B   #F8,W0L
2B62:  MOV.B   W0L,9B4
2B64:  MOV.B   #14,W0L
2B66:  MOV.B   W0L,9B5
2B68:  CALL    B2C
.................... 			} 
2B6C:  INC     098C
2B6E:  BRA     2B4C
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2B70:  BTSS.B  966.1
2B72:  BRA     2BD8
.................... 		{ 
....................             pushAck = false; 
2B74:  BCLR.B  966.1
.................... 			beep(true); 
2B76:  MOV.B   #1,W0L
2B78:  MOV.B   W0L,9AC
2B7A:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2B7E:  MOV     #32,W0
2B80:  CALL    AEC
.................... 			beep(false); 
2B84:  CLR.B   9AC
2B86:  CALL    1E22
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2B8A:  MOV.B   98B,W0L
2B8C:  CLR.B   1
2B8E:  XOR     #0,W0
2B90:  BRA     Z,2B9C
2B92:  XOR     #1,W0
2B94:  BRA     Z,2BB8
2B96:  XOR     #3,W0
2B98:  BRA     Z,2BD4
2B9A:  BRA     2BD8
.................... 				case 0: 
.................... 					editField(&chimeVolume, MIN_VOLUME, MAX_VOLUME,displayVolume); 
2B9C:  NOP     
2B9E:  MOV.B   W0L,1
2BA0:  MOV     #2090,W0
2BA2:  MOV     W0,W5
2BA4:  MOV.B   #1,W0L
2BA6:  MOV.B   W0L,99C
2BA8:  MOV.B   #64,W0L
2BAA:  MOV.B   W0L,99D
2BAC:  MOV     #8B3,W4
2BAE:  MOV     W4,99A
2BB0:  MOV     W5,99E
2BB2:  CALL    22D6
.................... 					break; 
2BB6:  BRA     2BD8
.................... 				case 1: 
.................... 					editField(&toneSelect, 1, TONE_COUNT,displayVolume); 
2BB8:  NOP     
2BBA:  MOV.B   W0L,1
2BBC:  MOV     #2090,W0
2BBE:  MOV     W0,W5
2BC0:  MOV.B   #1,W0L
2BC2:  MOV.B   W0L,99C
2BC4:  MOV.B   #1,W0L
2BC6:  MOV.B   W0L,99D
2BC8:  MOV     #8BE,W4
2BCA:  MOV     W4,99A
2BCC:  MOV     W5,99E
2BCE:  CALL    22D6
.................... 					break; 
2BD2:  BRA     2BD8
.................... 				case 2: 
.................... 					exitMenu = true; 
2BD4:  BSET.B  98A.0
.................... 					break; 
2BD6:  BRA     2BD8
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2BD8:  PUSH    986
2BDA:  POP     988
.................... 	} 
2BDC:  BRA     2AE8
.................... } 
2BDE:  MOV     [--W15],W5
2BE0:  RETURN  
....................  
....................  
.................... void EditCarillon() 
.................... { 
*
2604:  MOV     W5,[W15++]
2606:  CLR     988
2608:  BCLR.B  98A.0
260A:  MOV.B   890,W0L
260C:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_CARILLON_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
260E:  MOV.B   #F8,W0L
2610:  MOV.B   W0L,9B4
2612:  MOV.B   #F,W0L
2614:  MOV.B   W0L,9B5
2616:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
261A:  BSET.B  98A.1
261C:  BSET.B  98A.2
.................... 	 
.................... 	 
.................... 	while (!exitMenu){ 
261E:  BTSC.B  98A.0
2620:  BRA     26E0
.................... 		 
.................... 		currentPOS = POSCNT; 
2622:  PUSH    126
2624:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2626:  MOV     986,W0
2628:  CP      988
262A:  BRA     NZ,2630
262C:  BTSS.B  98A.2
262E:  BRA     26A6
.................... 			 
.................... 			if (!firstLoopRun) 
2630:  BTSC.B  98A.2
2632:  BRA     266E
.................... 			{ 
.................... 				direction = UPDN; 
2634:  BCLR.B  98A.1
2636:  BTSC.B  123.3
2638:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
263A:  CLR.B   W0
263C:  BTSC.B  123.3
263E:  INC     W0,W0
2640:  MOV.B   W0L,W4L
2642:  CLR.B   9
2644:  MUL.UU  W4,#2,W0
2646:  SUB.B   W0L,#1,W0L
2648:  ADD.B   98B
.................... 				cursorLocation %= EDIT_CARILLON_PH_LOCATION; 
264A:  MOV.B   98B,W0L
264C:  CLR.B   1
264E:  CLR.B   1
2650:  MOV     #2,W4
2652:  SE      W0,W0
2654:  REPEAT  #11
2656:  DIV.S   W0,W4
2658:  MOV.B   W1L,W0L
265A:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_CARILLON_PH_LOCATION; 
265C:  MOV     98A,W4
265E:  LSR     W4,#8,W4
2660:  CP.B    W4L,#0
2662:  BRA     GE,266E
2664:  MOV     98A,W4
2666:  LSR     W4,#8,W4
2668:  ADD.B   W4L,#2,W4L
266A:  MOV.B   W4L,W0L
266C:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
266E:  BCLR.B  98A.2
.................... 			 
.................... 			displayCarillon(); 
2670:  CALL    25A4
.................... 			 
.................... 			SET_CURSOR_HOME; 
2674:  MOV.B   #F8,W0L
2676:  MOV.B   W0L,9B4
2678:  MOV.B   #2,W0L
267A:  MOV.B   W0L,9B5
267C:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_CARILLON_LOCATION[cursorLocation] ; i++) 
2680:  CLR     98C
2682:  MOV.B   98B,W0L
2684:  SE      W0,W0
2686:  MOV     #890,W4
2688:  ADD     W0,W4,W0
268A:  MOV     W0,W4
268C:  MOV.B   [W4],W0L
268E:  SE      W0,W0
2690:  MOV     98C,W4
2692:  CP      W4,W0
2694:  BRA     GE,26A6
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2696:  MOV.B   #F8,W0L
2698:  MOV.B   W0L,9B4
269A:  MOV.B   #14,W0L
269C:  MOV.B   W0L,9B5
269E:  CALL    B2C
.................... 			} 
26A2:  INC     098C
26A4:  BRA     2682
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
26A6:  BTSS.B  966.1
26A8:  BRA     26DA
.................... 		{ 
....................             pushAck = false; 
26AA:  BCLR.B  966.1
.................... 			beep(true); 
26AC:  MOV.B   #1,W0L
26AE:  MOV.B   W0L,9AC
26B0:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
26B4:  MOV     #32,W0
26B6:  CALL    AEC
.................... 			beep(false); 
26BA:  CLR.B   9AC
26BC:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
26C0:  MOV.B   98B,W0L
26C2:  CLR.B   1
26C4:  XOR     #0,W0
26C6:  BRA     Z,26CE
26C8:  XOR     #1,W0
26CA:  BRA     Z,26D6
26CC:  BRA     26DA
.................... 				case 0: 
.................... 					carillon = !carillon; 
26CE:  BTG.B   885.2
.................... 					displayCarillon(); 
26D0:  CALL    25A4
.................... 					break; 
26D4:  BRA     26DA
.................... 				case 1: 
.................... 					exitMenu = true; 
26D6:  BSET.B  98A.0
.................... 					break; 
26D8:  BRA     26DA
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
26DA:  PUSH    986
26DC:  POP     988
.................... 	} 
26DE:  BRA     261E
.................... } 
26E0:  MOV     [--W15],W5
26E2:  RETURN  
....................  
....................  
.................... void EditAlarmSnooze() 
.................... { 
*
236C:  MOV     W5,[W15++]
236E:  CLR     990
2370:  BCLR.B  992.0
2372:  MOV.B   8A0,W0L
2374:  MOV.B   W0L,993
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_ALARM_SNOOZE_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
2376:  MOV.B   #F8,W0L
2378:  MOV.B   W0L,9B4
237A:  MOV.B   #F,W0L
237C:  MOV.B   W0L,9B5
237E:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
2382:  BSET.B  992.1
2384:  BSET.B  992.2
.................... 	 
.................... 	while (!exitMenu){ 
2386:  BTSC.B  992.0
2388:  BRA     245C
.................... 		 
.................... 		currentPOS = POSCNT; 
238A:  PUSH    126
238C:  POP     98E
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
238E:  MOV     98E,W0
2390:  CP      990
2392:  BRA     NZ,2398
2394:  BTSS.B  992.2
2396:  BRA     240E
.................... 			 
.................... 			if (!firstLoopRun) 
2398:  BTSC.B  992.2
239A:  BRA     23D6
.................... 			{ 
.................... 				direction = UPDN; 
239C:  BCLR.B  992.1
239E:  BTSC.B  123.3
23A0:  BSET.B  992.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
23A2:  CLR.B   W0
23A4:  BTSC.B  123.3
23A6:  INC     W0,W0
23A8:  MOV.B   W0L,W4L
23AA:  CLR.B   9
23AC:  MUL.UU  W4,#2,W0
23AE:  SUB.B   W0L,#1,W0L
23B0:  ADD.B   993
.................... 				cursorLocation %= EDIT_ALARM_SNOOZE_PH_LOCATION; 
23B2:  MOV.B   993,W0L
23B4:  CLR.B   1
23B6:  CLR.B   1
23B8:  MOV     #2,W4
23BA:  SE      W0,W0
23BC:  REPEAT  #11
23BE:  DIV.S   W0,W4
23C0:  MOV.B   W1L,W0L
23C2:  MOV.B   W0L,993
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_SNOOZE_PH_LOCATION; 
23C4:  MOV     992,W4
23C6:  LSR     W4,#8,W4
23C8:  CP.B    W4L,#0
23CA:  BRA     GE,23D6
23CC:  MOV     992,W4
23CE:  LSR     W4,#8,W4
23D0:  ADD.B   W4L,#2,W4L
23D2:  MOV.B   W4L,W0L
23D4:  MOV.B   W0L,993
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
23D6:  BCLR.B  992.2
.................... 			 
.................... 			displaySnooze(); 
23D8:  CALL    1F2C
.................... 			 
.................... 			SET_CURSOR_HOME; 
23DC:  MOV.B   #F8,W0L
23DE:  MOV.B   W0L,9B4
23E0:  MOV.B   #2,W0L
23E2:  MOV.B   W0L,9B5
23E4:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_ALARM_SNOOZE_LOCATION[cursorLocation] ; i++) 
23E8:  CLR     994
23EA:  MOV.B   993,W0L
23EC:  SE      W0,W0
23EE:  MOV     #8A0,W4
23F0:  ADD     W0,W4,W0
23F2:  MOV     W0,W4
23F4:  MOV.B   [W4],W0L
23F6:  SE      W0,W0
23F8:  MOV     994,W4
23FA:  CP      W4,W0
23FC:  BRA     GE,240E
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
23FE:  MOV.B   #F8,W0L
2400:  MOV.B   W0L,9B4
2402:  MOV.B   #14,W0L
2404:  MOV.B   W0L,9B5
2406:  CALL    B2C
.................... 			} 
240A:  INC     0994
240C:  BRA     23EA
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
240E:  BTSS.B  966.1
2410:  BRA     2456
.................... 		{ 
....................             pushAck = false; 
2412:  BCLR.B  966.1
.................... 			beep(true); 
2414:  MOV.B   #1,W0L
2416:  MOV.B   W0L,9AC
2418:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
241C:  MOV     #32,W0
241E:  CALL    AEC
.................... 			beep(false); 
2422:  CLR.B   9AC
2424:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2428:  MOV.B   993,W0L
242A:  CLR.B   1
242C:  XOR     #0,W0
242E:  BRA     Z,2436
2430:  XOR     #1,W0
2432:  BRA     Z,2452
2434:  BRA     2456
.................... 				case 0: 
.................... 					editField(&AlarmSnoozeTime,1,30,displaySnooze); 
2436:  NOP     
2438:  MOV.B   W0L,1
243A:  MOV     #1F2C,W0
243C:  MOV     W0,W5
243E:  MOV.B   #1,W0L
2440:  MOV.B   W0L,99C
2442:  MOV.B   #1E,W0L
2444:  MOV.B   W0L,99D
2446:  MOV     #8E1,W4
2448:  MOV     W4,99A
244A:  MOV     W5,99E
244C:  CALL    22D6
.................... 					break; 
2450:  BRA     2456
.................... 				case 1: 
.................... 					exitMenu = true; 
2452:  BSET.B  992.0
.................... 					break; 
2454:  BRA     2456
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2456:  PUSH    98E
2458:  POP     990
.................... 	} 
245A:  BRA     2386
....................      
....................     FindNextAlarmTime(); 
245C:  CALL    1830
.................... } 
2460:  MOV     [--W15],W5
2462:  RETURN  
....................  
.................... void EditRGBLighting() 
.................... { 
*
2994:  MOV     W5,[W15++]
2996:  CLR     988
2998:  BCLR.B  98A.0
299A:  MOV.B   8A6,W0L
299C:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_RGB_LIGHT_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
299E:  MOV.B   #F8,W0L
29A0:  MOV.B   W0L,9B4
29A2:  MOV.B   #F,W0L
29A4:  MOV.B   W0L,9B5
29A6:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
29AA:  BSET.B  98A.1
29AC:  BSET.B  98A.2
.................... 	 
.................... 	while (!exitMenu){ 
29AE:  BTSC.B  98A.0
29B0:  BRA     2ACA
.................... 		 
.................... 		currentPOS = POSCNT; 
29B2:  PUSH    126
29B4:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
29B6:  MOV     986,W0
29B8:  CP      988
29BA:  BRA     NZ,29C0
29BC:  BTSS.B  98A.2
29BE:  BRA     2A36
.................... 			 
.................... 			if (!firstLoopRun) 
29C0:  BTSC.B  98A.2
29C2:  BRA     29FE
.................... 			{ 
.................... 				direction = UPDN; 
29C4:  BCLR.B  98A.1
29C6:  BTSC.B  123.3
29C8:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
29CA:  CLR.B   W0
29CC:  BTSC.B  123.3
29CE:  INC     W0,W0
29D0:  MOV.B   W0L,W4L
29D2:  CLR.B   9
29D4:  MUL.UU  W4,#2,W0
29D6:  SUB.B   W0L,#1,W0L
29D8:  ADD.B   98B
.................... 				cursorLocation %= EDIT_RGB_LIGHT_PH_LOCATION; 
29DA:  MOV.B   98B,W0L
29DC:  CLR.B   1
29DE:  CLR.B   1
29E0:  MOV     #5,W4
29E2:  SE      W0,W0
29E4:  REPEAT  #11
29E6:  DIV.S   W0,W4
29E8:  MOV.B   W1L,W0L
29EA:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_RGB_LIGHT_PH_LOCATION; 
29EC:  MOV     98A,W4
29EE:  LSR     W4,#8,W4
29F0:  CP.B    W4L,#0
29F2:  BRA     GE,29FE
29F4:  MOV     98A,W4
29F6:  LSR     W4,#8,W4
29F8:  ADD.B   W4L,#5,W4L
29FA:  MOV.B   W4L,W0L
29FC:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
29FE:  BCLR.B  98A.2
.................... 			 
.................... 			displayRGBLight(); 
2A00:  CALL    1FE6
.................... 			 
.................... 			SET_CURSOR_HOME; 
2A04:  MOV.B   #F8,W0L
2A06:  MOV.B   W0L,9B4
2A08:  MOV.B   #2,W0L
2A0A:  MOV.B   W0L,9B5
2A0C:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_RGB_LIGHT_LOCATION[cursorLocation] ; i++) 
2A10:  CLR     98C
2A12:  MOV.B   98B,W0L
2A14:  SE      W0,W0
2A16:  MOV     #8A6,W4
2A18:  ADD     W0,W4,W0
2A1A:  MOV     W0,W4
2A1C:  MOV.B   [W4],W0L
2A1E:  SE      W0,W0
2A20:  MOV     98C,W4
2A22:  CP      W4,W0
2A24:  BRA     GE,2A36
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2A26:  MOV.B   #F8,W0L
2A28:  MOV.B   W0L,9B4
2A2A:  MOV.B   #14,W0L
2A2C:  MOV.B   W0L,9B5
2A2E:  CALL    B2C
.................... 			} 
2A32:  INC     098C
2A34:  BRA     2A12
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2A36:  BTSS.B  966.1
2A38:  BRA     2AC4
.................... 		{ 
....................             pushAck = false; 
2A3A:  BCLR.B  966.1
.................... 			beep(true); 
2A3C:  MOV.B   #1,W0L
2A3E:  MOV.B   W0L,9AC
2A40:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2A44:  MOV     #32,W0
2A46:  CALL    AEC
.................... 			beep(false); 
2A4A:  CLR.B   9AC
2A4C:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2A50:  MOV.B   98B,W0L
2A52:  CLR.B   1
2A54:  XOR     #0,W0
2A56:  BRA     Z,2A6A
2A58:  XOR     #1,W0
2A5A:  BRA     Z,2A72
2A5C:  XOR     #3,W0
2A5E:  BRA     Z,2A8C
2A60:  XOR     #1,W0
2A62:  BRA     Z,2AA6
2A64:  XOR     #7,W0
2A66:  BRA     Z,2AC0
2A68:  BRA     2AC4
.................... 				case 0: 
.................... 					moodEnable = !moodEnable; 
2A6A:  BTG.B   885.1
.................... 					displayRGBLight(); 
2A6C:  CALL    1FE6
.................... 					break; 
2A70:  BRA     2AC4
.................... 				case 1: 
.................... 					editIntField(&hsvColor.hue,0,359,displayRGBLight); 
2A72:  NOP     
2A74:  MOV.B   W0L,1
2A76:  MOV     #1FE6,W0
2A78:  MOV     W0,W5
2A7A:  CLR     994
2A7C:  MOV     #8B8,W4
2A7E:  MOV     W4,992
2A80:  MOV     #167,W4
2A82:  MOV     W4,996
2A84:  MOV     W5,998
2A86:  CALL    20F2
.................... 					break; 
2A8A:  BRA     2AC4
.................... 				case 2: 
.................... 					editField(&hsvColor.saturation,0,255,displayRGBLight); 
2A8C:  NOP     
2A8E:  MOV.B   W0L,1
2A90:  MOV     #1FE6,W0
2A92:  MOV     W0,W5
2A94:  CLR.B   99C
2A96:  MOV.B   #FF,W0L
2A98:  MOV.B   W0L,99D
2A9A:  MOV     #8BA,W4
2A9C:  MOV     W4,99A
2A9E:  MOV     W5,99E
2AA0:  CALL    22D6
.................... 					break; 
2AA4:  BRA     2AC4
.................... 				case 3: 
.................... 					editField(&hsvColor.value,0,255,displayRGBLight); 
2AA6:  NOP     
2AA8:  MOV.B   W0L,1
2AAA:  MOV     #1FE6,W0
2AAC:  MOV     W0,W5
2AAE:  CLR.B   99C
2AB0:  MOV.B   #FF,W0L
2AB2:  MOV.B   W0L,99D
2AB4:  MOV     #8BB,W4
2AB6:  MOV     W4,99A
2AB8:  MOV     W5,99E
2ABA:  CALL    22D6
.................... 					break; 
2ABE:  BRA     2AC4
.................... 				case 4: 
.................... 					exitMenu = true; 
2AC0:  BSET.B  98A.0
.................... 					break; 
2AC2:  BRA     2AC4
.................... 			} 
.................... 		} 
.................... 		 
.................... 		previousPOS = currentPOS; 
2AC4:  PUSH    986
2AC6:  POP     988
.................... 	} 
2AC8:  BRA     29AE
.................... } 
2ACA:  MOV     [--W15],W5
2ACC:  RETURN  
....................  
.................... void EditPowerCtrls() 
.................... { 
*
2C62:  MOV     W5,[W15++]
2C64:  CLR     988
2C66:  BCLR.B  98A.0
2C68:  MOV.B   8B0,W0L
2C6A:  MOV.B   W0L,98B
.................... 	int16 currentPOS; 
.................... 	int16 previousPOS = 0; 
.................... 	int1 exitMenu = false; 
.................... 	int8 cursorLocation = EDIT_LOAD_DISPLAY_LOCATION[0]; 
.................... 	 
.................... 	//Enter select mode 
.................... 	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT); 
2C6C:  MOV.B   #F8,W0L
2C6E:  MOV.B   W0L,9B4
2C70:  MOV.B   #F,W0L
2C72:  MOV.B   W0L,9B5
2C74:  CALL    B2C
.................... 	 
.................... 	int1  direction = UP; 
.................... 	int1  firstLoopRun = TRUE; 
2C78:  BSET.B  98A.1
2C7A:  BSET.B  98A.2
.................... 	 
.................... 	while (!exitMenu){ 
2C7C:  BTSC.B  98A.0
2C7E:  BRA     2D3E
.................... 		 
.................... 		currentPOS = POSCNT; 
2C80:  PUSH    126
2C82:  POP     986
.................... 		if ((currentPOS != previousPOS) || (firstLoopRun)) { 
2C84:  MOV     986,W0
2C86:  CP      988
2C88:  BRA     NZ,2C8E
2C8A:  BTSS.B  98A.2
2C8C:  BRA     2D00
.................... 			 
.................... 			if (!firstLoopRun) 
2C8E:  BTSC.B  98A.2
2C90:  BRA     2CCC
.................... 			{ 
.................... 				direction = UPDN; 
2C92:  BCLR.B  98A.1
2C94:  BTSC.B  123.3
2C96:  BSET.B  98A.1
.................... 				cursorLocation += ((int8)UPDN)*2-1; 
2C98:  CLR.B   W0
2C9A:  BTSC.B  123.3
2C9C:  INC     W0,W0
2C9E:  MOV.B   W0L,W4L
2CA0:  CLR.B   9
2CA2:  MUL.UU  W4,#2,W0
2CA4:  SUB.B   W0L,#1,W0L
2CA6:  ADD.B   98B
.................... 				cursorLocation %= EDIT_LOAD_DISPLAY_PH_LOCATION; 
2CA8:  MOV.B   98B,W0L
2CAA:  CLR.B   1
2CAC:  CLR.B   1
2CAE:  MOV     #3,W4
2CB0:  SE      W0,W0
2CB2:  REPEAT  #11
2CB4:  DIV.S   W0,W4
2CB6:  MOV.B   W1L,W0L
2CB8:  MOV.B   W0L,98B
.................... 				if (cursorLocation < 0) cursorLocation += EDIT_LOAD_DISPLAY_PH_LOCATION; 
2CBA:  MOV     98A,W4
2CBC:  LSR     W4,#8,W4
2CBE:  CP.B    W4L,#0
2CC0:  BRA     GE,2CCC
2CC2:  MOV     98A,W4
2CC4:  LSR     W4,#8,W4
2CC6:  ADD.B   W4L,#3,W4L
2CC8:  MOV.B   W4L,W0L
2CCA:  MOV.B   W0L,98B
.................... 				 
.................... 			} 
.................... 			firstLoopRun = false; 
2CCC:  BCLR.B  98A.2
.................... 			 
.................... 			//displayPowerCtrls(); 
.................... 			 
.................... 			SET_CURSOR_HOME; 
2CCE:  MOV.B   #F8,W0L
2CD0:  MOV.B   W0L,9B4
2CD2:  MOV.B   #2,W0L
2CD4:  MOV.B   W0L,9B5
2CD6:  CALL    B2C
.................... 			int i; 
.................... 			for (i = 0 ; i < EDIT_LOAD_DISPLAY_LOCATION[cursorLocation] ; i++) 
2CDA:  CLR     98C
2CDC:  MOV.B   98B,W0L
2CDE:  SE      W0,W0
2CE0:  MOV     #8B0,W4
2CE2:  ADD     W0,W4,W0
2CE4:  MOV     W0,W4
2CE6:  MOV.B   [W4],W0L
2CE8:  SE      W0,W0
2CEA:  MOV     98C,W4
2CEC:  CP      W4,W0
2CEE:  BRA     GE,2D00
.................... 			{ 
.................... 				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT); 
2CF0:  MOV.B   #F8,W0L
2CF2:  MOV.B   W0L,9B4
2CF4:  MOV.B   #14,W0L
2CF6:  MOV.B   W0L,9B5
2CF8:  CALL    B2C
.................... 			} 
2CFC:  INC     098C
2CFE:  BRA     2CDC
.................... 			 
.................... 		} 
.................... 		 
.................... 		if (pushAck) 
2D00:  BTSS.B  966.1
2D02:  BRA     2D34
.................... 		{ 
....................             pushAck = false; 
2D04:  BCLR.B  966.1
.................... 			beep(true); 
2D06:  MOV.B   #1,W0L
2D08:  MOV.B   W0L,9AC
2D0A:  CALL    1E22
.................... 			delay_ms(BUZZER_ON_TIME); 
2D0E:  MOV     #32,W0
2D10:  CALL    AEC
.................... 			beep(false); 
2D14:  CLR.B   9AC
2D16:  CALL    1E22
....................  
.................... 			//GO TO EDIT OR EXIT MODE 
.................... 			switch (cursorLocation) 
.................... 			{ 
2D1A:  MOV.B   98B,W0L
2D1C:  CLR.B   1
2D1E:  XOR     #0,W0
2D20:  BRA     Z,2D2C
2D22:  XOR     #1,W0
2D24:  BRA     Z,2D2E
2D26:  XOR     #3,W0
2D28:  BRA     Z,2D30
2D2A:  BRA     2D34
.................... 				case 0: 
.................... 					//editIntField(&phaseOffset,0,0x7FFF,displayPowerCtrls); 
.................... 					break; 
2D2C:  BRA     2D34
.................... 				case 1: 
.................... 					//editIntField(&pulseWidth,0,0x7FFF,displayPowerCtrls); 
.................... 					break; 
2D2E:  BRA     2D34
.................... 				case 2: 
.................... 					exitMenu = true; 
2D30:  BSET.B  98A.0
.................... 					break; 
2D32:  BRA     2D34
.................... 			} 
.................... 		} 
.................... 		displayPowerCtrls(); 
2D34:  CALL    2BE2
.................... 		previousPOS = currentPOS; 
2D38:  PUSH    986
2D3A:  POP     988
.................... 	} 
2D3C:  BRA     2C7C
.................... } 
2D3E:  MOV     [--W15],W5
2D40:  RETURN  
....................  
.................... void editField(byte * field, byte minimum, byte maximum, funPtr displayFunction) 
.................... { 
*
22D6:  MOV     W5,[W15++]
22D8:  PUSH    126
22DA:  POP     9A0
.................... 	//PUSH POSCNT CONTEXT 
.................... 	int16 initialPOSCNT = POSCNT; 
.................... 	//Load field into POSCNT 
.................... 	POSCNT = *field; 
22DC:  MOV     99A,W0
22DE:  MOV     W0,W4
22E0:  MOV.B   [W4],W0L
22E2:  CLR.B   1
22E4:  MOV     W0,126
.................... 	 
.................... 	int16 previousPOS = POSCNT; 
.................... 	int16 currentPOS = POSCNT; 
22E6:  PUSH    126
22E8:  POP     9A2
22EA:  PUSH    126
22EC:  POP     9A4
.................... 	 
.................... 	//While User doesn't push button 
.................... 	while(!pushAck) 
.................... 	{ 
22EE:  BTSC.B  966.1
22F0:  BRA     234E
.................... 		currentPOS = POSCNT; 
22F2:  PUSH    126
22F4:  POP     9A4
.................... 		*field = currentPOS; 
22F6:  MOV     99A,W5
22F8:  MOV.B   9A4,W0L
22FA:  MOV.B   W0L,[W5+#0]
.................... 		 
.................... 		if (*field == minimum-1) 
22FC:  MOV     99A,W0
22FE:  MOV.B   [W0],W5L
2300:  MOV     99C,W4
2302:  SUB.B   W4L,#1,W0L
2304:  CP.B    W5L,W0L
2306:  BRA     NZ,231C
.................... 		{ 
.................... 			currentPOS = maximum; 
2308:  MOV.B   99D,W0L
230A:  MOV.B   W0L,9A4
230C:  CLR.B   9A5
.................... 			POSCNT = maximum; 
230E:  MOV.B   99D,W0L
2310:  MOV.B   W0L,126
2312:  CLR.B   127
.................... 			*field = currentPOS; 
2314:  MOV     99A,W5
2316:  MOV.B   9A4,W0L
2318:  MOV.B   W0L,[W5+#0]
.................... 		} 
.................... 		else if (*field > maximum) { 
231A:  BRA     233A
231C:  MOV     99A,W0
231E:  MOV.B   [W0],W0L
2320:  MOV     99C,W4
2322:  LSR     W4,#8,W4
2324:  CP.B    W4L,W0L
2326:  BRA     C,233A
.................... 			currentPOS = minimum; 
2328:  MOV.B   99C,W0L
232A:  MOV.B   W0L,9A4
232C:  CLR.B   9A5
.................... 			POSCNT = minimum; 
232E:  MOV.B   99C,W0L
2330:  MOV.B   W0L,126
2332:  CLR.B   127
.................... 			*field = currentPOS; 
2334:  MOV     99A,W5
2336:  MOV.B   9A4,W0L
2338:  MOV.B   W0L,[W5+#0]
.................... 		} 
.................... 		if (previousPOS != currentPOS) 
233A:  MOV     9A2,W0
233C:  CP      9A4
233E:  BRA     Z,2348
.................... 		{ 
.................... 			(*displayFunction)(); 
2340:  MOV     99E,W2
2342:  MOV     #0,W3
2344:  CALL    2B6
.................... 			//displayEditDateAndTime(); 
.................... 		} 
.................... 		previousPOS = currentPOS; 
2348:  PUSH    9A4
234A:  POP     9A2
.................... 	} 
234C:  BRA     22EE
....................      
....................     pushAck = false; 
234E:  BCLR.B  966.1
.................... 	 
.................... 	beep(true); 
2350:  MOV.B   #1,W0L
2352:  MOV.B   W0L,9AC
2354:  CALL    1E22
.................... 	delay_ms(BUZZER_ON_TIME); 
2358:  MOV     #32,W0
235A:  CALL    AEC
.................... 	beep(false); 
235E:  CLR.B   9AC
2360:  CALL    1E22
....................      
.................... 	//POP POSCNT CONTEXT 
.................... 	POSCNT = initialPOSCNT; 
2364:  PUSH    9A0
2366:  POP     126
.................... } 
2368:  MOV     [--W15],W5
236A:  RETURN  
....................  
.................... void editIntField(int * field, int minimum, int maximum, funPtr displayFunction) 
.................... { 
*
20F2:  MOV     W5,[W15++]
20F4:  PUSH    126
20F6:  POP     99A
.................... 	//PUSH POSCNT CONTEXT 
.................... 	int16 initialPOSCNT = POSCNT; 
.................... 	//Load field into POSCNT 
.................... 	POSCNT = *field; 
20F8:  MOV     992,W0
20FA:  MOV     [W0],[W15++]
20FC:  POP     126
.................... 	 
.................... 	int16 previousPOS = POSCNT; 
.................... 	int16 currentPOS = POSCNT; 
20FE:  PUSH    126
2100:  POP     99C
2102:  PUSH    126
2104:  POP     99E
.................... 	 
.................... 	//While User doesn't push button 
.................... 	while(!pushAck) 
.................... 	{ 
2106:  BTSC.B  966.1
2108:  BRA     215C
.................... 		currentPOS = POSCNT; 
210A:  PUSH    126
210C:  POP     99E
.................... 		*field = currentPOS; 
210E:  MOV     992,W5
2110:  MOV     99E,W4
2112:  MOV     W4,[W5+#0]
.................... 		 
.................... 		if (*field == minimum-1) 
2114:  MOV     992,W0
2116:  MOV     [W0],W5
2118:  MOV     994,W4
211A:  SUB     W4,#1,W0
211C:  CP      W5,W0
211E:  BRA     NZ,2130
.................... 		{ 
.................... 			currentPOS = maximum; 
2120:  PUSH    996
2122:  POP     99E
.................... 			POSCNT = maximum; 
2124:  PUSH    996
2126:  POP     126
.................... 			*field = currentPOS; 
2128:  MOV     992,W5
212A:  MOV     99E,W4
212C:  MOV     W4,[W5+#0]
.................... 		} 
.................... 		else if (*field > maximum) { 
212E:  BRA     2148
2130:  MOV     992,W0
2132:  MOV     [W0],W5
2134:  MOV     996,W4
2136:  CP      W4,W5
2138:  BRA     GE,2148
.................... 			currentPOS = minimum; 
213A:  PUSH    994
213C:  POP     99E
.................... 			POSCNT = minimum; 
213E:  PUSH    994
2140:  POP     126
.................... 			*field = currentPOS; 
2142:  MOV     992,W5
2144:  MOV     99E,W4
2146:  MOV     W4,[W5+#0]
.................... 		} 
.................... 		if (previousPOS != currentPOS) 
2148:  MOV     99C,W0
214A:  CP      99E
214C:  BRA     Z,2156
.................... 		{ 
.................... 			(*displayFunction)(); 
214E:  MOV     998,W2
2150:  MOV     #0,W3
2152:  CALL    2B6
.................... 		} 
.................... 		previousPOS = currentPOS; 
2156:  PUSH    99E
2158:  POP     99C
.................... 	} 
215A:  BRA     2106
.................... 	 
....................     pushAck = false; 
215C:  BCLR.B  966.1
....................      
.................... 	beep(true); 
215E:  MOV.B   #1,W0L
2160:  MOV.B   W0L,9AC
2162:  CALL    1E22
.................... 	delay_ms(BUZZER_ON_TIME); 
2166:  MOV     #32,W0
2168:  CALL    AEC
.................... 	beep(false); 
216C:  CLR.B   9AC
216E:  CALL    1E22
.................... 	 
.................... 	//POP POSCNT CONTEXT 
.................... 	POSCNT = initialPOSCNT; 
2172:  PUSH    99A
2174:  POP     126
.................... } 
2176:  MOV     [--W15],W5
2178:  RETURN  
....................  
.................... //////////////////////////////////////////////////////////////// 
.................... // Fonctions de rafraÃ®chissement du LCD 
.................... //////////////////////////////////////////////////////////////// 
....................  
.................... void displayEditDateAndTime() 
.................... { 
*
1EA8:  MOV     W5,[W15++]
.................... 	clearLCDLines(); 
1EAA:  CALL    B4E
.................... 	sprintf(LCD_Line1,"%02u:%02u:%02u TIMESET",CurrentTime.tm_hour,CurrentTime.tm_min,CurrentTime.tm_sec); 
1EAE:  MOV     #8C0,W4
1EB0:  MOV     W4,97C
1EB2:  MOV     92C,W0
1EB4:  MOV     #8002,W4
1EB6:  CALL    1C80
1EBA:  MOV.B   #3A,W0L
1EBC:  CALL    1C72
1EC0:  MOV     92A,W0
1EC2:  MOV     #8002,W4
1EC4:  CALL    1C80
1EC8:  MOV.B   #3A,W0L
1ECA:  CALL    1C72
1ECE:  MOV     928,W0
1ED0:  MOV     #8002,W4
1ED2:  CALL    1C80
1ED6:  MOV     #E,W1
1ED8:  MOV     W1,W0
1EDA:  CALL    100
1EDE:  INC     W1,W1
1EE0:  MOV     W1,[W15++]
1EE2:  MOV     W0,[W15++]
1EE4:  MOV     [--W15],W0
1EE6:  CALL    1C72
1EEA:  MOV     [--W15],W1
1EEC:  MOV     #15,W0
1EEE:  CPSGT   W1,W0
1EF0:  BRA     1ED8
.................... 	sprintf(LCD_Line2,"%02u %02u %02u",CurrentTime.tm_mday,CurrentTime.tm_mon,CurrentTime.tm_year+1900); 
1EF2:  MOV     #76C,W4
1EF4:  MOV     932,W3
1EF6:  ADD     W3,W4,W5
1EF8:  MOV     #8D0,W4
1EFA:  MOV     W4,97C
1EFC:  MOV     92E,W0
1EFE:  MOV     #8002,W4
1F00:  CALL    1C80
1F04:  MOV.B   #20,W0L
1F06:  CALL    1C72
1F0A:  MOV     930,W0
1F0C:  MOV     #8002,W4
1F0E:  CALL    1C80
1F12:  MOV.B   #20,W0L
1F14:  CALL    1C72
1F18:  MOV     W5,W0
1F1A:  MOV     #8002,W4
1F1C:  CALL    1C80
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
1F20:  MOV.B   #9D,W0L
1F22:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
1F24:  CALL    1D90
.................... } 
1F28:  MOV     [--W15],W5
1F2A:  RETURN  
....................  
.................... void displayEditAlarmOptions() 
.................... { 
.................... 	clearLCDLines(); 
*
1DC4:  CALL    B4E
.................... 	sprintf(LCD_Line1,"%02u:%02u",CurrentTime.tm_hour,CurrentTime.tm_min); 
1DC8:  MOV     #8C0,W4
1DCA:  MOV     W4,97C
1DCC:  MOV     92C,W0
1DCE:  MOV     #8002,W4
1DD0:  CALL    1C80
1DD4:  MOV.B   #3A,W0L
1DD6:  CALL    1C72
1DDA:  MOV     92A,W0
1DDC:  MOV     #8002,W4
1DDE:  CALL    1C80
.................... 	sprintf(LCD_Line2,"%02u:%02u  ACTLMVBP",AlarmTime.tm_hour,AlarmTime.tm_min); 
1DE2:  MOV     #8D0,W4
1DE4:  MOV     W4,97C
1DE6:  MOV     93E,W0
1DE8:  MOV     #8002,W4
1DEA:  CALL    1C80
1DEE:  MOV.B   #3A,W0L
1DF0:  CALL    1C72
1DF4:  MOV     93C,W0
1DF6:  MOV     #8002,W4
1DF8:  CALL    1C80
1DFC:  MOV     #9,W1
1DFE:  MOV     W1,W0
1E00:  CALL    124
1E04:  INC     W1,W1
1E06:  MOV     W1,[W15++]
1E08:  MOV     W0,[W15++]
1E0A:  MOV     [--W15],W0
1E0C:  CALL    1C72
1E10:  MOV     [--W15],W1
1E12:  MOV     #12,W0
1E14:  CPSGT   W1,W0
1E16:  BRA     1DFE
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
1E18:  MOV.B   #9D,W0L
1E1A:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
1E1C:  CALL    1D90
.................... } 
1E20:  RETURN  
....................  
.................... void displayEditAlarmTime() 
.................... { 
.................... 	clearLCDLines(); 
*
1E2A:  CALL    B4E
.................... 	sprintf(LCD_Line1,"ALARME    "); 
1E2E:  MOV     #8C0,W4
1E30:  MOV     W4,97C
1E32:  MOV     #0,W1
1E34:  MOV     W1,W0
1E36:  CALL    144
1E3A:  INC     W1,W1
1E3C:  MOV     W1,[W15++]
1E3E:  MOV     W0,[W15++]
1E40:  MOV     [--W15],W0
1E42:  CALL    1C72
1E46:  MOV     [--W15],W1
1E48:  MOV     #9,W0
1E4A:  CPSGT   W1,W0
1E4C:  BRA     1E34
.................... 	sprintf(LCD_Line2,"%02u:%02u      J S",AlarmTime.tm_hour,AlarmTime.tm_min); 
1E4E:  MOV     #8D0,W4
1E50:  MOV     W4,97C
1E52:  MOV     93E,W0
1E54:  MOV     #8002,W4
1E56:  CALL    1C80
1E5A:  MOV.B   #3A,W0L
1E5C:  CALL    1C72
1E60:  MOV     93C,W0
1E62:  MOV     #8002,W4
1E64:  CALL    1C80
1E68:  MOV     #9,W1
1E6A:  MOV     W1,W0
1E6C:  CALL    15C
1E70:  INC     W1,W1
1E72:  MOV     W1,[W15++]
1E74:  MOV     W0,[W15++]
1E76:  MOV     [--W15],W0
1E78:  CALL    1C72
1E7C:  MOV     [--W15],W1
1E7E:  MOV     #11,W0
1E80:  CPSGT   W1,W0
1E82:  BRA     1E6A
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
1E84:  MOV.B   #9D,W0L
1E86:  MOV.B   W0L,8DF
.................... 	 
.................... 	if (ALARM_ENABLED) 
1E88:  BTSS.B  885.5
1E8A:  BRA     1E96
.................... 	{ 
.................... 		LCD_Line1[8] = 'O'; 
1E8C:  MOV.B   #4F,W0L
1E8E:  MOV.B   W0L,8C8
.................... 		LCD_Line1[9] = 'N'; 
1E90:  MOV.B   #4E,W0L
1E92:  MOV.B   W0L,8C9
.................... 	} 
.................... 	else 
1E94:  BRA     1EA2
.................... 	{ 
.................... 		LCD_Line1[7] = 'O'; 
1E96:  MOV.B   #4F,W0L
1E98:  MOV.B   W0L,8C7
.................... 		LCD_Line1[8] = 'F'; 
1E9A:  MOV.B   #46,W0L
1E9C:  MOV.B   W0L,8C8
.................... 		LCD_Line1[9] = 'F'; 
1E9E:  MOV.B   #46,W0L
1EA0:  MOV.B   W0L,8C9
.................... 	} 
.................... 	 
.................... 	//addSelector(); 
.................... 	refreshLCD();	 
1EA2:  CALL    1D90
.................... } 
1EA6:  RETURN  
....................  
.................... void displayCarillon() 
.................... { 
.................... 	clearLCDLines(); 
*
25A4:  CALL    B4E
.................... 	sprintf(LCD_Line1,"CARILLON"); 
25A8:  MOV     #8C0,W4
25AA:  MOV     W4,97C
25AC:  MOV     #0,W1
25AE:  MOV     W1,W0
25B0:  CALL    17C
25B4:  INC     W1,W1
25B6:  MOV     W1,[W15++]
25B8:  MOV     W0,[W15++]
25BA:  MOV     [--W15],W0
25BC:  CALL    1C72
25C0:  MOV     [--W15],W1
25C2:  MOV     #7,W0
25C4:  CPSGT   W1,W0
25C6:  BRA     25AE
.................... 	if (carillon) 
25C8:  BTSS.B  885.2
25CA:  BRA     25E4
.................... 	{ 
.................... 		sprintf(LCD_Line2," ON"); 
25CC:  MOV     #8D0,W4
25CE:  MOV     W4,97C
25D0:  MOV.B   #20,W0L
25D2:  CALL    1C72
25D6:  MOV.B   #4F,W0L
25D8:  CALL    1C72
25DC:  MOV.B   #4E,W0L
25DE:  CALL    1C72
.................... 	} 
.................... 	else { 
25E2:  BRA     25FA
.................... 		sprintf(LCD_Line2,"OFF"); 
25E4:  MOV     #8D0,W4
25E6:  MOV     W4,97C
25E8:  MOV.B   #4F,W0L
25EA:  CALL    1C72
25EE:  MOV.B   #46,W0L
25F0:  CALL    1C72
25F4:  MOV.B   #46,W0L
25F6:  CALL    1C72
.................... 	} 
....................  
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
25FA:  MOV.B   #9D,W0L
25FC:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
25FE:  CALL    1D90
.................... } 
2602:  RETURN  
....................  
.................... void displayLoadLighting() 
.................... { 
.................... 	clearLCDLines(); 
*
1F84:  CALL    B4E
.................... 	sprintf(LCD_Line1,"LUM    MAX %03u",maxLoadLighting); 
1F88:  MOV     #8C0,W4
1F8A:  MOV     W4,97C
1F8C:  MOV     #0,W1
1F8E:  MOV     W1,W0
1F90:  CALL    192
1F94:  INC     W1,W1
1F96:  MOV     W1,[W15++]
1F98:  MOV     W0,[W15++]
1F9A:  MOV     [--W15],W0
1F9C:  CALL    1C72
1FA0:  MOV     [--W15],W1
1FA2:  MOV     #A,W0
1FA4:  CPSGT   W1,W0
1FA6:  BRA     1F8E
1FA8:  MOV.B   8BF,W0L
1FAA:  SE      W0,W0
1FAC:  MOV     #8003,W4
1FAE:  CALL    1C80
.................... 	sprintf(LCD_Line2,"    DELAIS  %02u",delayLoadLighting); 
1FB2:  MOV     #8D0,W4
1FB4:  MOV     W4,97C
1FB6:  MOV     #0,W1
1FB8:  MOV     W1,W0
1FBA:  CALL    1AE
1FBE:  INC     W1,W1
1FC0:  MOV     W1,[W15++]
1FC2:  MOV     W0,[W15++]
1FC4:  MOV     [--W15],W0
1FC6:  CALL    1C72
1FCA:  MOV     [--W15],W1
1FCC:  MOV     #B,W0
1FCE:  CPSGT   W1,W0
1FD0:  BRA     1FB8
1FD2:  MOV.B   8E0,W0L
1FD4:  SE      W0,W0
1FD6:  MOV     #8002,W4
1FD8:  CALL    1C80
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
1FDC:  MOV.B   #9D,W0L
1FDE:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
1FE0:  CALL    1D90
.................... } 
1FE4:  RETURN  
....................  
.................... void displayAlarmDays() 
.................... { 
*
217A:  MOV     W5,[W15++]
.................... 	//ALARM_DAYS 
.................... 	clearLCDLines(); 
217C:  CALL    B4E
.................... 	sprintf(LCD_Line1,"JOURS  DLMMJVS"); 
2180:  MOV     #8C0,W4
2182:  MOV     W4,97C
2184:  MOV     #0,W1
2186:  MOV     W1,W0
2188:  CALL    1CC
218C:  INC     W1,W1
218E:  MOV     W1,[W15++]
2190:  MOV     W0,[W15++]
2192:  MOV     [--W15],W0
2194:  CALL    1C72
2198:  MOV     [--W15],W1
219A:  MOV     #D,W0
219C:  CPSGT   W1,W0
219E:  BRA     2186
.................... 	int i; 
.................... 	for (i = 0 ; i < 7 ; i++) 
21A0:  CLR     996
21A2:  MOV     996,W4
21A4:  CP      W4,#7
21A6:  BRA     GE,21D4
.................... 	{ 
.................... 		if (ALARM_DAYS[i]) 
21A8:  MOV     #920,W4
21AA:  MOV     996,W3
21AC:  ADD     W3,W4,W0
21AE:  CP0.B   [W0]
21B0:  BRA     Z,21C2
.................... 		{ 
.................... 			LCD_Line2[i+7] = 0x96; 
21B2:  MOV     996,W4
21B4:  ADD     W4,#7,W4
21B6:  MOV     W4,W5
21B8:  MOV     #8D0,W4
21BA:  ADD     W5,W4,W5
21BC:  MOV.B   #96,W0L
21BE:  MOV.B   W0L,[W5]
.................... 		} 
.................... 		else 
21C0:  BRA     21D0
.................... 		{ 
.................... 			LCD_Line2[i+7] = ' '; 
21C2:  MOV     996,W4
21C4:  ADD     W4,#7,W4
21C6:  MOV     W4,W5
21C8:  MOV     #8D0,W4
21CA:  ADD     W5,W4,W5
21CC:  MOV.B   #20,W0L
21CE:  MOV.B   W0L,[W5]
.................... 		} 
.................... 	} 
21D0:  INC     0996
21D2:  BRA     21A2
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
21D4:  MOV.B   #9D,W0L
21D6:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
21D8:  CALL    1D90
.................... } 
21DC:  MOV     [--W15],W5
21DE:  RETURN  
....................  
.................... void displaySnooze() 
.................... { 
.................... 	clearLCDLines(); 
*
1F2C:  CALL    B4E
.................... 	sprintf(LCD_Line1,"SNOOZE"); 
1F30:  MOV     #8C0,W4
1F32:  MOV     W4,97C
1F34:  MOV     #0,W1
1F36:  MOV     W1,W0
1F38:  CALL    1E8
1F3C:  INC     W1,W1
1F3E:  MOV     W1,[W15++]
1F40:  MOV     W0,[W15++]
1F42:  MOV     [--W15],W0
1F44:  CALL    1C72
1F48:  MOV     [--W15],W1
1F4A:  MOV     #5,W0
1F4C:  CPSGT   W1,W0
1F4E:  BRA     1F36
.................... 	sprintf(LCD_Line2,"%02u min",AlarmSnoozeTime); 
1F50:  MOV     #8D0,W4
1F52:  MOV     W4,97C
1F54:  MOV.B   8E1,W0L
1F56:  CLR.B   1
1F58:  MOV     #8002,W4
1F5A:  CALL    1C80
1F5E:  MOV     #4,W1
1F60:  MOV     W1,W0
1F62:  CALL    1FC
1F66:  INC     W1,W1
1F68:  MOV     W1,[W15++]
1F6A:  MOV     W0,[W15++]
1F6C:  MOV     [--W15],W0
1F6E:  CALL    1C72
1F72:  MOV     [--W15],W1
1F74:  MOV     #7,W0
1F76:  CPSGT   W1,W0
1F78:  BRA     1F60
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
1F7A:  MOV.B   #9D,W0L
1F7C:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD();	 
1F7E:  CALL    1D90
.................... } 
1F82:  RETURN  
....................  
.................... void displayRGBLight() 
.................... { 
.................... 	clearLCDLines(); 
*
1FE6:  CALL    B4E
.................... 	sprintf(LCD_Line1,"MOOD     H %03u", hsvColor.hue); 
1FEA:  MOV     #8C0,W4
1FEC:  MOV     W4,97C
1FEE:  MOV     #0,W1
1FF0:  MOV     W1,W0
1FF2:  CALL    212
1FF6:  INC     W1,W1
1FF8:  MOV     W1,[W15++]
1FFA:  MOV     W0,[W15++]
1FFC:  MOV     [--W15],W0
1FFE:  CALL    1C72
2002:  MOV     [--W15],W1
2004:  MOV     #A,W0
2006:  CPSGT   W1,W0
2008:  BRA     1FF0
200A:  MOV     8B8,W0
200C:  MOV     #8003,W4
200E:  CALL    1C80
.................... 	sprintf(LCD_Line2,"   S %03u V %03u",hsvColor.saturation,hsvColor.value); 
2012:  MOV     #8D0,W4
2014:  MOV     W4,97C
2016:  MOV     #0,W1
2018:  MOV     W1,W0
201A:  CALL    22E
201E:  INC     W1,W1
2020:  MOV     W1,[W15++]
2022:  MOV     W0,[W15++]
2024:  MOV     [--W15],W0
2026:  CALL    1C72
202A:  MOV     [--W15],W1
202C:  MOV     #4,W0
202E:  CPSGT   W1,W0
2030:  BRA     2018
2032:  MOV.B   8BA,W0L
2034:  CLR.B   1
2036:  MOV     #8003,W4
2038:  CALL    1C80
203C:  MOV.B   #20,W0L
203E:  CALL    1C72
2042:  MOV.B   #56,W0L
2044:  CALL    1C72
2048:  MOV.B   #20,W0L
204A:  CALL    1C72
204E:  MOV.B   8BB,W0L
2050:  CLR.B   1
2052:  MOV     #8003,W4
2054:  CALL    1C80
.................... 	if (moodEnable) 
2058:  BTSS.B  885.1
205A:  BRA     2066
.................... 	{ 
.................... 		LCD_Line1[6] = 'O'; 
205C:  MOV.B   #4F,W0L
205E:  MOV.B   W0L,8C6
.................... 		LCD_Line1[7] = 'N'; 
2060:  MOV.B   #4E,W0L
2062:  MOV.B   W0L,8C7
.................... 	} 
.................... 	else { 
2064:  BRA     2072
.................... 		LCD_Line1[5] = 'O'; 
2066:  MOV.B   #4F,W0L
2068:  MOV.B   W0L,8C5
.................... 		LCD_Line1[6] = 'F'; 
206A:  MOV.B   #46,W0L
206C:  MOV.B   W0L,8C6
.................... 		LCD_Line1[7] = 'F'; 
206E:  MOV.B   #46,W0L
2070:  MOV.B   W0L,8C7
.................... 	} 
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
2072:  MOV.B   #9D,W0L
2074:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD(); 
2076:  CALL    1D90
.................... 	HSVtoRGB(&hsvColor,&rgbColor); 
207A:  MOV     #8B8,W4
207C:  MOV     W4,9AC
207E:  MOV     #8B4,W4
2080:  MOV     W4,9AE
2082:  CALL    1288
....................     UpdateRGB_Out(&rgbColor); 
2086:  MOV     #8B4,W4
2088:  MOV     W4,9AC
208A:  CALL    1492
.................... 	//refreshRGB(); 
.................... } 
208E:  RETURN  
....................  
.................... void displayVolume() 
.................... { 
.................... 	clearLCDLines(); 
2090:  CALL    B4E
.................... 	sprintf(LCD_Line1,"VOLUME  %03u",chimeVolume); 
2094:  MOV     #8C0,W4
2096:  MOV     W4,97C
2098:  MOV     #0,W1
209A:  MOV     W1,W0
209C:  CALL    24C
20A0:  INC     W1,W1
20A2:  MOV     W1,[W15++]
20A4:  MOV     W0,[W15++]
20A6:  MOV     [--W15],W0
20A8:  CALL    1C72
20AC:  MOV     [--W15],W1
20AE:  MOV     #7,W0
20B0:  CPSGT   W1,W0
20B2:  BRA     209A
20B4:  MOV.B   8B3,W0L
20B6:  SE      W0,W0
20B8:  MOV     #8003,W4
20BA:  CALL    1C80
.................... 	sprintf(LCD_Line2,"TONE      %u",toneSelect); 
20BE:  MOV     #8D0,W4
20C0:  MOV     W4,97C
20C2:  MOV     #0,W1
20C4:  MOV     W1,W0
20C6:  CALL    266
20CA:  INC     W1,W1
20CC:  MOV     W1,[W15++]
20CE:  MOV     W0,[W15++]
20D0:  MOV     [--W15],W0
20D2:  CALL    1C72
20D6:  MOV     [--W15],W1
20D8:  MOV     #9,W0
20DA:  CPSGT   W1,W0
20DC:  BRA     20C4
20DE:  MOV.B   8BE,W0L
20E0:  SE      W0,W0
20E2:  MOV     #0,W4
20E4:  CALL    1C80
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
20E8:  MOV.B   #9D,W0L
20EA:  MOV.B   W0L,8DF
.................... 	//addSelector(); 
.................... 	refreshLCD();	 
20EC:  CALL    1D90
.................... } 
20F0:  RETURN  
....................  
.................... void displayPowerCtrls() 
.................... { 
.................... 	clearLCDLines(); 
*
2BE2:  CALL    B4E
.................... 	sprintf(LCD_Line1,"PHS %04u %05u",LoadStruct.PhaseOffset, TMR4IntrCnt1); 
2BE6:  MOV     #8C0,W4
2BE8:  MOV     W4,97C
2BEA:  MOV     #0,W1
2BEC:  MOV     W1,W0
2BEE:  CALL    280
2BF2:  INC     W1,W1
2BF4:  MOV     W1,[W15++]
2BF6:  MOV     W0,[W15++]
2BF8:  MOV     [--W15],W0
2BFA:  CALL    1C72
2BFE:  MOV     [--W15],W1
2C00:  MOV     #3,W0
2C02:  CPSGT   W1,W0
2C04:  BRA     2BEC
2C06:  MOV     8E2,W0
2C08:  MOV     #8004,W4
2C0A:  CALL    1C80
2C0E:  MOV.B   #20,W0L
2C10:  CALL    1C72
2C14:  MOV     8E8,W0
2C16:  MOV     #8005,W4
2C18:  CALL    1C80
.................... 	sprintf(LCD_Line2,"DLY %04u  %05u",LoadStruct.PulseWidth , TMR4IntrCnt2); 
2C1C:  MOV     #8D0,W4
2C1E:  MOV     W4,97C
2C20:  MOV     #0,W1
2C22:  MOV     W1,W0
2C24:  CALL    29A
2C28:  INC     W1,W1
2C2A:  MOV     W1,[W15++]
2C2C:  MOV     W0,[W15++]
2C2E:  MOV     [--W15],W0
2C30:  CALL    1C72
2C34:  MOV     [--W15],W1
2C36:  MOV     #3,W0
2C38:  CPSGT   W1,W0
2C3A:  BRA     2C22
2C3C:  MOV     8E4,W0
2C3E:  MOV     #8004,W4
2C40:  CALL    1C80
2C44:  MOV.B   #20,W0L
2C46:  CALL    1C72
2C4A:  MOV.B   #20,W0L
2C4C:  CALL    1C72
2C50:  MOV     8EA,W0
2C52:  MOV     #8005,W4
2C54:  CALL    1C80
.................... 	LCD_Line2[15] = 0x9D;	//Return sign 
2C58:  MOV.B   #9D,W0L
2C5A:  MOV.B   W0L,8DF
.................... 	refreshLCD(); 
2C5C:  CALL    1D90
.................... } 
2C60:  RETURN  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #define ENABLE_LCD_REFRESH 1 
....................  
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
*
07C2:  PUSH    42
07C4:  PUSH    36
07C6:  MOV     W0,[W15++]
07C8:  MOV     #2,W0
07CA:  REPEAT  #C
07CC:  MOV     [W0++],[W15++]
.................... 	//while(1){;} 
.................... } 
....................  
07CE:  BCLR.B  85.1
07D0:  MOV     #1A,W0
07D2:  REPEAT  #C
07D4:  MOV     [--W15],[W0--]
07D6:  MOV     [--W15],W0
07D8:  POP     36
07DA:  POP     42
07DC:  RETFIE  
.................... #int_TBE 
.................... void  TBE_isr(void)  
.................... { 
07DE:  BCLR.B  85.2
07E0:  PUSH    42
07E2:  PUSH    36
07E4:  MOV     W0,[W15++]
07E6:  MOV     #2,W0
07E8:  REPEAT  #C
07EA:  MOV     [W0++],[W15++]
.................... 	//while(1){;} 
.................... } 
....................  
07EC:  MOV     #1A,W0
07EE:  REPEAT  #C
07F0:  MOV     [--W15],[W0--]
07F2:  MOV     [--W15],W0
07F4:  POP     36
07F6:  POP     42
07F8:  RETFIE  
.................... #int_ADC1 
.................... void  ADC1_isr(void)  
.................... { 
07FA:  PUSH    42
07FC:  PUSH    36
07FE:  MOV     W0,[W15++]
0800:  MOV     #2,W0
0802:  REPEAT  #C
0804:  MOV     [W0++],[W15++]
.................... 	//while(1){;} 
.................... } 
....................  
0806:  BCLR.B  85.3
0808:  MOV     #1A,W0
080A:  REPEAT  #C
080C:  MOV     [--W15],[W0--]
080E:  MOV     [--W15],W0
0810:  POP     36
0812:  POP     42
0814:  RETFIE  
.................... #int_ADDRERR 
.................... void  ADDRERR_isr(void)  
.................... { 
0816:  PUSH    42
0818:  PUSH    36
081A:  MOV     W0,[W15++]
081C:  MOV     #2,W0
081E:  REPEAT  #C
0820:  MOV     [W0++],[W15++]
....................     ADDRERR = 0; 
0822:  BCLR.B  80.3
.................... } 
....................  
0824:  BCLR.B  80.3
0826:  MOV     #1A,W0
0828:  REPEAT  #C
082A:  MOV     [--W15],[W0--]
082C:  MOV     [--W15],W0
082E:  POP     36
0830:  POP     42
0832:  RETFIE  
.................... #int_default 
.................... void default_isr() 
.................... { 
0834:  PUSH    42
0836:  PUSH    36
0838:  MOV     W0,[W15++]
083A:  MOV     #2,W0
083C:  REPEAT  #C
083E:  MOV     [W0++],[W15++]
.................... #asm 
....................     NOP 
0840:  NOP     
.................... #endasm 
.................... } 
....................  
....................  
0842:  MOV     #1A,W0
0844:  REPEAT  #C
0846:  MOV     [--W15],[W0--]
0848:  MOV     [--W15],W0
084A:  POP     36
084C:  POP     42
084E:  RETFIE  
.................... void main() 
.................... {	 
*
2E96:  MOV     #4444,W0
2E98:  MOV     W0,94
2E9A:  MOV     #4444,W0
2E9C:  MOV     W0,96
2E9E:  MOV     #4444,W0
2EA0:  MOV     W0,98
2EA2:  MOV     #7444,W0
2EA4:  MOV     W0,9A
2EA6:  MOV     #4474,W0
2EA8:  MOV     W0,9E
2EAA:  BSET.B  81.7
2EAC:  MOV     #8000,W4
2EAE:  MOV     W4,216
2EB0:  MOV     #400,W4
2EB2:  MOV     W4,218
2EB4:  MOV     #F,W4
2EB6:  MOV     W4,21E
2EB8:  SETM    85A
2EBA:  CLR     85C
2EBC:  BCLR.B  885.0
2EBE:  BCLR.B  885.1
2EC0:  CLR.B   88F
2EC2:  CLR.B   8A5
2EC4:  CLR.B   8AB
2EC6:  CLR.B   8AF
2EC8:  BCLR.B  885.2
2ECA:  MOV.B   #64,W0L
2ECC:  MOV.B   W0L,8B3
2ECE:  MOV.B   #1,W0L
2ED0:  MOV.B   W0L,8BE
2ED2:  BCLR.B  885.3
2ED4:  BSET.B  885.4
2ED6:  MOV.B   #64,W0L
2ED8:  MOV.B   W0L,8BF
2EDA:  MOV.B   #1E,W0L
2EDC:  MOV.B   W0L,8E0
2EDE:  CLR     8E8
2EE0:  CLR     8EA
2EE2:  MOV.B   #7,W0L
2EE4:  MOV.B   W0L,8E1
2EE6:  BCLR.B  885.5
2EE8:  BSET.B  885.6
2EEA:  CLR     95E
2EEC:  CLR     960
2EEE:  CLR     962
2EF0:  CLR.B   927
2EF2:  BCLR.B  885.7
2EF4:  CLR     964
2EF6:  BCLR.B  966.0
2EF8:  BCLR.B  966.1
2EFA:  BCLR.B  966.2
2EFC:  BCLR.B  966.3
2EFE:  CLR     96C
2F00:  CLR     96E
2F02:  BCLR.B  966.4
2F04:  BCLR.B  966.5
2F06:  BCLR.B  966.6
2F08:  BCLR.B  966.7
2F0A:  CLR     97A
2F0C:  SETM    2A8
2F0E:  MOV     #B80,W15
2F10:  MOV     #BFF,W0
2F12:  MOV     W0,20
2F14:  NOP     
....................      
....................      
....................      
....................     setup_wdt(WDT_OFF); 
*
2FE4:  BCLR.B  740.5
....................   	 
....................     enable_interrupts(INT_RDA); 
2FE6:  BSET.B  8D.1
....................    	enable_interrupts(INT_TBE); 
2FE8:  BSET.B  8D.2
....................    	enable_interrupts(INT_ADC1); 
2FEA:  BSET.B  8D.3
....................    	enable_interrupts(INT_CNI); 
2FEC:  BSET.B  8D.7
....................    	 
....................    	InitLoadControl(); 
2FEE:  CALL    850
.................... 	InitRTCC(); 
2FF2:  CALL    A28
....................  	initUserInput(); 
2FF6:  CALL    ACC
....................  	initLumMonitor(); 
2FFA:  CALL    ADC
....................  	initLCD(); 
2FFE:  CALL    B74
.................... 	initChime(); 
3002:  CALL    C22
.................... 	initRGBLighting(); 
3006:  CALL    150C
....................      
....................     setChime(true); 
300A:  MOV.B   #1,W0L
300C:  MOV.B   W0L,98E
300E:  CALL    153C
....................     delay_ms(50); 
3012:  MOV     #32,W0
3014:  CALL    AEC
....................     setChime(false); 
3018:  CLR.B   98E
301A:  CALL    153C
....................  
....................  	while(true) 
....................     { 
....................         AlarmStateMachine(); 
301E:  CALL    18BC
....................         TransmitDataStreaming(); 
3022:  CALL    1BD8
.................... 	    //setChime(true);  
.................... 	     
....................  		encoderMonitoring(); 
3026:  CALL    1BEA
....................  		readLumMonitor(); 
302A:  CALL    1C00
.................... 		PDC1 = POSCNT*32; 
302E:  MOV     126,W0
3030:  SL      W0,#5,W0
3032:  MOV     W0,1D6
....................          
.................... 		currentPOSCNT = POSCNT; 
3034:  PUSH    126
3036:  POP     85C
....................  
.................... #ifdef ENABLE_LCD_REFRESH 
.................... 		clearLCDLines(); 
3038:  CALL    B4E
.................... 		sprintf(LCD_Line1,"%02u:%02u:%02u",CurrentTime.tm_hour,CurrentTime.tm_min,CurrentTime.tm_sec); 
303C:  MOV     #8C0,W4
303E:  MOV     W4,97C
3040:  MOV     92C,W0
3042:  MOV     #8002,W4
3044:  CALL    1C80
3048:  MOV.B   #3A,W0L
304A:  CALL    1C72
304E:  MOV     92A,W0
3050:  MOV     #8002,W4
3052:  CALL    1C80
3056:  MOV.B   #3A,W0L
3058:  CALL    1C72
305C:  MOV     928,W0
305E:  MOV     #8002,W4
3060:  CALL    1C80
.................... 		addSelector(); 
3064:  CALL    1D3C
.................... 		refreshLCD(); 
3068:  CALL    1D90
.................... #endif 
....................          
....................         if (pushAck                              &&  
....................              (alarmData.AlarmState != ALARM_WAKE) && 
....................              (enableLCD)) { 
306C:  BTSS.B  966.1
306E:  BRA     3086
3070:  MOV     876,W4
3072:  CP.B    W4L,#3
3074:  BRA     Z,3086
3076:  BTSS.B  885.4
3078:  BRA     3086
....................              pushAck = false; 
307A:  BCLR.B  966.1
....................              alarmData.PulseWidthErr++; 
307C:  INC     086E
307E:  BTSC.B  42.1
3080:  INC     0870
....................              EditMenu();     
3082:  CALL    2D42
....................         } 
.................... 		 
.................... 		//} 
....................  		previousPOSCNT = currentPOSCNT; 
3086:  PUSH    85C
3088:  POP     85A
....................  		//delay_ms(500); 
....................         
.................... //       float intensity = 0.0; 
.................... //        
.................... //       while (1) { 
.................... //            
.................... //        
.................... //       for (intensity = 0.0 ; intensity < 0.99 ; intensity += 0.01) { 
.................... //           SetLampIntensity(intensity); 
.................... //           delay_ms(50); 
.................... //       } 
.................... //        
.................... //       for (intensity = 0.99 ; intensity > 0.01 ; intensity -= 0.01) { 
.................... //           SetLampIntensity(intensity); 
.................... //           delay_ms(50); 
.................... //       } 
.................... //       } 
....................          
....................         IncreaseHue(&hsvColor); 
308A:  MOV     #8B8,W4
308C:  MOV     W4,97E
308E:  CALL    2E72
....................         HSVtoRGB(&hsvColor, &rgbColor); 
3092:  MOV     #8B8,W4
3094:  MOV     W4,9AC
3096:  MOV     #8B4,W4
3098:  MOV     W4,9AE
309A:  CALL    1288
....................         delay_ms(10); 
309E:  MOV     #A,W0
30A0:  CALL    AEC
....................          
....................         //UpdateRGB_Out(&rgbColor); 
....................         
....................         //alarmData.DayOfTheWeek = CurrentTime.tm_wday; 
....................         
....................         alarmData.MainLoops++; 
30A4:  INC     086A
30A6:  BTSC.B  42.1
30A8:  INC     086C
....................  	} 
30AA:  BRA     301E
.................... } 
....................  
30AC:  BRA     30AC

Configuration Fuses:
   Word  1L: C703   NOCKSFSM FRC_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 8730   NOPUT NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: 4003   DEBUG NOCOE ICSP1
          H: 0000  
