
---  C:\Program Files\PICC\devices\30F3011.h  ----------------------------------------------------
1:                 //////// Standard Header file for the DSPIC30F3011 device ////////////////
2:                 #device DSPIC30F3011
  0100  EF2032     clr.w 0x0032
  0102  2010C3     mov.w #0x10c,0x0006
  0104  418000     add.w 0x0006,0x0000,0x0000
  0106  BA4010     tblrdl.b [0x0000],0x0000
  0108  EF6001     clr.b 0x0001
  010A  060000     return
  010C  003025     nop
  010E  007532     nop
  0110  00253A     nop
  0112  003230     nop
  0114  003A75     nop
  0116  003025     nop
  0118  007532     nop
  011A  005420     nop
  011C  004D49     nop
  011E  005345     nop
  0120  005445     nop
  0122  000000     nop
  0124  EF2032     clr.w 0x0032
  0126  201303     mov.w #0x130,0x0006
  0128  418000     add.w 0x0006,0x0000,0x0000
  012A  BA4010     tblrdl.b [0x0000],0x0000
  012C  EF6001     clr.b 0x0001
  012E  060000     return
  0130  003025     nop
  0132  007532     nop
  0134  00253A     nop
  0136  003230     nop
  0138  002075     nop
  013A  004120     nop
  013C  005443     nop
  013E  004D4C     nop
  0140  004256     nop
  0142  000050     nop
  0144  EF2032     clr.w 0x0032
  0146  201503     mov.w #0x150,0x0006
  0148  418000     add.w 0x0006,0x0000,0x0000
  014A  BA4010     tblrdl.b [0x0000],0x0000
  014C  EF6001     clr.b 0x0001
  014E  060000     return
  0150  004C41     nop
  0152  005241     nop
  0154  00454D     nop
  0156  002020     nop
  0158  002020     nop
  015A  000000     nop
  015C  EF2032     clr.w 0x0032
  015E  201683     mov.w #0x168,0x0006
  0160  418000     add.w 0x0006,0x0000,0x0000
  0162  BA4010     tblrdl.b [0x0000],0x0000
  0164  EF6001     clr.b 0x0001
  0166  060000     return
  0168  003025     nop
  016A  007532     nop
  016C  00253A     nop
  016E  003230     nop
  0170  002075     nop
  0172  002020     nop
  0174  002020     nop
  0176  004A20     nop
  0178  005320     nop
  017A  000000     nop
  017C  EF2032     clr.w 0x0032
  017E  201883     mov.w #0x188,0x0006
  0180  418000     add.w 0x0006,0x0000,0x0000
  0182  BA4010     tblrdl.b [0x0000],0x0000
  0184  EF6001     clr.b 0x0001
  0186  060000     return
  0188  004143     nop
  018A  004952     nop
  018C  004C4C     nop
  018E  004E4F     nop
  0190  000000     nop
  0192  EF2032     clr.w 0x0032
  0194  2019E3     mov.w #0x19e,0x0006
  0196  418000     add.w 0x0006,0x0000,0x0000
  0198  BA4010     tblrdl.b [0x0000],0x0000
  019A  EF6001     clr.b 0x0001
  019C  060000     return
  019E  00554C     nop
  01A0  00204D     nop
  01A2  002020     nop
  01A4  004D20     nop
  01A6  005841     nop
  01A8  002520     nop
  01AA  003330     nop
  01AC  000075     nop
  01AE  EF2032     clr.w 0x0032
  01B0  201BA3     mov.w #0x1ba,0x0006
  01B2  418000     add.w 0x0006,0x0000,0x0000
  01B4  BA4010     tblrdl.b [0x0000],0x0000
  01B6  EF6001     clr.b 0x0001
  01B8  060000     return
  01BA  002020     nop
  01BC  002020     nop
  01BE  004544     nop
  01C0  00414C     nop
  01C2  005349     nop
  01C4  002020     nop
  01C6  003025     nop
  01C8  007532     nop
  01CA  000000     nop
  01CC  EF2032     clr.w 0x0032
  01CE  201D83     mov.w #0x1d8,0x0006
  01D0  418000     add.w 0x0006,0x0000,0x0000
  01D2  BA4010     tblrdl.b [0x0000],0x0000
  01D4  EF6001     clr.b 0x0001
  01D6  060000     return
  01D8  004F4A     nop
  01DA  005255     nop
  01DC  002053     nop
  01DE  004420     nop
  01E0  004D4C     nop
  01E2  004A4D     nop
  01E4  005356     nop
  01E6  000000     nop
  01E8  EF2032     clr.w 0x0032
  01EA  201F43     mov.w #0x1f4,0x0006
  01EC  418000     add.w 0x0006,0x0000,0x0000
  01EE  BA4010     tblrdl.b [0x0000],0x0000
  01F0  EF6001     clr.b 0x0001
  01F2  060000     return
  01F4  004E53     nop
  01F6  004F4F     nop
  01F8  00455A     nop
  01FA  000000     nop
  01FC  EF2032     clr.w 0x0032
  01FE  202083     mov.w #0x208,0x0006
  0200  418000     add.w 0x0006,0x0000,0x0000
  0202  BA4010     tblrdl.b [0x0000],0x0000
  0204  EF6001     clr.b 0x0001
  0206  060000     return
  0208  003025     nop
  020A  007532     nop
  020C  006D20     nop
  020E  006E69     nop
  0210  000000     nop
  0212  EF2032     clr.w 0x0032
  0214  2021E3     mov.w #0x21e,0x0006
  0216  418000     add.w 0x0006,0x0000,0x0000
  0218  BA4010     tblrdl.b [0x0000],0x0000
  021A  EF6001     clr.b 0x0001
  021C  060000     return
  021E  004F4D     nop
  0220  00444F     nop
  0222  002020     nop
  0224  002020     nop
  0226  004820     nop
  0228  002520     nop
  022A  003330     nop
  022C  000075     nop
  022E  EF2032     clr.w 0x0032
  0230  2023A3     mov.w #0x23a,0x0006
  0232  418000     add.w 0x0006,0x0000,0x0000
  0234  BA4010     tblrdl.b [0x0000],0x0000
  0236  EF6001     clr.b 0x0001
  0238  060000     return
  023A  002020     nop
  023C  005320     nop
  023E  002520     nop
  0240  003330     nop
  0242  002075     nop
  0244  002056     nop
  0246  003025     nop
  0248  007533     nop
  024A  000000     nop
  024C  EF2032     clr.w 0x0032
  024E  202583     mov.w #0x258,0x0006
  0250  418000     add.w 0x0006,0x0000,0x0000
  0252  BA4010     tblrdl.b [0x0000],0x0000
  0254  EF6001     clr.b 0x0001
  0256  060000     return
  0258  004F56     nop
  025A  00554C     nop
  025C  00454D     nop
  025E  002020     nop
  0260  003025     nop
  0262  007533     nop
  0264  000000     nop
  0266  EF2032     clr.w 0x0032
  0268  202723     mov.w #0x272,0x0006
  026A  418000     add.w 0x0006,0x0000,0x0000
  026C  BA4010     tblrdl.b [0x0000],0x0000
  026E  EF6001     clr.b 0x0001
  0270  060000     return
  0272  004F54     nop
  0274  00454E     nop
  0276  002020     nop
  0278  002020     nop
  027A  002020     nop
  027C  007525     nop
  027E  000000     nop
  0280  EF2032     clr.w 0x0032
  0282  2028C3     mov.w #0x28c,0x0006
  0284  418000     add.w 0x0006,0x0000,0x0000
  0286  BA4010     tblrdl.b [0x0000],0x0000
  0288  EF6001     clr.b 0x0001
  028A  060000     return
  028C  004850     nop
  028E  002053     nop
  0290  003025     nop
  0292  007534     nop
  0294  002520     nop
  0296  003530     nop
  0298  000075     nop
  029A  EF2032     clr.w 0x0032
  029C  202A63     mov.w #0x2a6,0x0006
  029E  418000     add.w 0x0006,0x0000,0x0000
  02A0  BA4010     tblrdl.b [0x0000],0x0000
  02A2  EF6001     clr.b 0x0001
  02A4  060000     return
  02A6  004C44     nop
  02A8  002059     nop
  02AA  003025     nop
  02AC  007534     nop
  02AE  002020     nop
  02B0  003025     nop
  02B2  007535     nop
  02B4  000000     nop
  02B6  014002     goto 0x0004
  045E  600167     and.w 0x0000,#7,0x0004
  0460  DE0043     lsr 0x0000,#3,0x0000
  0462  400001     add.w 0x0000,0x0002,0x0000
  0464  784010     mov.b [0x0000],0x0000
  0466  A51000     btst.c 0x0000,0x0004
  0468  EB0000     clr.w 0x0000
  046A  AF0042     btsc.b 0x0042,#0
  046C  E80000     inc.w 0x0000,0x0000
  046E  060000     return
                                                //@DIV3232A
  04B6  781F85     mov.w 0x000a,[0x001e++]      //PUSH W5
  04B8  2000C5     mov.w #0xc,0x000a            //MOV  12, W5
  04BA  090003     repeat #3                    //PUSH W6, W7, W8, W9
  04BC  781FB5     mov.w [0x000a++],[0x001e++]
  04BE  200009     mov.w #0x0,0x0012            //If   SR_DC == 0
  04C0  AF0043     btsc.b 0x0043,#0             //     MOV  0, W9
  04C2  200019     mov.w #0x1,0x0012            //Else MOV  1, W9
  04C4  781F89     mov.w 0x0012,[0x001e++]      
  04C6  EB0200     clr.w 0x0008                 //Clear W4  (Quotient? LSW)
  04C8  EB0280     clr.w 0x000a                 //Clear W5  (Quotient? MSW)
  04CA  EB0300     clr.w 0x000c                 //Clear W6  (Ruotient? LSW)
  04CC  EB0380     clr.w 0x000e                 //Clear W7  (Reminder? MSW)
  04CE  690403     xor.w 0x0004,0x0006,0x0010   //W2 XOR W3 -> W5
  04D0  320011     bra z, 0x0004f4              //????
  04D2  200208     mov.w #0x20,0x0010           //32 -> W8  (Shift count)
  04D4  A90042     bclr.b 0x0042,#0             //Clear Carry
  04D6  D28000     rlc.w 0x0000,0x0000          //Shift W0 Left with Carry Numerator   LSW
  04D8  D28081     rlc.w 0x0002,0x0002          //Shift W1 Left with Carry Numerator   MSW
  04DA  D28204     rlc.w 0x0008,0x0008          //Shift W2 Left with Carry Denominator LSW
  04DC  D28285     rlc.w 0x000a,0x000a          //Shift W3 Left with Carry Denominator MSW
  04DE  E12803     cp.w 0x000a,0x0006
  04E0  3A0001     bra nz, 0x0004e4             //if (W5 != W3)           (Denominator MSW != Quotient MSW) Goto 04E4
  04E2  E1A002     cpb.w 0x0008,0x0004
  04E4  390003     bra nc, 0x0004ec             //if ((W5) – (W3) – (!C)) (Denominator MSW == Quotient MSW) Goto 04E4
  04E6  520202     sub.w 0x0008,0x0004,0x0008
  04E8  5A8283     subb.w 0x000a,0x0006,0x000a
  04EA  A80042     bset.b 0x0042,#0
  04EC  D28306     rlc.w 0x000c,0x000c
  04EE  D28387     rlc.w 0x000e,0x000e
  04F0  E90408     dec.w 0x0010,0x0010
  04F2  3AFFF0     bra nz, 0x0004d4
  04F4  780087     mov.w 0x000e,0x0002
  04F6  780006     mov.w 0x000c,0x0000
  04F8  7804CF     mov.w [--0x001e],0x0012
  04FA  E00009     cp0.w 0x0012
  04FC  320001     bra z, 0x000500
  04FE  BE0004     mov.d 0x0008,0x0000
  0500  200125     mov.w #0x12,0x000a
  0502  090003     repeat #3
  0504  7812CF     mov.w [--0x001e],[0x000a--]
  0506  7802CF     mov.w [--0x001e],0x000a
  0508  060000     return

  050A  781F85     mov.w 0x000a,[0x001e++]
  050C  2000C5     mov.w #0xc,0x000a
  050E  090003     repeat #3
  0510  781FB5     mov.w [0x000a++],[0x001e++]
  0512  B80202     mul.uu 0x0000,0x0004,0x0008
  0514  B80303     mul.uu 0x0000,0x0006,0x000c
  0516  A90042     bclr.b 0x0042,#0
  0518  430285     add.w 0x000c,0x000a,0x000a
  051A  4B8460     addc.w 0x000e,#0,0x0010
  051C  B80B02     mul.uu 0x0002,0x0004,0x000c
  051E  4B0285     addc.w 0x000c,0x000a,0x000a
  0520  4B8408     addc.w 0x000e,0x0010,0x0010
  0522  B80B03     mul.uu 0x0002,0x0006,0x000c
  0524  430408     add.w 0x000c,0x0010,0x0010
  0526  B08007     addc.w #0x0,0x000e
  0528  780187     mov.w 0x000e,0x0006
  052A  780108     mov.w 0x0010,0x0004
  052C  780085     mov.w 0x000a,0x0002
  052E  780004     mov.w 0x0008,0x0000
  0530  200125     mov.w #0x12,0x000a
  0532  090003     repeat #3
  0534  7812CF     mov.w [--0x001e],[0x000a--]
  0536  7802CF     mov.w [--0x001e],0x000a
  0538  060000     return

  08DC  781F85     mov.w 0x000a,[0x001e++]
  08DE  2000C5     mov.w #0xc,0x000a
  08E0  090003     repeat #3
  08E2  781FB5     mov.w [0x000a++],[0x001e++]
  08E4  B80202     mul.uu 0x0000,0x0004,0x0008
  08E6  A6F003     btss 0x0006,#15
  08E8  370002     bra 0x0008ee
  08EA  B98303     mul.ss 0x0000,0x0006,0x000c
  08EC  370001     bra 0x0008f0
  08EE  B80303     mul.uu 0x0000,0x0006,0x000c
  08F0  A90042     bclr.b 0x0042,#0
  08F2  430285     add.w 0x000c,0x000a,0x000a
  08F4  4B8460     addc.w 0x000e,#0,0x0010
  08F6  A6F001     btss 0x0002,#15
  08F8  370002     bra 0x0008fe
  08FA  B98B02     mul.ss 0x0002,0x0004,0x000c
  08FC  370001     bra 0x000900
  08FE  B80B02     mul.uu 0x0002,0x0004,0x000c
  0900  4B0285     addc.w 0x000c,0x000a,0x000a
  0902  4B8408     addc.w 0x000e,0x0010,0x0010
  0904  B08009     addc.w #0x0,0x0012
  0906  B98B03     mul.ss 0x0002,0x0006,0x000c
  0908  4B0408     addc.w 0x000c,0x0010,0x0010
  090A  4C8387     addc.w 0x0012,0x000e,0x000e
  090C  780187     mov.w 0x000e,0x0006
  090E  780108     mov.w 0x0010,0x0004
  0910  780085     mov.w 0x000a,0x0002
  0912  780004     mov.w 0x0008,0x0000
  0914  200125     mov.w #0x12,0x000a
  0916  090003     repeat #3
  0918  7812CF     mov.w [--0x001e],[0x000a--]
  091A  7802CF     mov.w [--0x001e],0x000a
  091C  060000     return
  0C3E  781F85     mov.w 0x000a,[0x001e++]
  0C40  781F86     mov.w 0x000c,[0x001e++]
  0C42  2008E1     mov.w #0x8e,0x0002
  0C44  E00000     cp0.w 0x0000
  0C46  320012     bra z, 0x000c6c
  0C48  A7F000     btsc 0x0000,#15
  0C4A  370004     bra 0x000c54
  0C4C  A90042     bclr.b 0x0042,#0
  0C4E  D28000     rlc.w 0x0000,0x0000
  0C50  E90081     dec.w 0x0002,0x0002
  0C52  37FFFA     bra 0x000c48
  0C54  FD8001     swap.w 0x0002
  0C56  A90042     bclr.b 0x0042,#0
  0C58  D38081     rrc.w 0x0002,0x0002
  0C5A  A1F000     bclr 0x0000,#15
  0C5C  FD8000     swap.w 0x0000
  0C5E  684081     xor.b 0x0000,0x0002,0x0002
  0C60  B24000     and.b #0x0,0x0000
  0C62  370007     bra 0x000c72
  0C64  784001     mov.b 0x0002,0x0000
  0C66  A07001     bset 0x0002,#7
  0C68  B24001     and.b #0x0,0x0002
  0C6A  370003     bra 0x000c72
  0C6C  EB0000     clr.w 0x0000
  0C6E  EB0080     clr.w 0x0002
  0C70  370000     bra 0x000c72
  0C72  78034F     mov.w [--0x001e],0x000c
  0C74  7802CF     mov.w [--0x001e],0x000a
  0C76  060000     return
  0C78  781F85     mov.w 0x000a,[0x001e++]
  0C7A  2000C5     mov.w #0xc,0x000a
  0C7C  090004     repeat #4
  0C7E  781FB5     mov.w [0x000a++],[0x001e++]
  0C80  EB0480     clr.w 0x0012
  0C82  688483     xor.w 0x0002,0x0006,0x0012
  0C84  780301     mov.w 0x0002,0x000c
  0C86  780280     mov.w 0x0000,0x000a
  0C88  780403     mov.w 0x0006,0x0010
  0C8A  780382     mov.w 0x0004,0x000e
  0C8C  D28081     rlc.w 0x0002,0x0002
  0C8E  FD8001     swap.w 0x0002
  0C90  FB8081     ze 0x0002,0x0002
  0C92  E00001     cp0.w 0x0002
  0C94  32004E     bra z, 0x000d32
  0C96  D28183     rlc.w 0x0006,0x0006
  0C98  FD8003     swap.w 0x0006
  0C9A  FB8183     ze 0x0006,0x0006
  0C9C  E00003     cp0.w 0x0006
  0C9E  320049     bra z, 0x000d32
  0CA0  EB0000     clr.w 0x0000
  0CA2  50C003     sub.b 0x0002,0x0006,0x0000
  0CA4  390003     bra nc, 0x000cac
  0CA6  B047F0     add.b #0x7f,0x0000
  0CA8  310044     bra c, 0x000d32
  0CAA  370003     bra 0x000cb2
  0CAC  B14810     sub.b 0x0000,#0x81
  0CAE  390041     bra nc, 0x000d32
  0CB0  320040     bra z, 0x000d32
  0CB2  780085     mov.w 0x000a,0x0002
  0CB4  780106     mov.w 0x000c,0x0004
  0CB6  A07002     bset 0x0004,#7
  0CB8  B20FF2     and.w #0xff,0x0004
  0CBA  B20FF8     and.w #0xff,0x0010
  0CBC  A07008     bset 0x0010,#7
  0CBE  20019A     mov.w #0x19,0x0014
  0CC0  EB0180     clr.w 0x0006
  0CC2  EB0200     clr.w 0x0008
  0CC4  508087     sub.w 0x0002,0x000e,0x0002
  0CC6  590108     subb.w 0x0004,0x0010,0x0004
  0CC8  330002     bra n, 0x000cce
  0CCA  310004     bra c, 0x000cd4
  0CCC  3A0004     bra nz, 0x000cd6
  0CCE  408087     add.w 0x0002,0x000e,0x0002
  0CD0  490108     addc.w 0x0004,0x0010,0x0004
  0CD2  370001     bra 0x000cd6
  0CD4  A00004     bset 0x0008,#0
  0CD6  E9050A     dec.w 0x0014,0x0014
  0CD8  320007     bra z, 0x000ce8
  0CDA  A90042     bclr.b 0x0042,#0
  0CDC  D28081     rlc.w 0x0002,0x0002
  0CDE  D28102     rlc.w 0x0004,0x0004
  0CE0  A90042     bclr.b 0x0042,#0
  0CE2  D28204     rlc.w 0x0008,0x0008
  0CE4  D28183     rlc.w 0x0006,0x0006
  0CE6  37FFEE     bra 0x000cc4
  0CE8  EB0500     clr.w 0x0014
  0CEA  A78003     btsc 0x0006,#8
  0CEC  370001     bra 0x000cf0
  0CEE  370006     bra 0x000cfc
  0CF0  A90042     bclr.b 0x0042,#0
  0CF2  D38183     rrc.w 0x0006,0x0006
  0CF4  A17003     bclr 0x0006,#7
  0CF6  D38204     rrc.w 0x0008,0x0008
  0CF8  D2850A     rlc.w 0x0014,0x0014
  0CFA  370002     bra 0x000d00
  0CFC  E90000     dec.w 0x0000,0x0000
  0CFE  320019     bra z, 0x000d32
  0D00  A7F00A     btsc 0x0014,#15
  0D02  390005     bra nc, 0x000d0e
  0D04  D28081     rlc.w 0x0002,0x0002
  0D06  D28102     rlc.w 0x0004,0x0004
  0D08  508087     sub.w 0x0002,0x000e,0x0002
  0D0A  590108     subb.w 0x0004,0x0010,0x0004
  0D0C  390009     bra nc, 0x000d20
  0D0E  E80204     inc.w 0x0008,0x0008
  0D10  3A0007     bra nz, 0x000d20
  0D12  E80183     inc.w 0x0006,0x0006
  0D14  3A0005     bra nz, 0x000d20
  0D16  E80000     inc.w 0x0000,0x0000
  0D18  32000C     bra z, 0x000d32
  0D1A  370002     bra 0x000d20
  0D1C  E90000     dec.w 0x0000,0x0000
  0D1E  320009     bra z, 0x000d32
  0D20  FD8000     swap.w 0x0000
  0D22  D38080     rrc.w 0x0000,0x0002
  0D24  A0F001     bset 0x0002,#15
  0D26  A6F009     btss 0x0012,#15
  0D28  A1F001     bclr 0x0002,#15
  0D2A  A17003     bclr 0x0006,#7
  0D2C  69C081     xor.b 0x0006,0x0002,0x0002
  0D2E  780004     mov.w 0x0008,0x0000
  0D30  370003     bra 0x000d38
  0D32  200000     mov.w #0x0,0x0000
  0D34  200001     mov.w #0x0,0x0002
  0D36  370000     bra 0x000d38
  0D38  200145     mov.w #0x14,0x000a
  0D3A  090004     repeat #4
  0D3C  7812CF     mov.w [--0x001e],[0x000a--]
  0D3E  7802CF     mov.w [--0x001e],0x000a
  0D40  060000     return
  0D42  781F85     mov.w 0x000a,[0x001e++]
  0D44  781F86     mov.w 0x000c,[0x001e++]
  0D46  2008E1     mov.w #0x8e,0x0002
  0D48  A10006     bclr 0x000c,#0
  0D4A  A6F000     btss 0x0000,#15
  0D4C  370003     bra 0x000d54
  0D4E  A00006     bset 0x000c,#0
  0D50  EA0000     neg.w 0x0000,0x0000
  0D52  370000     bra 0x000d54
  0D54  E00000     cp0.w 0x0000
  0D56  320014     bra z, 0x000d80
  0D58  A7F000     btsc 0x0000,#15
  0D5A  370004     bra 0x000d64
  0D5C  A90042     bclr.b 0x0042,#0
  0D5E  D28000     rlc.w 0x0000,0x0000
  0D60  E90081     dec.w 0x0002,0x0002
  0D62  37FFFA     bra 0x000d58
  0D64  FD8001     swap.w 0x0002
  0D66  A90042     bclr.b 0x0042,#0
  0D68  D38081     rrc.w 0x0002,0x0002
  0D6A  A1F000     bclr 0x0000,#15
  0D6C  FD8000     swap.w 0x0000
  0D6E  684081     xor.b 0x0000,0x0002,0x0002
  0D70  B24000     and.b #0x0,0x0000
  0D72  A70006     btsc 0x000c,#0
  0D74  A0F001     bset 0x0002,#15
  0D76  370007     bra 0x000d86
  0D78  784001     mov.b 0x0002,0x0000
  0D7A  A07001     bset 0x0002,#7
  0D7C  B24001     and.b #0x0,0x0002
  0D7E  370003     bra 0x000d86
  0D80  EB0000     clr.w 0x0000
  0D82  EB0080     clr.w 0x0002
  0D84  370000     bra 0x000d86
  0D86  78034F     mov.w [--0x001e],0x000c
  0D88  7802CF     mov.w [--0x001e],0x000a
  0D8A  060000     return
  0D8C  781F85     mov.w 0x000a,[0x001e++]
  0D8E  781F86     mov.w 0x000c,[0x001e++]
  0D90  781F87     mov.w 0x000e,[0x001e++]
  0D92  688203     xor.w 0x0002,0x0006,0x0008
  0D94  A6F004     btss 0x0008,#15
  0D96  370006     bra 0x000da4
  0D98  A90042     bclr.b 0x0042,#0
  0D9A  A92042     bclr.b 0x0042,#1
  0D9C  A6F001     btss 0x0002,#15
  0D9E  370026     bra 0x000dec
  0DA0  A80042     bset.b 0x0042,#0
  0DA2  370024     bra 0x000dec
  0DA4  780201     mov.w 0x0002,0x0008
  0DA6  780280     mov.w 0x0000,0x000a
  0DA8  780303     mov.w 0x0006,0x000c
  0DAA  780382     mov.w 0x0004,0x000e
  0DAC  D28081     rlc.w 0x0002,0x0002
  0DAE  FD8001     swap.w 0x0002
  0DB0  D28183     rlc.w 0x0006,0x0006
  0DB2  FD8003     swap.w 0x0006
  0DB4  51C081     sub.b 0x0006,0x0002,0x0002
  0DB6  320005     bra z, 0x000dc2
  0DB8  A6F004     btss 0x0008,#15
  0DBA  370018     bra 0x000dec
  0DBC  200010     mov.w #0x1,0x0000
  0DBE  B6E042     xor.b 0x0042
  0DC0  370015     bra 0x000dec
  0DC2  784084     mov.b 0x0008,0x0002
  0DC4  784186     mov.b 0x000c,0x0006
  0DC6  A17001     bclr 0x0002,#7
  0DC8  A17003     bclr 0x0006,#7
  0DCA  51C081     sub.b 0x0006,0x0002,0x0002
  0DCC  320005     bra z, 0x000dd8
  0DCE  A6F004     btss 0x0008,#15
  0DD0  37000D     bra 0x000dec
  0DD2  200010     mov.w #0x1,0x0000
  0DD4  B6E042     xor.b 0x0042
  0DD6  37000A     bra 0x000dec
  0DD8  538085     sub.w 0x000e,0x000a,0x0002
  0DDA  320005     bra z, 0x000de6
  0DDC  A6F004     btss 0x0008,#15
  0DDE  370006     bra 0x000dec
  0DE0  200010     mov.w #0x1,0x0000
  0DE2  B6E042     xor.b 0x0042
  0DE4  370003     bra 0x000dec
  0DE6  A90042     bclr.b 0x0042,#0
  0DE8  370001     bra 0x000dec
  0DEA  370000     bra 0x000dec
  0DEC  7803CF     mov.w [--0x001e],0x000e
  0DEE  78034F     mov.w [--0x001e],0x000c
  0DF0  7802CF     mov.w [--0x001e],0x000a
  0DF2  060000     return
  0DF4  780100     mov.w 0x0000,0x0004
  0DF6  780181     mov.w 0x0002,0x0006
  0DF8  784001     mov.b 0x0002,0x0000
  0DFA  FD8000     swap.w 0x0000
  0DFC  A0F000     bset 0x0000,#15
  0DFE  D28081     rlc.w 0x0002,0x0002
  0E00  FD8001     swap.w 0x0002
  0E02  FB8081     ze 0x0002,0x0002
  0E04  2008E4     mov.w #0x8e,0x0008
  0E06  524081     sub.b 0x0008,0x0002,0x0002
  0E08  320006     bra z, 0x000e16
  0E0A  E00000     cp0.w 0x0000
  0E0C  320004     bra z, 0x000e16
  0E0E  A90042     bclr.b 0x0042,#0
  0E10  D38000     rrc.w 0x0000,0x0000
  0E12  E90081     dec.w 0x0002,0x0002
  0E14  3AFFFA     bra nz, 0x000e0a
  0E16  A6F003     btss 0x0006,#15
  0E18  370002     bra 0x000e1e
  0E1A  EA0000     neg.w 0x0000,0x0000
  0E1C  370000     bra 0x000e1e
  0E1E  060000     return
  0E20  781F85     mov.w 0x000a,[0x001e++]
  0E22  2000C5     mov.w #0xc,0x000a
  0E24  090003     repeat #3
  0E26  781FB5     mov.w [0x000a++],[0x001e++]
  0E28  EB0480     clr.w 0x0012
  0E2A  280008     mov.w #0x8000,0x0010
  0E2C  AF0043     btsc.b 0x0043,#0
  0E2E  6C0183     xor.w 0x0010,0x0006,0x0006
  0E30  780501     mov.w 0x0002,0x0014
  0E32  69858A     xor.w 0x0006,0x0014,0x0016
  0E34  780301     mov.w 0x0002,0x000c
  0E36  780383     mov.w 0x0006,0x000e
  0E38  780603     mov.w 0x0006,0x0018
  0E3A  A92042     bclr.b 0x0042,#1
  0E3C  A90042     bclr.b 0x0042,#0
  0E3E  D28306     rlc.w 0x000c,0x000c
  0E40  FD8006     swap.w 0x000c
  0E42  B20FF6     and.w #0xff,0x000c
  0E44  E00006     cp0.w 0x000c
  0E46  3200A1     bra z, 0x000f8a
  0E48  A92042     bclr.b 0x0042,#1
  0E4A  A90042     bclr.b 0x0042,#0
  0E4C  D28387     rlc.w 0x000e,0x000e
  0E4E  FD8007     swap.w 0x000e
  0E50  B20FF7     and.w #0xff,0x000e
  0E52  E00007     cp0.w 0x000e
  0E54  32009F     bra z, 0x000f94
  0E56  A92042     bclr.b 0x0042,#1
  0E58  A90042     bclr.b 0x0042,#0
  0E5A  E13806     cp.w 0x000e,0x000c
  0E5C  32009C     bra z, 0x000f96
  0E5E  3300A3     bra n, 0x000fa6
  0E60  A10009     bclr 0x0012,#0
  0E62  A01009     bset 0x0012,#1
  0E64  538406     sub.w 0x000e,0x000c,0x0010
  0E66  780307     mov.w 0x000e,0x000c
  0E68  B20FF1     and.w #0xff,0x0002
  0E6A  A07001     bset 0x0002,#7
  0E6C  B20FF3     and.w #0xff,0x0006
  0E6E  A07003     bset 0x0006,#7
  0E70  200287     mov.w #0x28,0x000e
  0E72  E13808     cp.w 0x000e,0x0010
  0E74  330011     bra n, 0x000e98
  0E76  A92042     bclr.b 0x0042,#1
  0E78  A90042     bclr.b 0x0042,#0
  0E7A  D38081     rrc.w 0x0002,0x0002
  0E7C  D38000     rrc.w 0x0000,0x0000
  0E7E  E90408     dec.w 0x0010,0x0010
  0E80  3AFFFA     bra nz, 0x000e76
  0E82  37000D     bra 0x000e9e
  0E84  200287     mov.w #0x28,0x000e
  0E86  E13808     cp.w 0x000e,0x0010
  0E88  330009     bra n, 0x000e9c
  0E8A  A92042     bclr.b 0x0042,#1
  0E8C  A90042     bclr.b 0x0042,#0
  0E8E  D38183     rrc.w 0x0006,0x0006
  0E90  D38102     rrc.w 0x0004,0x0004
  0E92  E90408     dec.w 0x0010,0x0010
  0E94  3AFFFA     bra nz, 0x000e8a
  0E96  37000F     bra 0x000eb6
  0E98  780002     mov.w 0x0004,0x0000
  0E9A  780083     mov.w 0x0006,0x0002
  0E9C  370043     bra 0x000f24
  0E9E  A6F00B     btss 0x0016,#15
  0EA0  370011     bra 0x000ec4
  0EA2  A74009     btsc 0x0012,#4
  0EA4  78058C     mov.w 0x0018,0x0016
  0EA6  EA0000     neg.w 0x0000,0x0000
  0EA8  320002     bra z, 0x000eae
  0EAA  EAC081     com.b 0x0002,0x0002
  0EAC  370001     bra 0x000eb0
  0EAE  EA0081     neg.w 0x0002,0x0002
  0EB0  A74009     btsc 0x0012,#4
  0EB2  37002B     bra 0x000f0a
  0EB4  370007     bra 0x000ec4
  0EB6  A6F00B     btss 0x0016,#15
  0EB8  370005     bra 0x000ec4
  0EBA  EA0102     neg.w 0x0004,0x0004
  0EBC  320002     bra z, 0x000ec2
  0EBE  EAC183     com.b 0x0006,0x0006
  0EC0  370001     bra 0x000ec4
  0EC2  EA0183     neg.w 0x0006,0x0006
  0EC4  B20FF5     and.w #0xff,0x000a
  0EC6  A92042     bclr.b 0x0042,#1
  0EC8  A90042     bclr.b 0x0042,#0
  0ECA  400002     add.w 0x0000,0x0004,0x0000
  0ECC  48C083     addc.b 0x0002,0x0006,0x0002
  0ECE  AF0042     btsc.b 0x0042,#0
  0ED0  A03009     bset 0x0012,#3
  0ED2  A70009     btsc 0x0012,#0
  0ED4  370009     bra 0x000ee8
  0ED6  A71009     btsc 0x0012,#1
  0ED8  370001     bra 0x000edc
  0EDA  37000B     bra 0x000ef2
  0EDC  A7F00B     btsc 0x0016,#15
  0EDE  370015     bra 0x000f0a
  0EE0  A73009     btsc 0x0012,#3
  0EE2  370029     bra 0x000f36
  0EE4  A06009     bset 0x0012,#6
  0EE6  37001E     bra 0x000f24
  0EE8  A7F00B     btsc 0x0016,#15
  0EEA  37000F     bra 0x000f0a
  0EEC  A73009     btsc 0x0012,#3
  0EEE  370023     bra 0x000f36
  0EF0  370019     bra 0x000f24
  0EF2  A12009     bclr 0x0012,#2
  0EF4  A7F00B     btsc 0x0016,#15
  0EF6  370004     bra 0x000f00
  0EF8  78058A     mov.w 0x0014,0x0016
  0EFA  A73009     btsc 0x0012,#3
  0EFC  37001C     bra 0x000f36
  0EFE  370036     bra 0x000f6c
  0F00  A04009     bset 0x0012,#4
  0F02  B2C801     xor.b #0x80,0x0002
  0F04  A77001     btsc 0x0002,#7
  0F06  37FFCD     bra 0x000ea2
  0F08  78058A     mov.w 0x0014,0x0016
  0F0A  B20FF1     and.w #0xff,0x0002
  0F0C  700381     ior.w 0x0000,0x0002,0x000e
  0F0E  32000A     bra z, 0x000f24
  0F10  A77001     btsc 0x0002,#7
  0F12  370008     bra 0x000f24
  0F14  A92042     bclr.b 0x0042,#1
  0F16  A90042     bclr.b 0x0042,#0
  0F18  D28000     rlc.w 0x0000,0x0000
  0F1A  D28081     rlc.w 0x0002,0x0002
  0F1C  E90306     dec.w 0x000c,0x000c
  0F1E  AF2042     btsc.b 0x0042,#1
  0F20  370031     bra 0x000f84
  0F22  37FFF6     bra 0x000f10
  0F24  A70009     btsc 0x0012,#0
  0F26  78058A     mov.w 0x0014,0x0016
  0F28  A71009     btsc 0x0012,#1
  0F2A  78058C     mov.w 0x0018,0x0016
  0F2C  A65009     btss 0x0012,#5
  0F2E  37001A     bra 0x000f64
  0F30  A7F00A     btsc 0x0014,#15
  0F32  A08000     bset 0x0000,#8
  0F34  37001B     bra 0x000f6c
  0F36  A80042     bset.b 0x0042,#0
  0F38  D3C081     rrc.b 0x0002,0x0002
  0F3A  D38000     rrc.w 0x0000,0x0000
  0F3C  AF0042     btsc.b 0x0042,#0
  0F3E  A05009     bset 0x0012,#5
  0F40  E80306     inc.w 0x000c,0x000c
  0F42  320020     bra z, 0x000f84
  0F44  A65009     btss 0x0012,#5
  0F46  370008     bra 0x000f58
  0F48  E80000     inc.w 0x0000,0x0000
  0F4A  3A0006     bra nz, 0x000f58
  0F4C  E84081     inc.b 0x0002,0x0002
  0F4E  3A0004     bra nz, 0x000f58
  0F50  D3C081     rrc.b 0x0002,0x0002
  0F52  D38000     rrc.w 0x0000,0x0000
  0F54  E80306     inc.w 0x000c,0x000c
  0F56  320016     bra z, 0x000f84
  0F58  A70009     btsc 0x0012,#0
  0F5A  78058A     mov.w 0x0014,0x0016
  0F5C  A71009     btsc 0x0012,#1
  0F5E  78058C     mov.w 0x0018,0x0016
  0F60  AF2042     btsc.b 0x0042,#1
  0F62  370010     bra 0x000f84
  0F64  A76009     btsc 0x0012,#6
  0F66  78058A     mov.w 0x0014,0x0016
  0F68  A77009     btsc 0x0012,#7
  0F6A  78058C     mov.w 0x0018,0x0016
  0F6C  700101     ior.w 0x0000,0x0002,0x0004
  0F6E  320023     bra z, 0x000fb6
  0F70  A17001     bclr 0x0002,#7
  0F72  FD8006     swap.w 0x000c
  0F74  A92042     bclr.b 0x0042,#1
  0F76  A90042     bclr.b 0x0042,#0
  0F78  D38306     rrc.w 0x000c,0x000c
  0F7A  6B0081     xor.w 0x000c,0x0002,0x0002
  0F7C  A0F001     bset 0x0002,#15
  0F7E  A6F00B     btss 0x0016,#15
  0F80  A1F001     bclr 0x0002,#15
  0F82  370019     bra 0x000fb6
  0F84  200000     mov.w #0x0,0x0000
  0F86  200001     mov.w #0x0,0x0002
  0F88  370016     bra 0x000fb6
  0F8A  A7F00A     btsc 0x0014,#15
  0F8C  6C0183     xor.w 0x0010,0x0006,0x0006
  0F8E  780002     mov.w 0x0004,0x0000
  0F90  780083     mov.w 0x0006,0x0002
  0F92  370011     bra 0x000fb6
  0F94  370010     bra 0x000fb6
  0F96  B20FF3     and.w #0xff,0x0006
  0F98  A07003     bset 0x0006,#7
  0F9A  B20FF1     and.w #0xff,0x0002
  0F9C  A07001     bset 0x0002,#7
  0F9E  A7F00B     btsc 0x0016,#15
  0FA0  A17003     bclr 0x0006,#7
  0FA2  A02009     bset 0x0012,#2
  0FA4  37FF88     bra 0x000eb6
  0FA6  530407     sub.w 0x000c,0x000e,0x0010
  0FA8  B20FF1     and.w #0xff,0x0002
  0FAA  A07001     bset 0x0002,#7
  0FAC  B20FF3     and.w #0xff,0x0006
  0FAE  A07003     bset 0x0006,#7
  0FB0  A11009     bclr 0x0012,#1
  0FB2  A00009     bset 0x0012,#0
  0FB4  37FF67     bra 0x000e84
  0FB6  200125     mov.w #0x12,0x000a
  0FB8  090003     repeat #3
  0FBA  7812CF     mov.w [--0x001e],[0x000a--]
  0FBC  7802CF     mov.w [--0x001e],0x000a
  0FBE  060000     return
  0FC0  781F85     mov.w 0x000a,[0x001e++]
  0FC2  2000C5     mov.w #0xc,0x000a
  0FC4  090004     repeat #4
  0FC6  781FB5     mov.w [0x000a++],[0x001e++]
  0FC8  780200     mov.w 0x0000,0x0008
  0FCA  780281     mov.w 0x0002,0x000a
  0FCC  780383     mov.w 0x0006,0x000e
  0FCE  780302     mov.w 0x0004,0x000c
  0FD0  A90042     bclr.b 0x0042,#0
  0FD2  A92042     bclr.b 0x0042,#1
  0FD4  D28081     rlc.w 0x0002,0x0002
  0FD6  FD8001     swap.w 0x0002
  0FD8  B20FF1     and.w #0xff,0x0002
  0FDA  E00001     cp0.w 0x0002
  0FDC  320048     bra z, 0x00106e
  0FDE  A90042     bclr.b 0x0042,#0
  0FE0  A92042     bclr.b 0x0042,#1
  0FE2  D28183     rlc.w 0x0006,0x0006
  0FE4  FD8003     swap.w 0x0006
  0FE6  B20FF3     and.w #0xff,0x0006
  0FE8  E00003     cp0.w 0x0006
  0FEA  320041     bra z, 0x00106e
  0FEC  FB8000     ze 0x0000,0x0000
  0FEE  41C001     add.b 0x0006,0x0002,0x0000
  0FF0  310004     bra c, 0x000ffa
  0FF2  B107F0     sub.w 0x0000,#0x7f
  0FF4  32003C     bra z, 0x00106e
  0FF6  39003B     bra nc, 0x00106e
  0FF8  370002     bra 0x000ffe
  0FFA  B04810     add.b #0x81,0x0000
  0FFC  310038     bra c, 0x00106e
  0FFE  6A8507     xor.w 0x000a,0x000e,0x0014
  1000  A90042     bclr.b 0x0042,#0
  1002  A92042     bclr.b 0x0042,#1
  1004  B20FF5     and.w #0xff,0x000a
  1006  A07005     bset 0x000a,#7
  1008  A90042     bclr.b 0x0042,#0
  100A  B20FF7     and.w #0xff,0x000e
  100C  A07007     bset 0x000e,#7
  100E  B82106     mul.uu 0x0008,0x000c,0x0004
  1010  B82C06     mul.uu 0x000a,0x000c,0x0010
  1012  4C0183     addc.w 0x0010,0x0006,0x0006
  1014  780089     mov.w 0x0012,0x0002
  1016  B83C04     mul.uu 0x000e,0x0008,0x0010
  1018  4C0183     addc.w 0x0010,0x0006,0x0006
  101A  4C8081     addc.w 0x0012,0x0002,0x0002
  101C  B82C07     mul.uu 0x000a,0x000e,0x0010
  101E  4C0081     addc.w 0x0010,0x0002,0x0002
  1020  E80000     inc.w 0x0000,0x0000
  1022  E00001     cp0.w 0x0002
  1024  AF2042     btsc.b 0x0042,#1
  1026  370001     bra 0x00102a
  1028  370003     bra 0x001030
  102A  E00003     cp0.w 0x0006
  102C  AF2042     btsc.b 0x0042,#1
  102E  370005     bra 0x00103a
  1030  A7F001     btsc 0x0002,#15
  1032  370003     bra 0x00103a
  1034  D28183     rlc.w 0x0006,0x0006
  1036  D28081     rlc.w 0x0002,0x0002
  1038  E90000     dec.w 0x0000,0x0000
  103A  780101     mov.w 0x0002,0x0004
  103C  A90042     bclr.b 0x0042,#0
  103E  A67003     btss 0x0006,#7
  1040  370009     bra 0x001054
  1042  2FF007     mov.w #0xff00,0x000e
  1044  618187     and.w 0x0006,0x000e,0x0006
  1046  B01003     add.w #0x100,0x0006
  1048  490160     addc.w 0x0004,#0,0x0004
  104A  E00002     cp0.w 0x0004
  104C  3A0003     bra nz, 0x001054
  104E  E00003     cp0.w 0x0006
  1050  3A0001     bra nz, 0x001054
  1052  E80000     inc.w 0x0000,0x0000
  1054  FD8000     swap.w 0x0000
  1056  A90042     bclr.b 0x0042,#0
  1058  A92042     bclr.b 0x0042,#1
  105A  D38080     rrc.w 0x0000,0x0002
  105C  A7F00A     btsc 0x0014,#15
  105E  A0F001     bset 0x0002,#15
  1060  A1F002     bclr 0x0004,#15
  1062  FD8002     swap.w 0x0004
  1064  694081     xor.b 0x0004,0x0002,0x0002
  1066  FD8003     swap.w 0x0006
  1068  784103     mov.b 0x0006,0x0004
  106A  780002     mov.w 0x0004,0x0000
  106C  370003     bra 0x001074
  106E  200000     mov.w #0x0,0x0000
  1070  200001     mov.w #0x0,0x0002
  1072  370000     bra 0x001074
  1074  200145     mov.w #0x14,0x000a
  1076  090004     repeat #4
  1078  7812CF     mov.w [--0x001e],[0x000a--]
  107A  7802CF     mov.w [--0x001e],0x000a
  107C  060000     return
  1554  781F85     mov.w 0x000a,[0x001e++]
  1556  781F86     mov.w 0x000c,[0x001e++]
  1558  780200     mov.w 0x0000,0x0008
  155A  780281     mov.w 0x0002,0x000a
  155C  EB0000     clr.w 0x0000
  155E  EB0080     clr.w 0x0002
  1560  720185     ior.w 0x0008,0x000a,0x0006
  1562  320011     bra z, 0x001586
  1564  EB0100     clr.w 0x0004
  1566  200B61     mov.w #0xb6,0x0002
  1568  A77002     btsc 0x0004,#7
  156A  370007     bra 0x00157a
  156C  A90042     bclr.b 0x0042,#0
  156E  D28204     rlc.w 0x0008,0x0008
  1570  D28285     rlc.w 0x000a,0x000a
  1572  D28000     rlc.w 0x0000,0x0000
  1574  D28102     rlc.w 0x0004,0x0004
  1576  E90081     dec.w 0x0002,0x0002
  1578  3AFFF7     bra nz, 0x001568
  157A  FD8001     swap.w 0x0002
  157C  A90042     bclr.b 0x0042,#0
  157E  D38081     rrc.w 0x0002,0x0002
  1580  A1F001     bclr 0x0002,#15
  1582  A17002     bclr 0x0004,#7
  1584  694081     xor.b 0x0004,0x0002,0x0002
  1586  78034F     mov.w [--0x001e],0x000c
  1588  7802CF     mov.w [--0x001e],0x000a
  158A  060000     return
  1C72  781F81     mov.w 0x0002,[0x001e++]
  1C74  804BE1     mov.w 0x097c,0x0002
  1C76  785880     mov.b 0x0000,[0x0002++]
  1C78  EB4880     clr.b [0x0002]
  1C7A  7800CF     mov.w [--0x001e],0x0002
  1C7C  EC297C     inc.w 0x097c
  1C7E  060000     return
  1C80  781F85     mov.w 0x000a,[0x001e++]
  1C82  2000C5     mov.w #0xc,0x000a
  1C84  090003     repeat #3
  1C86  781FB5     mov.w [0x000a++],[0x001e++]
  1C88  780380     mov.w 0x0000,0x000e
  1C8A  780484     mov.w 0x0008,0x0012
  1C8C  A1F004     bclr 0x0008,#15
  1C8E  E00004     cp0.w 0x0008
  1C90  3A0006     bra nz, 0x001c9e
  1C92  A7F009     btsc 0x0012,#15
  1C94  370002     bra 0x001c9a
  1C96  200005     mov.w #0x0,0x000a
  1C98  370010     bra 0x001cba
  1C9A  200005     mov.w #0x0,0x000a
  1C9C  37000E     bra 0x001cba
  1C9E  5242E6     sub.b 0x0008,#6,0x000a
  1CA0  39000B     bra nc, 0x001cb8
  1CA2  200300     mov.w #0x30,0x0000
  1CA4  A6F009     btss 0x0012,#15
  1CA6  200200     mov.w #0x20,0x0000
  1CA8  781F80     mov.w 0x0000,[0x001e++]
  1CAA  78004F     mov.w [--0x001e],0x0000
  1CAC  021C72     call 0x001c72
  1CB0  E90285     dec.w 0x000a,0x000a
  1CB2  3BFFFA     bra nn, 0x001ca8
  1CB4  200055     mov.w #0x5,0x000a
  1CB6  370001     bra 0x001cba
  1CB8  780284     mov.w 0x0008,0x000a
  1CBA  200064     mov.w #0x6,0x0008
  1CBC  A0E005     bset 0x000a,#14
  1CBE  A7F009     btsc 0x0012,#15
  1CC0  A0F005     bset 0x000a,#15
  1CC2  227108     mov.w #0x2710,0x0010
  1CC4  090011     repeat #17
  1CC6  D88388     div.uw 0x000e,0x0010
  1CC8  021CFE     call 0x001cfe
  1CCC  780381     mov.w 0x0002,0x000e
  1CCE  203E88     mov.w #0x3e8,0x0010
  1CD0  090011     repeat #17
  1CD2  D88388     div.uw 0x000e,0x0010
  1CD4  021CFE     call 0x001cfe
  1CD8  780381     mov.w 0x0002,0x000e
  1CDA  200648     mov.w #0x64,0x0010
  1CDC  090011     repeat #17
  1CDE  D88388     div.uw 0x000e,0x0010
  1CE0  021CFE     call 0x001cfe
  1CE4  780381     mov.w 0x0002,0x000e
  1CE6  2000A8     mov.w #0xa,0x0010
  1CE8  090011     repeat #17
  1CEA  D88388     div.uw 0x000e,0x0010
  1CEC  021CFE     call 0x001cfe
  1CF0  200300     mov.w #0x30,0x0000
  1CF2  40C000     add.b 0x0002,0x0000,0x0000
  1CF4  781F80     mov.w 0x0000,[0x001e++]
  1CF6  78004F     mov.w [--0x001e],0x0000
  1CF8  021C72     call 0x001c72
  1CFC  37001A     bra 0x001d32
  1CFE  200306     mov.w #0x30,0x000c
  1D00  E00000     cp0.w 0x0000
  1D02  3A000E     bra nz, 0x001d20
  1D04  A6E005     btss 0x000a,#14
  1D06  37000D     bra 0x001d22
  1D08  E90204     dec.w 0x0008,0x0008
  1D0A  E12405     cp.b 0x0008,0x000a
  1D0C  320002     bra z, 0x001d12
  1D0E  AF0042     btsc.b 0x0042,#0
  1D10  060000     return
  1D12  E00000     cp0.w 0x0000
  1D14  3A0005     bra nz, 0x001d20
  1D16  A6E005     btss 0x000a,#14
  1D18  370004     bra 0x001d22
  1D1A  A6F005     btss 0x000a,#15
  1D1C  200206     mov.w #0x20,0x000c
  1D1E  370001     bra 0x001d22
  1D20  A1E005     bclr 0x000a,#14
  1D22  434000     add.b 0x000c,0x0000,0x0000
  1D24  781F81     mov.w 0x0002,[0x001e++]
  1D26  781F80     mov.w 0x0000,[0x001e++]
  1D28  78004F     mov.w [--0x001e],0x0000
  1D2A  021C72     call 0x001c72
  1D2E  7800CF     mov.w [--0x001e],0x0002
  1D30  060000     return
  1D32  200125     mov.w #0x12,0x000a
  1D34  090003     repeat #3
  1D36  7812CF     mov.w [--0x001e],[0x000a--]
  1D38  7802CF     mov.w [--0x001e],0x000a
  1D3A  060000     return
---  C:\Program Files\PICC\drivers\math.h  -------------------------------------------------------
1:                 ////////////////////////////////////////////////////////////////////////////
2:                 ////        (C) Copyright 1996,2008 Custom Computer Services            ////
3:                 //// This source code may only be used by licensed users of the CCS C   ////
4:                 //// compiler.  This source code may only be distributed to other       ////
5:                 //// licensed users of the CCS C compiler.  No other use, reproduction  ////
6:                 //// or distribution is permitted without written permission.           ////
7:                 //// Derivative programs created using this software in object code     ////
8:                 //// form are not restricted in any way.                                ////
9:                 ////////////////////////////////////////////////////////////////////////////
10:                ////                                                                    ////
11:                //// History:                                                           ////
12:                ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
13:                ////                 The code now is small, much faster,                ////
14:                ////                 and more accurate.                                 ////
15:                ////  * 2/21/2007 :  Compiler handles & operator differently and does
16:                ////                 not return generic (int8 *) so type cast is done   ////
17:                ////                                                                    ////
18:                ////////////////////////////////////////////////////////////////////////////
19:                
20:                #ifndef MATH_H
21:                #define MATH_H
22:                
23:                #ifdef PI
24:                #undef  PI
25:                #endif
26:                #define PI     3.1415926535897932
27:                
28:                
29:                #define SQRT2  1.4142135623730950
30:                
31:                //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
32:                //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
33:                
34:                ///////////////////////////// Round Functions //////////////////////////////
35:                
36:                float32 CEIL_FLOOR(float32 x, unsigned int8 n)
37:                {
  107E  781F85     mov.w 0x000a,[0x001e++]
  1080  781F86     mov.w 0x000c,[0x001e++]
38:                   float32 y, res;
39:                   unsigned int16 l;
40:                   int1 s;
41:                
42:                   s = 0;
  1082  A909F7     bclr.b 0x09f7,#0
43:                   y = x;
  1084  F809F2     push.w 0x09f2
  1086  F909F8     pop.w 0x09f8
  1088  F809F4     push.w 0x09f4
  108A  F909FA     pop.w 0x09fa
44:                
45:                   if (x < 0)
  108C  804F90     mov.w 0x09f2,0x0000
  108E  804FA1     mov.w 0x09f4,0x0002
  1090  200002     mov.w #0x0,0x0004
  1092  200003     mov.w #0x0,0x0006
  1094  020D8C     call 0x000d8c
  1098  390002     bra nc, 0x00109e
46:                   {
47:                      s = 1;
  109A  A809F7     bset.b 0x09f7,#0
48:                      y = -y;
  109C  AAE9FB     btg.b 0x09fb,#7
49:                   }
50:                
51:                   if (y <= 32768.0)
  109E  804FC0     mov.w 0x09f8,0x0000
  10A0  804FD1     mov.w 0x09fa,0x0002
  10A2  200002     mov.w #0x0,0x0004
  10A4  247003     mov.w #0x4700,0x0006
  10A6  020D8C     call 0x000d8c
  10AA  310001     bra c, 0x0010ae
  10AC  3A0009     bra nz, 0x0010c0
52:                  res = (float32)(unsigned int16)y;
  10AE  804FC0     mov.w 0x09f8,0x0000
  10B0  804FD1     mov.w 0x09fa,0x0002
  10B2  020DF4     call 0x000df4
  10B6  020C3E     call 0x000c3e
  10BA  884FE0     mov.w 0x0000,0x09fc
  10BC  884FF1     mov.w 0x0002,0x09fe
53:                
54:                 else if (y < 10000000.0)
  10BE  370049     bra 0x001152
  10C0  804FC0     mov.w 0x09f8,0x0000
  10C2  804FD1     mov.w 0x09fa,0x0002
  10C4  296802     mov.w #0x9680,0x0004
  10C6  24B183     mov.w #0x4b18,0x0006
  10C8  020D8C     call 0x000d8c
  10CC  39003E     bra nc, 0x00114a
55:                   {
56:                  l = (unsigned int16)(y/32768.0);
  10CE  804FC0     mov.w 0x09f8,0x0000
  10D0  804FD1     mov.w 0x09fa,0x0002
  10D2  200002     mov.w #0x0,0x0004
  10D4  247003     mov.w #0x4700,0x0006
  10D6  020C78     call 0x000c78
  10DA  020DF4     call 0x000df4
  10DE  885000     mov.w 0x0000,0x0a00
57:                      y = 32768.0*(y/32768.0 - (float32)l);
  10E0  804FC0     mov.w 0x09f8,0x0000
  10E2  804FD1     mov.w 0x09fa,0x0002
  10E4  200002     mov.w #0x0,0x0004
  10E6  247003     mov.w #0x4700,0x0006
  10E8  020C78     call 0x000c78
  10EC  780280     mov.w 0x0000,0x000a
  10EE  780301     mov.w 0x0002,0x000c
  10F0  805000     mov.w 0x0a00,0x0000
  10F2  020C3E     call 0x000c3e
  10F6  A80043     bset.b 0x0043,#0
  10F8  780100     mov.w 0x0000,0x0004
  10FA  780181     mov.w 0x0002,0x0006
  10FC  780005     mov.w 0x000a,0x0000
  10FE  780086     mov.w 0x000c,0x0002
  1100  020E20     call 0x000e20
  1104  780100     mov.w 0x0000,0x0004
  1106  780181     mov.w 0x0002,0x0006
  1108  200000     mov.w #0x0,0x0000
  110A  247001     mov.w #0x4700,0x0002
  110C  020FC0     call 0x000fc0
  1110  884FC0     mov.w 0x0000,0x09f8
  1112  884FD1     mov.w 0x0002,0x09fa
58:                  res = 32768.0*(float32)l;
  1114  805000     mov.w 0x0a00,0x0000
  1116  020C3E     call 0x000c3e
  111A  780100     mov.w 0x0000,0x0004
  111C  780181     mov.w 0x0002,0x0006
  111E  200000     mov.w #0x0,0x0000
  1120  247001     mov.w #0x4700,0x0002
  1122  020FC0     call 0x000fc0
  1126  884FE0     mov.w 0x0000,0x09fc
  1128  884FF1     mov.w 0x0002,0x09fe
59:                  res += (float32)(unsigned int16)y;
  112A  804FC0     mov.w 0x09f8,0x0000
  112C  804FD1     mov.w 0x09fa,0x0002
  112E  020DF4     call 0x000df4
  1132  020C3E     call 0x000c3e
  1136  A90043     bclr.b 0x0043,#0
  1138  780100     mov.w 0x0000,0x0004
  113A  780181     mov.w 0x0002,0x0006
  113C  804FE0     mov.w 0x09fc,0x0000
  113E  804FF1     mov.w 0x09fe,0x0002
  1140  020E20     call 0x000e20
  1144  884FE0     mov.w 0x0000,0x09fc
  1146  884FF1     mov.w 0x0002,0x09fe
60:                 }
61:                
62:                 else
  1148  370004     bra 0x001152
63:                  res = y;
  114A  F809F8     push.w 0x09f8
  114C  F909FC     pop.w 0x09fc
  114E  F809FA     push.w 0x09fa
  1150  F909FE     pop.w 0x09fe
64:                
65:                 y = y - (float32)(unsigned int16)y;
  1152  804FC0     mov.w 0x09f8,0x0000
  1154  804FD1     mov.w 0x09fa,0x0002
  1156  020DF4     call 0x000df4
  115A  020C3E     call 0x000c3e
  115E  A80043     bset.b 0x0043,#0
  1160  780100     mov.w 0x0000,0x0004
  1162  780181     mov.w 0x0002,0x0006
  1164  804FC0     mov.w 0x09f8,0x0000
  1166  804FD1     mov.w 0x09fa,0x0002
  1168  020E20     call 0x000e20
  116C  884FC0     mov.w 0x0000,0x09f8
  116E  884FD1     mov.w 0x0002,0x09fa
66:                
67:                 if (s)
  1170  AE09F7     btss.b 0x09f7,#0
  1172  370001     bra 0x001176
68:                  res = -res;
  1174  AAE9FF     btg.b 0x09ff,#7
69:                
70:                 if (y != 0)
  1176  804FC0     mov.w 0x09f8,0x0000
  1178  804FD1     mov.w 0x09fa,0x0002
  117A  200002     mov.w #0x0,0x0004
  117C  200003     mov.w #0x0,0x0006
  117E  020D8C     call 0x000d8c
  1182  32001B     bra z, 0x0011ba
71:                 {
72:                  if (s == 1 && n == 0)
  1184  AE09F7     btss.b 0x09f7,#0
  1186  37000B     bra 0x00119e
  1188  E249F6     cp0.b 0x09f6
  118A  3A0009     bra nz, 0x00119e
73:                   res -= 1.0;
  118C  A80043     bset.b 0x0043,#0
  118E  804FE0     mov.w 0x09fc,0x0000
  1190  804FF1     mov.w 0x09fe,0x0002
  1192  200002     mov.w #0x0,0x0004
  1194  23F803     mov.w #0x3f80,0x0006
  1196  020E20     call 0x000e20
  119A  884FE0     mov.w 0x0000,0x09fc
  119C  884FF1     mov.w 0x0002,0x09fe
74:                
75:                  if (s == 0 && n == 1)
  119E  AF09F7     btsc.b 0x09f7,#0
  11A0  37000C     bra 0x0011ba
  11A2  804FB4     mov.w 0x09f6,0x0008
  11A4  E12461     cp.b 0x0008,#1
  11A6  3A0009     bra nz, 0x0011ba
76:                   res += 1.0;
  11A8  A90043     bclr.b 0x0043,#0
  11AA  804FE0     mov.w 0x09fc,0x0000
  11AC  804FF1     mov.w 0x09fe,0x0002
  11AE  200002     mov.w #0x0,0x0004
  11B0  23F803     mov.w #0x3f80,0x0006
  11B2  020E20     call 0x000e20
  11B6  884FE0     mov.w 0x0000,0x09fc
  11B8  884FF1     mov.w 0x0002,0x09fe
77:                 }
78:                 if (x == 0)
  11BA  804F90     mov.w 0x09f2,0x0000
  11BC  804FA1     mov.w 0x09f4,0x0002
  11BE  200002     mov.w #0x0,0x0004
  11C0  200003     mov.w #0x0,0x0006
  11C2  020D8C     call 0x000d8c
  11C6  3A0002     bra nz, 0x0011cc
79:                    res = 0;
  11C8  EF29FC     clr.w 0x09fc
  11CA  EF29FE     clr.w 0x09fe
80:                
81:                 return (res);
  11CC  804FE0     mov.w 0x09fc,0x0000
  11CE  804FF1     mov.w 0x09fe,0x0002
82:                }
  11D0  78034F     mov.w [--0x001e],0x000c
  11D2  7802CF     mov.w [--0x001e],0x000a
  11D4  060000     return
83:                
84:                // Overloaded Functions to take care for new Data types in PCD
85:                // Overloaded function CEIL_FLOOR() for data type - Float48
86:                #if defined(__PCD__)
87:                float48 CEIL_FLOOR(float48 x, unsigned int8 n)
88:                {
89:                   float48 y, res;
90:                   unsigned int16 l;
91:                   int1 s;
92:                
93:                   s = 0;
94:                   y = x;
95:                
96:                   if (x < 0)
97:                   {
98:                      s = 1;
99:                      y = -y;
100:                  }
101:               
102:                  if (y <= 32768.0)
103:                 res = (float48)(unsigned int16)y;
104:               
105:                else if (y < 10000000.0)
106:                  {
107:                 l = (unsigned int16)(y/32768.0);
108:                     y = 32768.0*(y/32768.0 - (float48)l);
109:                 res = 32768.0*(float32)l;
110:                 res += (float48)(unsigned int16)y;
111:                }
112:               
113:                else
114:                 res = y;
115:               
116:                y = y - (float48)(unsigned int16)y;
117:               
118:                if (s)
119:                 res = -res;
120:               
121:                if (y != 0)
122:                {
123:                 if (s == 1 && n == 0)
124:                  res -= 1.0;
125:               
126:                 if (s == 0 && n == 1)
127:                  res += 1.0;
128:                }
129:                if (x == 0)
130:                   res = 0;
131:               
132:                return (res);
133:               }
134:               
135:               
136:               // Overloaded function CEIL_FLOOR() for data type - Float64
137:               float64 CEIL_FLOOR(float64 x, unsigned int8 n)
138:               {
139:                  float64 y, res;
140:                  unsigned int16 l;
141:                  int1 s;
142:               
143:                  s = 0;
144:                  y = x;
145:               
146:                  if (x < 0)
147:                  {
148:                     s = 1;
149:                     y = -y;
150:                  }
151:               
152:                  if (y <= 32768.0)
153:                 res = (float64)(unsigned int16)y;
154:               
155:                else if (y < 10000000.0)
156:                  {
157:                 l = (unsigned int16)(y/32768.0);
158:                     y = 32768.0*(y/32768.0 - (float64)l);
159:                 res = 32768.0*(float64)l;
160:                 res += (float64)(unsigned int16)y;
161:                }
162:               
163:                else
164:                 res = y;
165:               
166:                y = y - (float64)(unsigned int16)y;
167:               
168:                if (s)
169:                 res = -res;
170:               
171:                if (y != 0)
172:                {
173:                 if (s == 1 && n == 0)
174:                  res -= 1.0;
175:               
176:                 if (s == 0 && n == 1)
177:                  res += 1.0;
178:                }
179:                if (x == 0)
180:                   res = 0;
181:               
182:                return (res);
183:               }
184:               #endif
185:               
186:               ////////////////////////////////////////////////////////////////////////////
187:               //   float floor(float x)
188:               ////////////////////////////////////////////////////////////////////////////
189:               // Description : rounds down the number x.
190:               // Date : N/A
191:               //
192:               float32 floor(float32 x)
193:               {
194:                  return CEIL_FLOOR(x, 0);
  11EA  EF69F6     clr.b 0x09f6
  11EC  F809EA     push.w 0x09ea
  11EE  F909F2     pop.w 0x09f2
  11F0  F809EC     push.w 0x09ec
  11F2  F909F4     pop.w 0x09f4
  11F4  02107E     call 0x00107e
  11F8  BE0000     mov.d 0x0000,0x0000
195:               }
  11FA  060000     return
196:               // Following 2 functions are overloaded functions of floor() for PCD
197:               // Overloaded function floor() for data type - Float48
198:               #if defined(__PCD__)
199:               float48 floor(float48 x)
200:               {
201:                  return CEIL_FLOOR(x, 0);
202:               }
203:               
204:               // Overloaded function floor() for data type - Float64
205:               float64 floor(float64 x)
206:               {
207:                  return CEIL_FLOOR(x, 0);
208:               }
209:               #endif
210:               
211:               
212:               ////////////////////////////////////////////////////////////////////////////
213:               //   float ceil(float x)
214:               ////////////////////////////////////////////////////////////////////////////
215:               // Description : rounds up the number x.
216:               // Date : N/A
217:               //
218:               float32 ceil(float32 x)
219:               {
220:                  return CEIL_FLOOR(x, 1);
  11D6  B3C010     mov.b #0x1,0x0000
  11D8  B7E9F6     mov.b 0x0000,0x09f6
  11DA  F809EA     push.w 0x09ea
  11DC  F909F2     pop.w 0x09f2
  11DE  F809EC     push.w 0x09ec
  11E0  F909F4     pop.w 0x09f4
  11E2  02107E     call 0x00107e
  11E6  BE0000     mov.d 0x0000,0x0000
221:               }
  11E8  060000     return
222:               // Following 2 functions are overloaded functions of ceil() for PCD
223:               // Overloaded function ceil() for data type - Float48
224:               #if defined(__PCD__)
225:               float48 ceil(float48 x)
226:               {
227:                  return CEIL_FLOOR(x, 1);
228:               }
229:               
230:               // Overloaded function ceil() for data type - Float64
231:               float64 ceil(float64 x)
232:               {
233:                  return CEIL_FLOOR(x, 1);
234:               }
235:               #endif
236:               
237:                ////////////////////////////////////////////////////////////////////////////
238:               //   float fabs(float x)
239:               ////////////////////////////////////////////////////////////////////////////
240:               // Description : Computes the absolute value of floating point number x
241:               // Returns : returns the absolute value of x
242:               // Date : N/A
243:               //
244:               #define fabs abs
245:               
246:               ////////////////////////////////////////////////////////////////////////////
247:               //   float fmod(float x)
248:               ////////////////////////////////////////////////////////////////////////////
249:               // Description : Computes the floating point remainder of x/y
250:               // Returns : returns the value of x= i*y, for some integer i such that, if y
251:               // is non zero, the result has the same isgn of x na dmagnitude less than the
252:               // magnitude of y. If y is zero then a domain error occurs.
253:               // Date : N/A
254:               //
255:               
256:               float fmod(float32 x,float32 y)
257:               {
  11FC  781F85     mov.w 0x000a,[0x001e++]
  11FE  781F86     mov.w 0x000c,[0x001e++]
258:                  float32 i;
259:                  if (y!=0.0)
  1200  804EB0     mov.w 0x09d6,0x0000
  1202  804EC1     mov.w 0x09d8,0x0002
  1204  200002     mov.w #0x0,0x0004
  1206  200003     mov.w #0x0,0x0006
  1208  020D8C     call 0x000d8c
  120C  32003A     bra z, 0x001282
260:                  {
261:                     i=(x/y < 0.0)? ceil(x/y): floor(x/y);
  120E  804E90     mov.w 0x09d2,0x0000
  1210  804EA1     mov.w 0x09d4,0x0002
  1212  804EB2     mov.w 0x09d6,0x0004
  1214  804EC3     mov.w 0x09d8,0x0006
  1216  020C78     call 0x000c78
  121A  780280     mov.w 0x0000,0x000a
  121C  780301     mov.w 0x0002,0x000c
  121E  780005     mov.w 0x000a,0x0000
  1220  780086     mov.w 0x000c,0x0002
  1222  200002     mov.w #0x0,0x0004
  1224  200003     mov.w #0x0,0x0006
  1226  020D8C     call 0x000d8c
  122A  39000D     bra nc, 0x001246
  122C  804E90     mov.w 0x09d2,0x0000
  122E  804EA1     mov.w 0x09d4,0x0002
  1230  804EB2     mov.w 0x09d6,0x0004
  1232  804EC3     mov.w 0x09d8,0x0006
  1234  020C78     call 0x000c78
  1238  780280     mov.w 0x0000,0x000a
  123A  780301     mov.w 0x0002,0x000c
  123C  884F55     mov.w 0x000a,0x09ea
  123E  884F66     mov.w 0x000c,0x09ec
  1240  0211D6     call 0x0011d6
  1244  37000C     bra 0x00125e
  1246  804E90     mov.w 0x09d2,0x0000
  1248  804EA1     mov.w 0x09d4,0x0002
  124A  804EB2     mov.w 0x09d6,0x0004
  124C  804EC3     mov.w 0x09d8,0x0006
  124E  020C78     call 0x000c78
  1252  780280     mov.w 0x0000,0x000a
  1254  780301     mov.w 0x0002,0x000c
  1256  884F55     mov.w 0x000a,0x09ea
  1258  884F66     mov.w 0x000c,0x09ec
  125A  0211EA     call 0x0011ea
  125E  884ED0     mov.w 0x0000,0x09da
  1260  884EE1     mov.w 0x0002,0x09dc
262:                     return(x-(i*y));
  1262  804ED0     mov.w 0x09da,0x0000
  1264  804EE1     mov.w 0x09dc,0x0002
  1266  804EB2     mov.w 0x09d6,0x0004
  1268  804EC3     mov.w 0x09d8,0x0006
  126A  020FC0     call 0x000fc0
  126E  A80043     bset.b 0x0043,#0
  1270  780100     mov.w 0x0000,0x0004
  1272  780181     mov.w 0x0002,0x0006
  1274  804E90     mov.w 0x09d2,0x0000
  1276  804EA1     mov.w 0x09d4,0x0002
  1278  020E20     call 0x000e20
  127C  BE0000     mov.d 0x0000,0x0000
  127E  370001     bra 0x001282
263:                  }
264:                  else
  1280  370000     bra 0x001282
265:                  {
266:                  #ifdef _ERRNO
267:                  {
268:                     errno=EDOM;
269:                  }
270:                  #endif
271:                  }
272:               }
  1282  78034F     mov.w [--0x001e],0x000c
  1284  7802CF     mov.w [--0x001e],0x000a
  1286  060000     return
---  C:\Program Files\PICC\drivers\string.h  -----------------------------------------------------
1:                 ////////////////////////////////////////////////////////////////////////////
2:                 ////        (C) Copyright 1996,2008 Custom Computer Services            ////
3:                 //// This source code may only be used by licensed users of the CCS C   ////
4:                 //// compiler.  This source code may only be distributed to other       ////
5:                 //// licensed users of the CCS C compiler.  No other use, reproduction  ////
6:                 //// or distribution is permitted without written permission.           ////
7:                 //// Derivative programs created using this software in object code     ////
8:                 //// form are not restricted in any way.                                ////
9:                 ////////////////////////////////////////////////////////////////////////////
10:                
11:                #ifndef _STRING
12:                #define _STRING
13:                #include <stddef.h>
14:                #include <ctype.h>
15:                
16:                
17:                
18:                //////////////////////////////////////////////
19:                //// Uncomment the following define to    ////
20:                //// allow some functions to use a        ////
21:                //// quicker algorithm, but use more ROM  ////
22:                ////                                      ////
23:                //// #define FASTER_BUT_MORE_ROM          ////
24:                //////////////////////////////////////////////
25:                
26:                
27:                
28:                /*Copying functions*/
29:                /* standard template:
30:                   void *memmove(void *s1, void *s2, size_t n).
31:                   Copies max of n characters safely (not following ending '\0')
32:                   from s2 in s1; if s2 has less than n characters, appends 0 */
33:                
34:                char *memmove(void *s1,char *s2,size_t n)
35:                {
36:                   char *sc1;
37:                   char *sc2;
38:                   sc1=s1;
39:                   sc2=s2;
40:                   if(sc2<sc1 && sc1 <sc2 +n)
41:                      for(sc1+=n,sc2+=n;0<n;--n)
42:                         *--sc1=*--sc2;
43:                   else
44:                      for(;0<n;--n)
45:                         *sc1++=*sc2++;
46:                  return s1;
47:                  }
48:                
49:                /* Standard template: char *strcpy(char *s1, const char *s2)
50:                   copies the string s2 including the null character to s1.
51:                   This is a compiler built in to handle the different address
52:                   spaces */
53:                
54:                #define strcopy strcpy
55:                
56:                /* standard template:
57:                   char *strncpy(char *s1, const char *s2, size_t n).
58:                   Copies max of n characters (not following ending '\0')
59:                   from s2 in s1; if s2 has less than n characters, appends 0 */
60:                
61:                char *strncpy(char *s1, char *s2, size_t n)
62:                {
63:                  char *s;
64:                
65:                  for (s = s1; n > 0 && *s2 != '\0'; n--)
66:                     *s++ = *s2++;
67:                  for (; n > 0; n--)
68:                     *s++ = '\0';
69:                
70:                  return(s1);
71:                }
72:                /***********************************************************/
73:                
74:                /*concatenation functions*/
75:                /* standard template: char *strcat(char *s1, const char *s2)
76:                appends s2 to s1*/
77:                
78:                char *strcat(char *s1, char *s2)
79:                {
80:                   char *s;
81:                
82:                   for (s = s1; *s != '\0'; ++s);
83:                   while(*s2 != '\0')
84:                   {
85:                      *s = *s2;
86:                      ++s;
87:                      ++s2;
88:                   }
89:                
90:                   *s = '\0';
91:                   return(s1);
92:                }
93:                /* standard template: char *strncat(char *s1, char *s2,size_t n)
94:                appends not more than n characters from s2 to s1*/
95:                
96:                char *strncat(char *s1, char *s2, size_t n)
97:                {
98:                   char *s;
99:                
100:                  for (s = s1; *s != '\0'; ++s);
101:                  while(*s2 != '\0' && 0<n)
102:                  {
103:                     *s = *s2;
104:                     ++s;
105:                     ++s2;
106:                     --n;
107:                  }
108:               
109:                  *s = '\0';
110:                  return(s1);
111:               }
112:               
113:               /***********************************************************/
114:               
115:               
116:               /*comparison functions*/
117:               /* standard template: signed int memcmp(void *s1, void *s2).
118:                  Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
119:               
120:               signed int8 memcmp(void * s1,char *s2,size_t n)
121:               {
122:               char *su1, *su2;
123:               for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
124:               {
125:                  if(*su1!=*su2)
126:                     return ((*su1<*su2)?-1:+1);
127:               }
128:               return 0;
129:               }
130:               
131:               /* standard template: int strcmp(const char *s1, const char *s2).
132:                  Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
133:               
134:               signed int8 strcmp(char *s1, char *s2)
135:               {
136:                  for (; *s1 == *s2; s1++, s2++)
137:                     if (*s1 == '\0')
138:                        return(0);
139:                  return((*s1 < *s2) ? -1: 1);
140:               }
141:               /* standard template: int strcoll(const char *s1, const char *s2).
142:                  Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
143:               
144:               signed int8 strcoll(char *s1, char *s2)
145:               {
146:                  for (; *s1 == *s2; s1++, s2++)
147:                     if (*s1 == '\0')
148:                        return(0);
149:                  return((*s1 < *s2) ? -1: 1);
150:               }
151:               
152:               /* standard template:
153:                  int strncmp(const char *s1, const char *s2, size_t n).
154:                  Compares max of n characters (not following 0) from s1 to s2;
155:                  returns same as strcmp */
156:               
157:               signed int8 strncmp(char *s1, char *s2, size_t n)
158:               {
159:                  for (; n > 0; s1++, s2++, n--)
160:                     if (*s1 != *s2)
161:                        return((*s1 <*s2) ? -1: 1);
162:                     else if (*s1 == '\0')
163:                        return(0);
164:                  return(0);
165:               }
166:               /* standard template:
167:                  int strxfrm(const char *s1, const char *s2, size_t n).
168:                  transforms maximum of n characters from s2 and places them into s1*/
169:               size_t strxfrm(char *s1, char *s2, size_t n)
170:               {
171:                 char *s;
172:                 unsigned int8 n1;
173:                 n1=n;
174:                 for (s = s1; n > 0 && *s2 != '\0'; n--)
175:                    *s++ = *s2++;
176:                 for (; n > 0; n--)
177:                    *s++ = '\0';
178:               
179:                 return(n1);
180:               }
181:               
182:               
183:               
184:               
185:               
186:               /***********************************************************/
187:               /*Search functions*/
188:               /* standard template: void *memchr(const char *s, int c).
189:                  Finds first occurrence of c in n characters of s */
190:               
191:               char *memchr(void *s,unsigned int8 c,size_t n)
192:               {
193:                  char uc;
194:                  char *su;
195:                  uc=c;
196:                  for(su=s;0<n;++su,--n)
197:                     if(*su==uc)
198:                     return su;
199:                  return NULL;
200:               }
201:               
202:               /* standard template: char *strchr(const char *s, int c).
203:                  Finds first occurrence of c in s */
204:               
205:               char *strchr(char *s, unsigned int8 c)
206:               {
207:                  for (; *s != c; s++)
208:                     if (*s == '\0')
209:                        return(0);
210:                  return(s);
211:               }
212:               /* standard template:
213:                  size_t strcspn(const char *s1, const char *s2).
214:                  Computes length of max initial segment of s1 that
215:                  consists entirely of characters NOT from s2*/
216:               
217:               unsigned int8  strcspn(char *s1, char *s2)
218:               {
219:                  char *sc1, *sc2;
220:               
221:                  for (sc1 = s1; *sc1 != 0; sc1++)
222:                     for (sc2 = s2; *sc2 != 0; sc2++)
223:                        if (*sc1 == *sc2)
224:                           return(sc1 - s1);
225:                  return(sc1 - s1);
226:               }
227:               /* standard template:
228:                  char *strpbrk(const char *s1, const char *s2).
229:                  Locates first occurence of any character from s2 in s1;
230:                  returns s1 if s2 is empty string */
231:               
232:               char *strpbrk(char *s1, char *s2)
233:               {
234:                  char *sc1, *sc2;
235:               
236:                  for (sc1 = s1; *sc1 != 0; sc1++)
237:                     for (sc2 = s2; *sc2 != 0; sc2++)
238:                        if (*sc1 == *sc2)
239:                           return(sc1);
240:                  return(0);
241:               }
242:               
243:               
244:               /* standard template: char *strrchr(const char *s, int c).
245:                  Finds last occurrence of c in s */
246:               
247:               char *strrchr(char *s, unsigned int8 c)
248:               {
249:                  char *p;
250:               
251:                  for (p = 0; ; s++)
252:                  {
253:                     if (*s == c)
254:                        p = s;
255:                     if (*s == '\0')
256:                        return(p);
257:                  }
258:               }
259:               /* computes length of max initial segment of s1 consisting
260:                  entirely of characters from s2 */
261:               
262:               unsigned int8  strspn(char *s1, char *s2)
263:               {
264:                  char *sc1, *sc2;
265:               
266:                  for (sc1 = s1; *sc1 != 0; sc1++)
267:                     for (sc2 = s2; ; sc2++)
268:                   if (*sc2 == '\0')
269:                      return(sc1 - s1);
270:                        else if (*sc1 == *sc2)
271:                           break;
272:                  return(sc1 - s1);
273:               }
274:               /* standard template:
275:                  char *strstr(const char *s1, const char *s2);
276:                  Locates first occurence of character sequence s2 in s1;
277:                  returns 0 if s2 is empty string
278:               
279:                  Uncomment #define FASTER_BUT_MORE_ROM at the top of the
280:                  file to use the faster algorithm */
281:               char *strstr(char *s1, char *s2)
282:               {
283:                  char *s, *t;
284:               
285:                  #ifdef FASTER_BUT_MORE_ROM
286:                  if (*s2 == '\0')
287:                        return(s1);
288:                  #endif
289:               
290:                  while (*s1)
291:                  {
292:                     for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
293:               
294:                     if (*t == '\0')
295:                        return s1;
296:                     ++s1;
297:                     #ifdef FASTER_BUT_MORE_ROM
298:                        while(*s1 != '\0' && *s1 != *s2)
299:                           ++s1;
300:                     #endif
301:                  }
302:                  return 0;
303:               }
304:               
305:               /* standard template: char *strtok(char *s1, const char *s2).
306:               
307:                  Finds next token in s1 delimited by a character from separator
308:                  string s2 (which can be different from call to call).  First call
309:                  starts at beginning of s1 searching for first character NOT
310:                  contained in s2; returns 0 if none is found.
311:                  If one is found, it is the start of first token (return value).
312:                  Function then searches from there for a character contained in s2.
313:                  If none is found, current token extends to end of s1, and subsequent
314:                  searches for a token will return 0.  If one is found, it is
315:                  overwritten by '\0', which terminates current token.  Function saves
316:                  pointer to following character from which next search will start.
317:                  Each subsequent call, with 0 as first argument, starts searching
318:                  from saved pointer */
319:               
320:               char *strtok(char *s1, char *s2)
321:               {
322:                  char *beg, *end;
323:                  static char *save;
  2F16  EF2878     clr.w 0x0878
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\Chime.c  -------------------------
1:                 #include "includes.h"
2:                 
3:                 #int_TIMER3
4:                 void TIMER3_isr(void)
5:                 {
  0470  F80042     push.w 0x0042
  0472  F80036     push.w 0x0036
  0474  781F80     mov.w 0x0000,[0x001e++]
  0476  200020     mov.w #0x2,0x0000
  0478  09000C     repeat #12
  047A  781FB0     mov.w [0x0000++],[0x001e++]
6:                 	PWM2L = ChimePattern[chimeState];
  047C  A921C8     bclr.b 0x01c8,#1
  047E  BFC8AF     mov.b 0x08af,0x0000
  0480  780280     mov.w 0x0000,0x000a
  0482  FB0285     se 0x000a,0x000a
  0484  780005     mov.w 0x000a,0x0000
  0486  208BC1     mov.w #0x8bc,0x0002
  0488  02045E     call 0x00045e
  048C  A60000     btss 0x0000,#0
  048E  370001     bra 0x000492
  0490  A821C8     bset.b 0x01c8,#1
7:                 	++chimeState %= CHIMESIZE;
  0492  EC68AF     inc.b 0x08af
  0494  BFC8AF     mov.b 0x08af,0x0000
  0496  EF6001     clr.b 0x0001
  0498  EF6001     clr.b 0x0001
  049A  2000E4     mov.w #0xe,0x0008
  049C  FB0000     se 0x0000,0x0000
  049E  090011     repeat #17
  04A0  D80004     div.sw 0x0000,0x0008
  04A2  784001     mov.b 0x0002,0x0000
  04A4  B7E8AF     mov.b 0x0000,0x08af
8:                 }
9:                 
  04A6  A9E084     bclr.b 0x0084,#7
  04A8  2001A0     mov.w #0x1a,0x0000
  04AA  09000C     repeat #12
  04AC  78104F     mov.w [--0x001e],[0x0000--]
  04AE  78004F     mov.w [--0x001e],0x0000
  04B0  F90036     pop.w 0x0036
  04B2  F90042     pop.w 0x0042
  04B4  064000     retfie
10:                void initChime()
11:                {
12:                	//TMR3 INIT
13:                	TMR3 = 0;
  0C22  EF210A     clr.w 0x010a
14:                	PR3  = TMR3_BASE;
  0C24  210F84     mov.w #0x10f8,0x0008
  0C26  880874     mov.w 0x0008,0x010e
15:                	T3CON = INITIAL_T3CON;
  0C28  280304     mov.w #0x8030,0x0008
  0C2A  880894     mov.w 0x0008,0x0112
16:                	
17:                	//PWM INIT
18:                	PTCKPS0 = 0;
  0C2C  A941C0     bclr.b 0x01c0,#2
19:                	PTCKPS1 = 0;
  0C2E  A961C0     bclr.b 0x01c0,#3
20:                	//		
21:                	PTPER = CHIME_FREQ_PERIOD;
  0C30  238944     mov.w #0x3894,0x0008
  0C32  880E24     mov.w 0x0008,0x01c4
22:                	PDC2  = CHIME_ON_TIME;
  0C34  21C4A4     mov.w #0x1c4a,0x0008
  0C36  880EC4     mov.w 0x0008,0x01d8
23:                	
24:                	PWM2L = 0;
  0C38  A921C8     bclr.b 0x01c8,#1
25:                	PTEN = 1;
  0C3A  A8E1C1     bset.b 0x01c1,#7
26:                	
27:                }
  0C3C  060000     return
28:                
29:                void setChime(int1 enableChime)			
30:                {
31:                	chimeOn = enableChime;
  153C  A96885     bclr.b 0x0885,#3
  153E  AF098E     btsc.b 0x098e,#0
  1540  A86885     bset.b 0x0885,#3
32:                	
33:                	if(enableChime)
  1542  E2498E     cp0.b 0x098e
  1544  320004     bra z, 0x00154e
34:                	{
35:                		chimeState = 0;
  1546  EF68AF     clr.b 0x08af
36:                		TMR3 = 0;
  1548  EF210A     clr.w 0x010a
37:                		enable_interrupts(INT_TIMER3);
  154A  A8E08C     bset.b 0x008c,#7
38:                	}
39:                	else {
  154C  370002     bra 0x001552
40:                		disable_interrupts(INT_TIMER3);
  154E  A9E08C     bclr.b 0x008c,#7
41:                        PWM2L = false;
  1550  A921C8     bclr.b 0x01c8,#1
42:                	}
43:                
44:                }
  1552  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\Chime.h  -------------------------
1:                 #ifndef __CHIME__
2:                 #define __CHIME__
3:                 
4:                 //TIMER3 DECLARATIONS
5:                 #word TMR3	= 0x010A
6:                 #word PR3	= 0x010E
7:                 #word T3CON	= 0x0112
8:                 
9:                 #bit TMR3TON	= T3CON.15
10:                #bit TMR3TSIDL	= T3CON.13
11:                #bit TMR3TGATE	= T3CON.6
12:                #bit TMR3TCKPS1	= T3CON.5
13:                #bit TMR3TCKPS0	= T3CON.4
14:                #bit TMR3TCS	= T3CON.1
15:                
16:                //PWM DECLARATIONS
17:                #word PTCON		= 0x01C0
18:                #word PTMR		= 0x01C2
19:                #word PTPER		= 0x01C4
20:                #word PWMCON1 	= 0x01C8
21:                #word PDC1		= 0x01D6
22:                #word PDC2		= 0x01D8
23:                
24:                #bit  PTEN  = PTCON.15
25:                #bit  PWM1H = PWMCON1.4
26:                #bit  PWM1L = PWMCON1.0
27:                #bit  PWM2L = PWMCON1.1
28:                #bit  PTCKPS0 = PTCON.2
29:                #bit  PTCKPS1 = PTCON.3
30:                
31:                
32:                #define INITIAL_T3CON 0x8030
33:                #define TMR3_BASE (0x87C6 / 8)		// 300 ms * 118.6622 MHz / 4 / 256
34:                
35:                #define CHIMESIZE 14
36:                
37:                #define TONE_COUNT 1
38:                #define MIN_VOLUME 1
39:                #define MAX_VOLUME 100
40:                
41:                int1 ChimePattern[] = {1,0,1,0,1,0,1,0,0,0,0,0,0,0};
  2F84  200554     mov.w #0x55,0x0008
  2F86  8845E4     mov.w 0x0008,0x08bc
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\LCDDriver.c  ---------------------
1:                 #include "includes.h"
2:                 
3:                 void initLCD()
4:                 {
5:                                                                         /* Power on the LCD.                        */
6:                     output_low(SHDN_5V);
  0B74  A902C7     bclr.b 0x02c7,#0
  0B76  A902CB     bclr.b 0x02cb,#0
7:                     
8:                     //output_high(SHDN_5V);                               /* Disable LCD (DEBUG)                      */
9:                     
10:                    delay_ms(500);
  0B78  201F40     mov.w #0x1f4,0x0000
  0B7A  020AEC     call 0x000aec
11:                    enableLCD = true;
  0B7E  A88885     bset.b 0x0885,#4
12:                    
13:                	//Init LCD IO
14:                	output_high(STB);
  0B80  A9A2D8     bclr.b 0x02d8,#5
  0B82  A8A2DC     bset.b 0x02dc,#5
15:                	output_high(SCK);
  0B84  A962D8     bclr.b 0x02d8,#3
  0B86  A862DC     bset.b 0x02dc,#3
16:                	output_high(SISO);
  0B88  A982D8     bclr.b 0x02d8,#4
  0B8A  A882DC     bset.b 0x02dc,#4
17:                	
18:                	delay_us(1);
  0B8C  09001B     repeat #27
  0B8E  000000     nop
19:                	writeToLCD(LCD_WRITE_CFG,LCD_FCT_DFT|LCD_FCT_25);
  0B90  B3CF80     mov.b #0xf8,0x0000
  0B92  B7E9B4     mov.b 0x0000,0x09b4
  0B94  B3C2B0     mov.b #0x2b,0x0000
  0B96  B7E9B5     mov.b 0x0000,0x09b5
  0B98  020B2C     call 0x000b2c
20:                    delay_us(1);
  0B9C  09001B     repeat #27
  0B9E  000000     nop
21:                	writeToLCD(LCD_WRITE_CFG,LCD_CLEAR); //CLEAR LCD
  0BA0  B3CF80     mov.b #0xf8,0x0000
  0BA2  B7E9B4     mov.b 0x0000,0x09b4
  0BA4  B3C010     mov.b #0x1,0x0000
  0BA6  B7E9B5     mov.b 0x0000,0x09b5
  0BA8  020B2C     call 0x000b2c
22:                	delay_ms(40);
  0BAC  200280     mov.w #0x28,0x0000
  0BAE  020AEC     call 0x000aec
23:                	writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM); //SET CURSOR TO HOME 
  0BB2  B3CF80     mov.b #0xf8,0x0000
  0BB4  B7E9B4     mov.b 0x0000,0x09b4
  0BB6  B3C020     mov.b #0x2,0x0000
  0BB8  B7E9B5     mov.b 0x0000,0x09b5
  0BBA  020B2C     call 0x000b2c
24:                	//delay_us(1);
25:                	//writeToLCD(LCD_WRITE_CFG,LCD_CSR_BHV);
26:                	delay_us(1);
  0BBE  09001B     repeat #27
  0BC0  000000     nop
27:                	writeToLCD(LCD_WRITE_CFG,LCD_EMS_DFLT); //SET DEFAULT ENTRY MODE
  0BC2  B3CF80     mov.b #0xf8,0x0000
  0BC4  B7E9B4     mov.b 0x0000,0x09b4
  0BC6  B3C060     mov.b #0x6,0x0000
  0BC8  B7E9B5     mov.b 0x0000,0x09b5
  0BCA  020B2C     call 0x000b2c
28:                	delay_us(1);
  0BCE  09001B     repeat #27
  0BD0  000000     nop
29:                	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_BOFF); //SET DISPLAY 
  0BD2  B3CF80     mov.b #0xf8,0x0000
  0BD4  B7E9B4     mov.b 0x0000,0x09b4
  0BD6  B3C0C0     mov.b #0xc,0x0000
  0BD8  B7E9B5     mov.b 0x0000,0x09b5
  0BDA  020B2C     call 0x000b2c
30:                	delay_us(1);
  0BDE  09001B     repeat #27
  0BE0  000000     nop
31:                	writeToLCD(LCD_WRITE_CFG,LCD_ADDR_SET);  //SET ADDR to 0x00
  0BE2  B3CF80     mov.b #0xf8,0x0000
  0BE4  B7E9B4     mov.b 0x0000,0x09b4
  0BE6  B3C800     mov.b #0x80,0x0000
  0BE8  B7E9B5     mov.b 0x0000,0x09b5
  0BEA  020B2C     call 0x000b2c
32:                	
33:                	delay_us(1);
  0BEE  09001B     repeat #27
  0BF0  000000     nop
34:                
35:                	int i;
36:                
37:                	//Clear LCD DDRAM
38:                	writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM);
  0BF2  B3CF80     mov.b #0xf8,0x0000
  0BF4  B7E9B4     mov.b 0x0000,0x09b4
  0BF6  B3C020     mov.b #0x2,0x0000
  0BF8  B7E9B5     mov.b 0x0000,0x09b5
  0BFA  020B2C     call 0x000b2c
39:                	for (i = 0 ; i < 0xFF ; i++)
  0BFE  EF297E     clr.w 0x097e
  0C00  804BF4     mov.w 0x097e,0x0008
  0C02  200FF3     mov.w #0xff,0x0006
  0C04  E11804     cp.w 0x0006,0x0008
  0C06  34000A     bra les, 0x000c1c
40:                	{
41:                		writeToLCD(LCD_WRITE_MEM, ' ');
  0C08  B3CFA0     mov.b #0xfa,0x0000
  0C0A  B7E9B4     mov.b 0x0000,0x09b4
  0C0C  B3C200     mov.b #0x20,0x0000
  0C0E  B7E9B5     mov.b 0x0000,0x09b5
  0C10  020B2C     call 0x000b2c
42:                		delay_us(5);
  0C14  090092     repeat #146
  0C16  000000     nop
43:                	}
  0C18  EC297E     inc.w 0x097e
  0C1A  37FFF2     bra 0x000c00
44:                
45:                	clearLCDLines();
  0C1C  020B4E     call 0x000b4e
46:                }
  0C20  060000     return
47:                
48:                void shutdownLCD(void)
49:                {
50:                    enableLCD = false;
  1BF2  A98885     bclr.b 0x0885,#4
51:                    output_high(SHDN_5V);
  1BF4  A902C7     bclr.b 0x02c7,#0
  1BF6  A802CB     bset.b 0x02cb,#0
52:                    delay_ms(500);
  1BF8  201F40     mov.w #0x1f4,0x0000
  1BFA  020AEC     call 0x000aec
53:                }
  1BFE  060000     return
54:                
55:                void writeToLCD(byte MSB, byte LSB)
56:                {
57:                	output_low(STB);
  0B2C  A9A2D8     bclr.b 0x02d8,#5
  0B2E  A9A2DC     bclr.b 0x02dc,#5
58:                	delay_cycles(STB_L_HOLDTIME);
  0B30  09009E     repeat #158
  0B32  000000     nop
59:                	writeByte(MSB);
  0B34  BFC9B4     mov.b 0x09b4,0x0000
  0B36  B7E9B8     mov.b 0x0000,0x09b8
  0B38  020B00     call 0x000b00
60:                	writeByte(LSB);
  0B3C  BFC9B5     mov.b 0x09b5,0x0000
  0B3E  B7E9B8     mov.b 0x0000,0x09b8
  0B40  020B00     call 0x000b00
61:                	delay_cycles(STB_H_HOLDTIME);
  0B44  090256     repeat #598
  0B46  000000     nop
62:                	output_high(STB);
  0B48  A9A2D8     bclr.b 0x02d8,#5
  0B4A  A8A2DC     bset.b 0x02dc,#5
63:                }
  0B4C  060000     return
64:                
65:                void writeByte(byte b)
66:                {
67:                	int i;
68:                	//Most significant bit first
69:                	for (i = 0 ; i < 8 ; i++)
  0B00  EF29BA     clr.w 0x09ba
  0B02  804DD4     mov.w 0x09ba,0x0008
  0B04  E12068     cp.w 0x0008,#8
  0B06  3D0011     bra ges, 0x000b2a
70:                	{
71:                		output_low(SCK);
  0B08  A962D8     bclr.b 0x02d8,#3
  0B0A  A962DC     bclr.b 0x02dc,#3
72:                		output_bit(SISO,shift_left(&b,1,0));
  0B0C  A90042     bclr.b 0x0042,#0
  0B0E  D6E9B8     rlc.b 0x09b8
  0B10  310002     bra c, 0x000b16
  0B12  A982DC     bclr.b 0x02dc,#4
  0B14  370001     bra 0x000b18
  0B16  A882DC     bset.b 0x02dc,#4
  0B18  A982D8     bclr.b 0x02d8,#4
73:                		delay_cycles(SCK_L_HOLDTIME);
  0B1A  09013E     repeat #318
  0B1C  000000     nop
74:                		output_high(SCK);
  0B1E  A962D8     bclr.b 0x02d8,#3
  0B20  A862DC     bset.b 0x02dc,#3
75:                		delay_cycles(SCK_H_HOLDTIME);
  0B22  09013E     repeat #318
  0B24  000000     nop
76:                	}
  0B26  EC29BA     inc.w 0x09ba
  0B28  37FFEC     bra 0x000b02
77:                }
  0B2A  060000     return
78:                
79:                void writeToDDRAM(byte *arrayPtr, byte arraySize)
80:                {
  1D56  781F85     mov.w 0x000a,[0x001e++]
81:                	//byte testByte;
82:                	
83:                	//output_low(STB);
84:                	//delay_cycles(STB_L_HOLDTIME);
85:                	//writeByte(LCD_WRITE_MEM);
86:                	while(arraySize--)
87:                     {
  1D58  BFC9AE     mov.b 0x09ae,0x0000
  1D5A  ED69AE     dec.b 0x09ae
  1D5C  E00400     cp0.b 0x0000
  1D5E  32000A     bra z, 0x001d74
88:                 		writeToLCD(LCD_WRITE_MEM,*arrayPtr);
  1D60  804D60     mov.w 0x09ac,0x0000
  1D62  784290     mov.b [0x0000],0x000a
  1D64  B3CFA0     mov.b #0xfa,0x0000
  1D66  B7E9B4     mov.b 0x0000,0x09b4
  1D68  784005     mov.b 0x000a,0x0000
  1D6A  B7E9B5     mov.b 0x0000,0x09b5
  1D6C  020B2C     call 0x000b2c
89:                		//delay_us(100);
90:                		arrayPtr++;
  1D70  EC29AC     inc.w 0x09ac
91:                     }
  1D72  37FFF2     bra 0x001d58
92:                	
93:                	//delay_cycles(STB_H_HOLDTIME);
94:                    //	output_high(STB);
95:                }
  1D74  7802CF     mov.w [--0x001e],0x000a
  1D76  060000     return
96:                
97:                void writeToDDRAM(byte b, byte arraySize)
98:                {
99:                	while(arraySize--)
100:                    {
  1D78  BFC9AD     mov.b 0x09ad,0x0000
  1D7A  ED69AD     dec.b 0x09ad
  1D7C  E00400     cp0.b 0x0000
  1D7E  320007     bra z, 0x001d8e
101:                		writeToLCD(LCD_WRITE_MEM,b);
  1D80  B3CFA0     mov.b #0xfa,0x0000
  1D82  B7E9B4     mov.b 0x0000,0x09b4
  1D84  BFC9AC     mov.b 0x09ac,0x0000
  1D86  B7E9B5     mov.b 0x0000,0x09b5
  1D88  020B2C     call 0x000b2c
102:                    }
  1D8C  37FFF5     bra 0x001d78
103:               }
  1D8E  060000     return
104:               
105:               void refreshLCD()
106:               {
107:                   if (enableLCD)
  1D90  AE8885     btss.b 0x0885,#4
  1D92  370017     bra 0x001dc2
108:                   {
109:                       writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM);
  1D94  B3CF80     mov.b #0xf8,0x0000
  1D96  B7E9B4     mov.b 0x0000,0x09b4
  1D98  B3C020     mov.b #0x2,0x0000
  1D9A  B7E9B5     mov.b 0x0000,0x09b5
  1D9C  020B2C     call 0x000b2c
110:                       writeToDDRAM(&LCD_Line1, LCD_LINE_SIZE);
  1DA0  B3C100     mov.b #0x10,0x0000
  1DA2  B7E9AE     mov.b 0x0000,0x09ae
  1DA4  208C04     mov.w #0x8c0,0x0008
  1DA6  884D64     mov.w 0x0008,0x09ac
  1DA8  021D56     call 0x001d56
111:                       writeToDDRAM(0, 24);	//Go to line2
  1DAC  EF69AC     clr.b 0x09ac
  1DAE  B3C180     mov.b #0x18,0x0000
  1DB0  B7E9AD     mov.b 0x0000,0x09ad
  1DB2  021D78     call 0x001d78
112:                       writeToDDRAM(&LCD_Line2, LCD_LINE_SIZE);
  1DB6  B3C100     mov.b #0x10,0x0000
  1DB8  B7E9AE     mov.b 0x0000,0x09ae
  1DBA  208D04     mov.w #0x8d0,0x0008
  1DBC  884D64     mov.w 0x0008,0x09ac
  1DBE  021D56     call 0x001d56
113:                   }
114:               }
  1DC2  060000     return
115:               
116:               void clearLCDLines()
117:               {
  0B4E  781F85     mov.w 0x000a,[0x001e++]
118:               	//initialize LCD lines
119:               	int i;
120:               	for (i = 0 ; i < LCD_LINE_SIZE ; i++)
  0B50  EF29AC     clr.w 0x09ac
  0B52  804D64     mov.w 0x09ac,0x0008
  0B54  E12070     cp.w 0x0008,#16
  0B56  3D000C     bra ges, 0x000b70
121:               	{
122:               		LCD_Line1[i] = ' ';
  0B58  208C04     mov.w #0x8c0,0x0008
  0B5A  804D63     mov.w 0x09ac,0x0006
  0B5C  418284     add.w 0x0006,0x0008,0x000a
  0B5E  B3C200     mov.b #0x20,0x0000
  0B60  784A80     mov.b 0x0000,[0x000a]
123:               		LCD_Line2[i] = ' ';
  0B62  208D04     mov.w #0x8d0,0x0008
  0B64  804D63     mov.w 0x09ac,0x0006
  0B66  418284     add.w 0x0006,0x0008,0x000a
  0B68  B3C200     mov.b #0x20,0x0000
  0B6A  784A80     mov.b 0x0000,[0x000a]
124:               	}
  0B6C  EC29AC     inc.w 0x09ac
  0B6E  37FFF1     bra 0x000b52
125:               }
  0B70  7802CF     mov.w [--0x001e],0x000a
  0B72  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\LoadControl.c  -------------------
1:                 #include "includes.h"
2:                 
3:                 //#define timeArraySize 1
4:                 #define PHASE_STATS_SIZE 16
5:                 
6:                 //int1  firstRun = true;
7:                 //int16 phaseStats [PHASE_STATS_SIZE];
8:                 int8  phaseStatsIndex     = 0;
9:                 int1  previousSyncSatus   = 0;
10:                int16 syncTransitions     = 0;
11:                int1  currentSyncStatus   = 0;
12:                int1  pushButtonStates[3] = {0, 0, 0};
  2FE2  EF2967     clr.w 0x0967
13:                int1  pushAck             = false;
14:                int1  pushLongAck         = false;
15:                
16:                //int16 highTime[timeArraySize];
17:                //int16 lowTime[timeArraySize];
18:                
19:                //int16 highTime;
20:                //int16 lowTime;
21:                
22:                //int16 lowTimeMon = 0;
23:                //int16 highTimeMon = 0;
24:                
25:                //int8 highTimeIndex = 0;
26:                //int8 lowTimeIndex = 0;
27:                
28:                //int32 highTimeSum = 0;
29:                //int32 lowTimeSum = 0;
30:                
31:                WORD_VAL highTimeLocal;
32:                WORD_VAL  lowTimeLocal;
33:                
34:                //const int16 PowerLUT[11] = 	{35075, 42970, 45310, 47156,
35:                //48764, 50307, 51842, 53461, 55293, 57650, 65535};
36:                						 
37:                #define DEFAULT_PULSE_PHASE_OFFSET  0
38:                #define DEFAULT_PULSE_WIDTH_DEFAULT 93                  /* 25 us.                               */
39:                
40:                #define PHASE_WAIT 0
41:                #define PULSE_WAIT 1
42:                
43:                int1 pulseState = PHASE_WAIT;
44:                
45:                /*
46:                 unsigned int16 pulseWidth  = PMW_PULSE_WIDTH_DEFAULT;
47:                 unsigned int16 phaseOffset = PWM_PULSE_PHASE_OFFSET;
48:                */
49:                static   float  light_t_on = 0.0f;                      /* 0 to 8.6 ms scale.						*/
50:                unsigned long   light_on_time;
51:                         float  light_power;                            /* 0 to 1 scale.							*/
52:                						 
53:                /*
54:                 *****************************************************************************************************
55:                 *                                              CNI_isr()
56:                 *****************************************************************************************************
57:                 *
58:                 * Description  : Provides reference for the Zero-Crossing of the AC sector signal.
59:                 *
60:                 * Arguments    : none.
61:                 * 
62:                 * Caller       : External Interrupt.
63:                 *
64:                 * Returns      : none.
65:                 * 
66:                 * Notes        : (1)   currentSyncStatus provides status on AC phase location:
67:                 *                          LOW     Enters Zero-Crossing
68:                 *                          HIGH    Leaves Zero-Crossing
69:                 *
70:                 *                (2)   If 
71:                 *****************************************************************************************************
72:                 */ 
73:                #int_CNI HIGH
74:                void  CNI_isr(void) 
75:                {
  031E  F80042     push.w 0x0042
  0320  F80036     push.w 0x0036
  0322  781F80     mov.w 0x0000,[0x001e++]
  0324  200020     mov.w #0x2,0x0000
  0326  09000C     repeat #12
  0328  781FB0     mov.w [0x0000++],[0x001e++]
76:                	currentSyncStatus = input(SYNC);
  032A  A862C6     bset.b 0x02c6,#3
  032C  A90966     bclr.b 0x0966,#0
  032E  AF62C8     btsc.b 0x02c8,#3
  0330  A80966     bset.b 0x0966,#0
77:                	
78:                	//Load Control
79:                	pulseState = PHASE_WAIT;                            /* TODO: Depricate pulseState           */
  0332  A96966     bclr.b 0x0966,#3
80:                                                                        /* Setup TMR4 & PR4 to wait for trigg.  */
81:                    TMR4 = 0;
  0334  EF2114     clr.w 0x0114
82:                	PR4  = LoadStruct.PhaseOffset;
  0336  F808E2     push.w 0x08e2
  0338  F9011A     pop.w 0x011a
83:                    
84:                    TMR4IntrCnt2++;
  033A  EC28EA     inc.w 0x08ea
85:                    
86:                    if(currentSyncStatus) {
  033C  AE0966     btss.b 0x0966,#0
  033E  370003     bra 0x000346
87:                        LoadStruct.LoadState = LS_OFF_WAIT_TURN_ON;
  0340  B3C010     mov.b #0x1,0x0000
  0342  B7E8E6     mov.b 0x0000,0x08e6
88:                        enable_interrupts(INT_TIMER4);
  0344  A8A08E     bset.b 0x008e,#5
89:                	} 
90:                    //else {
91:                    //    TurnTriacOff();
92:                    //}
93:                
94:                                                                        /* Evaluate Pushbutton state.           */
95:                    pushButtonStates[2] = pushButtonStates[1];
  0346  A94967     bclr.b 0x0967,#2
  0348  AF2967     btsc.b 0x0967,#1
  034A  A84967     bset.b 0x0967,#2
96:                    pushButtonStates[1] = pushButtonStates[0];
  034C  A92967     bclr.b 0x0967,#1
  034E  AF0967     btsc.b 0x0967,#0
  0350  A82967     bset.b 0x0967,#1
97:                    pushButtonStates[0] = input(PUSH);
  0352  A842C6     bset.b 0x02c6,#2
  0354  A90967     bclr.b 0x0967,#0
  0356  AF42C8     btsc.b 0x02c8,#2
  0358  A80967     bset.b 0x0967,#0
98:                    
99:                    if ((pushButtonStates[0] == false) && 
100:                       (pushButtonStates[1] == false) && 
101:                       (pushButtonStates[2] == true)) {                /* On push up.                          */
  035A  AF0967     btsc.b 0x0967,#0
  035C  370018     bra 0x00038e
  035E  AF2967     btsc.b 0x0967,#1
  0360  370016     bra 0x00038e
  0362  AE4967     btss.b 0x0967,#2
  0364  370014     bra 0x00038e
102:                   
103:                       if (alarmData.ButtonDownTick >= RTCC_STANDBY_TIMEOUT) {
  0366  8043A4     mov.w 0x0874,0x0008
  0368  E12060     cp.w 0x0008,#0
  036A  390008     bra nc, 0x00037c
  036C  3E0004     bra gtu, 0x000376
  036E  804394     mov.w 0x0872,0x0008
  0370  200B43     mov.w #0xb4,0x0006
  0372  E11804     cp.w 0x0006,0x0008
  0374  3E0003     bra gtu, 0x00037c
104:                           pushLongAck = true;
  0376  A84966     bset.b 0x0966,#2
105:                           pushAck     = false;
  0378  A92966     bclr.b 0x0966,#1
106:                       } else {
  037A  370004     bra 0x000384
107:                           pushLongAck = false;
  037C  A94966     bclr.b 0x0966,#2
108:                           pushAck     = true;
  037E  A82966     bset.b 0x0966,#1
109:                           alarmData.ButtonDownTick = 0;
  0380  EF2872     clr.w 0x0872
  0382  EF2874     clr.w 0x0874
110:                       }
111:                       lastUserPush = alarmData.CurrentBinaryTime;
  0384  F80866     push.w 0x0866
  0386  F9095E     pop.w 0x095e
  0388  F80868     push.w 0x0868
  038A  F90960     pop.w 0x0960
112:                       
113:                   } else if ((pushButtonStates[0] == true) && 
  038C  370009     bra 0x0003a0
114:                              (pushButtonStates[1] == true) && 
115:                              (pushButtonStates[2] == true)) {
  038E  AE0967     btss.b 0x0967,#0
  0390  370007     bra 0x0003a0
  0392  AE2967     btss.b 0x0967,#1
  0394  370005     bra 0x0003a0
  0396  AE4967     btss.b 0x0967,#2
  0398  370003     bra 0x0003a0
116:                       
117:                       alarmData.ButtonDownTick++;
  039A  EC2872     inc.w 0x0872
  039C  AF2042     btsc.b 0x0042,#1
  039E  EC2874     inc.w 0x0874
118:                       
119:                   }
120:               	
121:               	phaseStatsIndex = (++phaseStatsIndex)%PHASE_STATS_SIZE;
  03A0  EC6927     inc.b 0x0927
  03A2  BFC927     mov.b 0x0927,0x0000
  03A4  EF6001     clr.b 0x0001
  03A6  EF6001     clr.b 0x0001
  03A8  200104     mov.w #0x10,0x0008
  03AA  FB0000     se 0x0000,0x0000
  03AC  090011     repeat #17
  03AE  D80004     div.sw 0x0000,0x0008
  03B0  784001     mov.b 0x0002,0x0000
  03B2  B7E927     mov.b 0x0000,0x0927
122:               
123:               }
124:               
  03B4  A9E085     bclr.b 0x0085,#7
  03B6  2001A0     mov.w #0x1a,0x0000
  03B8  09000C     repeat #12
  03BA  78104F     mov.w [--0x001e],[0x0000--]
  03BC  78004F     mov.w [--0x001e],0x0000
  03BE  F90036     pop.w 0x0036
  03C0  F90042     pop.w 0x0042
  03C2  064000     retfie
125:               #int_TIMER4 HIGH
126:               void TIMER4_isr(void)
127:               {
  03FC  F80042     push.w 0x0042
  03FE  F80036     push.w 0x0036
  0400  781F80     mov.w 0x0000,[0x001e++]
  0402  200020     mov.w #0x2,0x0000
  0404  09000C     repeat #12
  0406  781FB0     mov.w [0x0000++],[0x001e++]
128:                   TMR4IntrCnt1++;
  0408  EC28E8     inc.w 0x08e8
129:                   
130:                   switch (LoadStruct.LoadState) {
  040A  BFC8E6     mov.b 0x08e6,0x0000
  040C  EF6001     clr.b 0x0001
  040E  B28000     xor.w #0x0,0x0000
  0410  320007     bra z, 0x000420
  0412  B28010     xor.w #0x1,0x0000
  0414  320007     bra z, 0x000424
  0416  B28030     xor.w #0x3,0x0000
  0418  32000D     bra z, 0x000434
  041A  B28010     xor.w #0x1,0x0000
  041C  320017     bra z, 0x00044c
  041E  370017     bra 0x00044e
131:                       case LS_OFF:
132:                           disable_interrupts(INT_TIMER4);
  0420  A9A08E     bclr.b 0x008e,#5
133:                           break;
  0422  370015     bra 0x00044e
134:                       case LS_OFF_WAIT_TURN_ON:
135:                           PR4  = LoadStruct.PulseWidth;               
  0424  F808E4     push.w 0x08e4
  0426  F9011A     pop.w 0x011a
136:                           TMR2 = 0;
  0428  EF2106     clr.w 0x0106
137:                           TurnTriacOn();;                      /* Turn Triac On.                           */
  042A  0203CA     call 0x0003ca
138:                           LoadStruct.LoadState = LS_ON;               /* Change LoadState to LS_ON.               */
  042E  B3C020     mov.b #0x2,0x0000
  0430  B7E8E6     mov.b 0x0000,0x08e6
139:                           break;
  0432  37000D     bra 0x00044e
140:                       case LS_ON:
141:                           if (TMR2 >= RTCC_PW_TH_MAX) {
  0434  800834     mov.w 0x0106,0x0008
  0436  200673     mov.w #0x67,0x0006
  0438  E11804     cp.w 0x0006,0x0008
  043A  3E0003     bra gtu, 0x000442
142:                               alarmData.PulseWidthErr++;
  043C  EC286E     inc.w 0x086e
  043E  AF2042     btsc.b 0x0042,#1
  0440  EC2870     inc.w 0x0870
143:                           }
144:                           TurnTriacOff();                     /* Turn Triac Off.                          */
  0442  0203E6     call 0x0003e6
145:                           LoadStruct.LoadState = LS_OFF_WAIT_ZERO_X;  /* Change LoadState to LS_OFF_WAIT_ZERO_X.  */
  0446  B3C030     mov.b #0x3,0x0000
  0448  B7E8E6     mov.b 0x0000,0x08e6
146:                           break;
  044A  370001     bra 0x00044e
147:                       case LS_OFF_WAIT_ZERO_X:
148:                           break;
  044C  370000     bra 0x00044e
149:                   }
150:               }
151:               
152:               /*
153:                *****************************************************************************************************
154:                *                                              InitRTCC()
155:                *****************************************************************************************************
156:                *
157:                * Description : Initialize the output load controller.
158:                *
159:                * Arguments   : none.
160:                * 
161:                * Caller      : main().
162:                *
163:                * Returns     : none.
164:                * 
165:                * Notes       : none.
166:                *****************************************************************************************************
167:                */ 
  044E  A9A086     bclr.b 0x0086,#5
  0450  2001A0     mov.w #0x1a,0x0000
  0452  09000C     repeat #12
  0454  78104F     mov.w [--0x001e],[0x0000--]
  0456  78004F     mov.w [--0x001e],0x0000
  0458  F90036     pop.w 0x0036
  045A  F90042     pop.w 0x0042
  045C  064000     retfie
168:               void InitLoadControl(void)
169:               {
170:                   TurnTriacOff();                                     /* Turn Triac Off.                          */
  0850  F80042     push.w 0x0042
  0852  EFE042     setm.b 0x0042
  0854  0203E6     call 0x0003e6
  0858  F90042     pop.w 0x0042
171:                                                                       /* Init. TimeLocal vars for phase stats.    */
172:               	lowTimeLocal.Val = 0;
  085A  EF296A     clr.w 0x096a
173:               	highTimeLocal.Val = 0;
  085C  EF2968     clr.w 0x0968
174:                                                                       /* Enable interrupt on change.              */
175:               	CN5IE = true;
  085E  A8A0C0     bset.b 0x00c0,#5
176:                                                                       /* Disable pin pull-up.                     */
177:               	CN5PUE = false;
  0860  A9A0C4     bclr.b 0x00c4,#5
178:               
179:               	setup_timer2(TMR_INTERNAL |TMR_DIV_BY_8 , 0xFFFF);
  0862  EF2110     clr.w 0x0110
  0864  EFA10C     setm.w 0x010c
  0866  2A0104     mov.w #0xa010,0x0008
  0868  880884     mov.w 0x0008,0x0110
180:               	
181:                                                                       /* Init TMR4 with lowest freq. possible.    */
182:               	TMR4  = 0;
  086A  EF2114     clr.w 0x0114
183:               	PR4   = 0xFFFF;
  086C  EFA11A     setm.w 0x011a
184:               	T4CON = T4CON_INIT;
  086E  280104     mov.w #0x8010,0x0008
  0870  8808F4     mov.w 0x0008,0x011e
185:                   
186:                   TMR2  = TMR4;
  0872  F80114     push.w 0x0114
  0874  F90106     pop.w 0x0106
187:                   PR2   = 0xFFFF;
  0876  EFA10C     setm.w 0x010c
188:                   T2CON = T4CON_INIT;
  0878  280104     mov.w #0x8010,0x0008
  087A  880884     mov.w 0x0008,0x0110
189:                   
190:                   LoadStruct.PhaseOffset = DEFAULT_PULSE_PHASE_OFFSET;
  087C  EF28E2     clr.w 0x08e2
191:                   LoadStruct.PulseWidth  = DEFAULT_PULSE_WIDTH_DEFAULT;
  087E  2005D4     mov.w #0x5d,0x0008
  0880  884724     mov.w 0x0008,0x08e4
192:                   LoadStruct.LoadState   = LS_OFF;
  0882  EF68E6     clr.b 0x08e6
193:                   LoadStruct.TriacState  = false;
  0884  A908E7     bclr.b 0x08e7,#0
194:               }
  0886  060000     return
195:               
196:               void CalculateLuminosity()
197:               {
  1678  781F85     mov.w 0x000a,[0x001e++]
  167A  781F86     mov.w 0x000c,[0x001e++]
198:                                                                       /* ---------- COMPUTE LIGHT POWER --------- */
199:                                                                       /* Check if light should be on              */
200:               	light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul;
  167C  804705     mov.w 0x08e0,0x000a
  167E  FB0285     se 0x000a,0x000a
  1680  EB0300     clr.w 0x000c
  1682  A7F005     btsc 0x000a,#15
  1684  EB8300     setm.w 0x000c
  1686  F80042     push.w 0x0042
  1688  EFE042     setm.b 0x0042
  168A  780005     mov.w 0x000a,0x0000
  168C  780086     mov.w 0x000c,0x0002
  168E  2003C2     mov.w #0x3c,0x0004
  1690  200003     mov.w #0x0,0x0006
  1692  02050A     call 0x00050a
  1696  F90042     pop.w 0x0042
  1698  8042F4     mov.w 0x085e,0x0008
  169A  520000     sub.w 0x0008,0x0000,0x0000
  169C  884B80     mov.w 0x0000,0x0970
  169E  804304     mov.w 0x0860,0x0008
  16A0  5A0001     subb.w 0x0008,0x0002,0x0000
  16A2  884B90     mov.w 0x0000,0x0972
201:               	
202:                   /* If the time is within the ramp section.	*/
203:               	if ((alarmData.CurrentBinaryTime >= light_on_time) &&
204:               	    (alarmData.CurrentBinaryTime <= alarmData.SnoozeBinaryTime)) {
  16A4  804B90     mov.w 0x0972,0x0000
  16A6  804344     mov.w 0x0868,0x0008
  16A8  E12000     cp.w 0x0008,0x0000
  16AA  39007C     bra nc, 0x0017a4
  16AC  3E0004     bra gtu, 0x0016b6
  16AE  804B80     mov.w 0x0970,0x0000
  16B0  804334     mov.w 0x0866,0x0008
  16B2  E12000     cp.w 0x0008,0x0000
  16B4  390077     bra nc, 0x0017a4
  16B6  804340     mov.w 0x0868,0x0000
  16B8  804304     mov.w 0x0860,0x0008
  16BA  E12000     cp.w 0x0008,0x0000
  16BC  390073     bra nc, 0x0017a4
  16BE  3E0004     bra gtu, 0x0016c8
  16C0  804330     mov.w 0x0866,0x0000
  16C2  8042F4     mov.w 0x085e,0x0008
  16C4  E12000     cp.w 0x0008,0x0000
  16C6  39006E     bra nc, 0x0017a4
205:                       
206:                                                                       /* Compute ramp location.					*/
207:                       light_power  = (float)(alarmData.CurrentBinaryTime - light_on_time);
  16C8  804334     mov.w 0x0866,0x0008
  16CA  804B83     mov.w 0x0970,0x0006
  16CC  520003     sub.w 0x0008,0x0006,0x0000
  16CE  804344     mov.w 0x0868,0x0008
  16D0  804B93     mov.w 0x0972,0x0006
  16D2  5A0083     subb.w 0x0008,0x0006,0x0002
  16D4  021554     call 0x001554
  16D8  884BA0     mov.w 0x0000,0x0974
  16DA  884BB1     mov.w 0x0002,0x0976
208:                       light_power /= 60.0;                            /* Ramp power.								*/
  16DC  804BA0     mov.w 0x0974,0x0000
  16DE  804BB1     mov.w 0x0976,0x0002
  16E0  200002     mov.w #0x0,0x0004
  16E2  242703     mov.w #0x4270,0x0006
  16E4  020C78     call 0x000c78
  16E8  884BA0     mov.w 0x0000,0x0974
  16EA  884BB1     mov.w 0x0002,0x0976
209:                       light_power /= (float)delayLoadLighting;
  16EC  BFC8E0     mov.b 0x08e0,0x0000
  16EE  FB0000     se 0x0000,0x0000
  16F0  020D42     call 0x000d42
  16F4  780100     mov.w 0x0000,0x0004
  16F6  780181     mov.w 0x0002,0x0006
  16F8  804BA0     mov.w 0x0974,0x0000
  16FA  804BB1     mov.w 0x0976,0x0002
  16FC  020C78     call 0x000c78
  1700  884BA0     mov.w 0x0000,0x0974
  1702  884BB1     mov.w 0x0002,0x0976
210:                       light_power *= (float)maxLoadLighting;          /* Adjust for user defined max power.       */
  1704  BFC8BF     mov.b 0x08bf,0x0000
  1706  FB0000     se 0x0000,0x0000
  1708  020D42     call 0x000d42
  170C  780100     mov.w 0x0000,0x0004
  170E  780181     mov.w 0x0002,0x0006
  1710  804BA0     mov.w 0x0974,0x0000
  1712  804BB1     mov.w 0x0976,0x0002
  1714  020FC0     call 0x000fc0
  1718  884BA0     mov.w 0x0000,0x0974
  171A  884BB1     mov.w 0x0002,0x0976
211:                       light_power /= 100.0f;
  171C  804BA0     mov.w 0x0974,0x0000
  171E  804BB1     mov.w 0x0976,0x0002
  1720  200002     mov.w #0x0,0x0004
  1722  242C83     mov.w #0x42c8,0x0006
  1724  020C78     call 0x000c78
  1728  884BA0     mov.w 0x0000,0x0974
  172A  884BB1     mov.w 0x0002,0x0976
212:                                                                       /* Equivalent Triac On-Time.				*/
213:                       light_t_on = PowerToTimeOn(light_power);
  172C  F80974     push.w 0x0974
  172E  F9099A     pop.w 0x099a
  1730  F80976     push.w 0x0976
  1732  F9099C     pop.w 0x099c
  1734  02158C     call 0x00158c
  1738  884B60     mov.w 0x0000,0x096c
  173A  884B71     mov.w 0x0002,0x096e
214:                                                                       /* Delay in ms to sustain such On-Time.		*/
215:                       light_t_on = 8.3333333f - light_t_on;
  173C  A80043     bset.b 0x0043,#0
  173E  255550     mov.w #0x5555,0x0000
  1740  241051     mov.w #0x4105,0x0002
  1742  804B62     mov.w 0x096c,0x0004
  1744  804B73     mov.w 0x096e,0x0006
  1746  020E20     call 0x000e20
  174A  884B60     mov.w 0x0000,0x096c
  174C  884B71     mov.w 0x0002,0x096e
216:                   
217:                                                                       /* Convert Delay to PR4 Value where:        */
218:                                                                       /* ... fosc    = 118.6622 MHz               */
219:                                                                       /* ... TMR4scr = fosc / 4                   */
220:                                                                       /* ... TMR4scr =  29.6655 MHz               */
221:                                                                       /* ... TMR4tck = TMR4scr / 8                */
222:                                                                       /* ... TMR4tck =  3.708   MHz = 269.673 ns. */
223:                   
224:                                                                       /* PR4 max per = 8.333 ms (120 Hz)          */
225:                                                                       /* PR4 max per = 30901 ticks.               */
226:                       
227:                       
228:                       
229:                       if ((alarmData.CurrentBinaryTime - light_on_time) >= 10) {
  174E  804334     mov.w 0x0866,0x0008
  1750  804B83     mov.w 0x0970,0x0006
  1752  520283     sub.w 0x0008,0x0006,0x000a
  1754  804344     mov.w 0x0868,0x0008
  1756  804B93     mov.w 0x0972,0x0006
  1758  5A0303     subb.w 0x0008,0x0006,0x000c
  175A  E13060     cp.w 0x000c,#0
  175C  390023     bra nc, 0x0017a4
  175E  3E0002     bra gtu, 0x001764
  1760  E1286A     cp.w 0x000a,#10
  1762  390020     bra nc, 0x0017a4
230:                           if (light_t_on <= 0.0f) {                   /* Underflow.                               */
  1764  804B60     mov.w 0x096c,0x0000
  1766  804B71     mov.w 0x096e,0x0002
  1768  200002     mov.w #0x0,0x0004
  176A  200003     mov.w #0x0,0x0006
  176C  020D8C     call 0x000d8c
  1770  310001     bra c, 0x001774
  1772  3A0005     bra nz, 0x00177e
231:                               LoadStruct.PhaseOffset = LS_MAX_DELAY;
  1774  261A84     mov.w #0x61a8,0x0008
  1776  884714     mov.w 0x0008,0x08e2
232:                               LoadStruct.LoadState   = LS_OFF_WAIT_TURN_ON;
  1778  B3C010     mov.b #0x1,0x0000
  177A  B7E8E6     mov.b 0x0000,0x08e6
233:                           } else if (light_t_on > 8.33333f) {         /* Overflow.                                */
  177C  370013     bra 0x0017a4
  177E  255520     mov.w #0x5552,0x0000
  1780  241051     mov.w #0x4105,0x0002
  1782  804B62     mov.w 0x096c,0x0004
  1784  804B73     mov.w 0x096e,0x0006
  1786  020D8C     call 0x000d8c
  178A  390003     bra nc, 0x001792
234:                               LoadStruct.PhaseOffset = 10;            /* Always On.                               */
  178C  2000A4     mov.w #0xa,0x0008
  178E  884714     mov.w 0x0008,0x08e2
235:                           } else {
  1790  370009     bra 0x0017a4
236:                               LoadStruct.PhaseOffset = (unsigned int16)(light_t_on * 3708f);
  1792  804B60     mov.w 0x096c,0x0000
  1794  804B71     mov.w 0x096e,0x0002
  1796  2C0002     mov.w #0xc000,0x0004
  1798  245673     mov.w #0x4567,0x0006
  179A  020FC0     call 0x000fc0
  179E  020DF4     call 0x000df4
  17A2  884710     mov.w 0x0000,0x08e2
237:                           }
238:                       }
239:                   }
240:               }
  17A4  78034F     mov.w [--0x001e],0x000c
  17A6  7802CF     mov.w [--0x001e],0x000a
  17A8  060000     return
241:               
242:               
243:               /*
244:                *****************************************************************************************************
245:                *                                            SetLampIntensity()
246:                *****************************************************************************************************
247:                *
248:                * Description : Set the lamp intensity.
249:                *
250:                * Arguments   : intensity      Lamp intensity [0, 1]
251:                * 
252:                * Caller      : various.
253:                *
254:                * Returns     : none.
255:                * 
256:                * Notes       : none.
257:                *****************************************************************************************************
258:                */ 
259:               void SetLampIntensity(float intensity)
260:               {
  17AA  781F85     mov.w 0x000a,[0x001e++]
  17AC  781F86     mov.w 0x000c,[0x001e++]
  17AE  BFC8BF     mov.b 0x08bf,0x0000
  17B0  FB0000     se 0x0000,0x0000
  17B2  020D42     call 0x000d42
  17D6  884C90     mov.w 0x0000,0x0992
  17D8  884CA1     mov.w 0x0002,0x0994
261:                   float userDefinedPower = (float)maxLoadLighting * intensity / 100.0f;
262:                   light_t_on = PowerToTimeOn(userDefinedPower);
  17DA  F80992     push.w 0x0992
  17DC  F9099A     pop.w 0x099a
  17DE  F80994     push.w 0x0994
  17E0  F9099C     pop.w 0x099c
  17E2  02158C     call 0x00158c
  17E6  884B60     mov.w 0x0000,0x096c
  17E8  884B71     mov.w 0x0002,0x096e
263:                   light_t_on = 8.3333333f - light_t_on;
  17EA  A80043     bset.b 0x0043,#0
  17EC  255550     mov.w #0x5555,0x0000
  17EE  241051     mov.w #0x4105,0x0002
  17F0  804B62     mov.w 0x096c,0x0004
  17F2  804B73     mov.w 0x096e,0x0006
  17F4  020E20     call 0x000e20
  17F8  884B60     mov.w 0x0000,0x096c
  17FA  884B71     mov.w 0x0002,0x096e
264:                   LoadStruct.PhaseOffset = (unsigned int16)(light_t_on * 3708f);
  17FC  804B60     mov.w 0x096c,0x0000
  17FE  804B71     mov.w 0x096e,0x0002
  1800  2C0002     mov.w #0xc000,0x0004
  1802  245673     mov.w #0x4567,0x0006
  1804  020FC0     call 0x000fc0
  1808  020DF4     call 0x000df4
  180C  884710     mov.w 0x0000,0x08e2
265:               }
  180E  78034F     mov.w [--0x001e],0x000c
  1810  7802CF     mov.w [--0x001e],0x000a
  1812  060000     return
266:               
267:               void monitorSync()
268:               {
269:               	int1 currentSyncSatus = input(SYNC);
270:               	if (currentSyncSatus != previousSyncSatus)
271:               	{
272:               		syncTransitions++;
273:               		previousSyncSatus = currentSyncSatus;
274:               	}
275:               }
276:               
277:               /*
278:                *****************************************************************************************************
279:                *                                            TurnTriacOn()
280:                *****************************************************************************************************
281:                *
282:                * Description : Turn Triac On.
283:                *
284:                * Arguments   : none.
285:                * 
286:                * Caller      : various.
287:                *
288:                * Returns     : none.
289:                * 
290:                * Notes       : none.
291:                *****************************************************************************************************
292:                */
293:               void TurnTriacOn(void)
294:               {
  03CA  781F85     mov.w 0x000a,[0x001e++]
295:                   if (LoadStruct.TriacState == true) {
  03CC  AE08E7     btss.b 0x08e7,#0
  03CE  370003     bra 0x0003d6
296:                       alarmData.PulseWidthErr++;
  03D0  EC286E     inc.w 0x086e
  03D2  AF2042     btsc.b 0x0042,#1
  03D4  EC2870     inc.w 0x0870
297:                   }
298:                   TurnLoadCtrlLow();
  03D6  0203C4     call 0x0003c4
299:                   LoadStruct.TriacState = true;
  03DA  A808E7     bset.b 0x08e7,#0
300:               }
  03DC  7802CF     mov.w [--0x001e],0x000a
  03DE  060000     return
301:               
302:               /*
303:                *****************************************************************************************************
304:                *                                         TurnLoadCtrlLow()
305:                *****************************************************************************************************
306:                *
307:                * Description : Turn Triac On.
308:                *
309:                * Arguments   : none.
310:                * 
311:                * Caller      : various.
312:                *
313:                * Returns     : none.
314:                * 
315:                * Notes       : none.
316:                *****************************************************************************************************
317:                */
318:               void TurnLoadCtrlLow(void)
319:               {
320:                   output_low(LOAD_CTRL);
  03C4  A902D8     bclr.b 0x02d8,#0
  03C6  A902DC     bclr.b 0x02dc,#0
321:                   //output_low(ENCA);
322:               }
  03C8  060000     return
323:               
324:               /*
325:                *****************************************************************************************************
326:                *                                         TurnLoadCtrlLow()
327:                *****************************************************************************************************
328:                *
329:                * Description : Turn Triac On.
330:                *
331:                * Arguments   : none.
332:                * 
333:                * Caller      : various.
334:                *
335:                * Returns     : none.
336:                * 
337:                * Notes       : none.
338:                *****************************************************************************************************
339:                */
340:               void TurnLoadCtrlHigh(void)
341:               {
342:                   output_high(LOAD_CTRL);
  03E0  A902D8     bclr.b 0x02d8,#0
  03E2  A802DC     bset.b 0x02dc,#0
343:                   //output_high(ENCA);
344:               }
  03E4  060000     return
345:               
346:               /*
347:                *****************************************************************************************************
348:                *                                            TurnTriacOff()
349:                *****************************************************************************************************
350:                *
351:                * Description : Turn Triac Off.
352:                *
353:                * Arguments   : none.
354:                * 
355:                * Caller      : various.
356:                *
357:                * Returns     : none.
358:                * 
359:                * Notes       : none.
360:                *****************************************************************************************************
361:                */
362:               void TurnTriacOff(void)
363:               {
  03E6  781F85     mov.w 0x000a,[0x001e++]
364:                   if (LoadStruct.TriacState == false) {
  03E8  AF08E7     btsc.b 0x08e7,#0
  03EA  370003     bra 0x0003f2
365:                       alarmData.PulseWidthErr++;
  03EC  EC286E     inc.w 0x086e
  03EE  AF2042     btsc.b 0x0042,#1
  03F0  EC2870     inc.w 0x0870
366:                   }
367:                   TurnLoadCtrlHigh();
  03F2  0203E0     call 0x0003e0
368:                   LoadStruct.TriacState = false;
  03F6  A908E7     bclr.b 0x08e7,#0
369:               }
  03F8  7802CF     mov.w [--0x001e],0x000a
  03FA  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\LumMonitor.c  --------------------
1:                 #include "includes.h"
2:                 
3:                 unsigned int16 ADC_LUM_AMB = 0;
4:                 //int16 ADC_BAT_MON = 0;
5:                 
6:                 void initLumMonitor()
7:                 {
8:                 	SETUP_ADC(ADC_CLOCK_INTERNAL);
  0ADC  200804     mov.w #0x80,0x0008
  0ADE  881524     mov.w 0x0008,0x02a4
  0AE0  280E04     mov.w #0x80e0,0x0008
  0AE2  881504     mov.w 0x0008,0x02a0
9:                 	SETUP_ADC_PORTS(sAN6|sAN7	,VSS_VDD);
  0AE4  2FF3F4     mov.w #0xff3f,0x0008
  0AE6  881544     mov.w 0x0008,0x02a8
  0AE8  EF22A2     clr.w 0x02a2
10:                }
  0AEA  060000     return
11:                
12:                void readLumMonitor()
13:                {
14:                	set_adc_channel(6);
  1C00  200064     mov.w #0x6,0x0008
  1C02  881534     mov.w 0x0008,0x02a6
15:                	delay_us(100);
  1C04  090B94     repeat #2964
  1C06  000000     nop
16:                	ADC_LUM_AMB = read_adc();
  1C08  A902A0     bclr.b 0x02a0,#0
  1C0A  A822A0     bset.b 0x02a0,#1
  1C0C  AE02A0     btss.b 0x02a0,#0
  1C0E  37FFFE     bra 0x001c0c
  1C10  801400     mov.w 0x0280,0x0000
  1C12  DD0046     sl 0x0000,#6,0x0000
  1C14  884B10     mov.w 0x0000,0x0962
17:                    
18:                    if ((enableLCD)                                                             &&
19:                        (ADC_LUM_AMB < LUM_LCD_OFF_THRESHOLD_LOW)                               &&
20:                        !insideMenu                                                             &&
21:                        (alarmData.CurrentBinaryTime >= (lastUserPush + PUSH_BUTTON_TIMEOUT_SEC))) {
  1C16  AE8885     btss.b 0x0885,#4
  1C18  370016     bra 0x001c46
  1C1A  804B14     mov.w 0x0962,0x0008
  1C1C  204003     mov.w #0x400,0x0006
  1C1E  E11804     cp.w 0x0006,0x0008
  1C20  360012     bra leu, 0x001c46
  1C22  AF0885     btsc.b 0x0885,#0
  1C24  370010     bra 0x001c46
  1C26  804AF4     mov.w 0x095e,0x0008
  1C28  42026A     add.w 0x0008,#10,0x0008
  1C2A  780004     mov.w 0x0008,0x0000
  1C2C  804B04     mov.w 0x0960,0x0008
  1C2E  4A0260     addc.w 0x0008,#0,0x0008
  1C30  780084     mov.w 0x0008,0x0002
  1C32  804344     mov.w 0x0868,0x0008
  1C34  E12001     cp.w 0x0008,0x0002
  1C36  390007     bra nc, 0x001c46
  1C38  3E0003     bra gtu, 0x001c40
  1C3A  804334     mov.w 0x0866,0x0008
  1C3C  E12000     cp.w 0x0008,0x0000
  1C3E  390003     bra nc, 0x001c46
22:                        shutdownLCD();
  1C40  021BF2     call 0x001bf2
23:                    } else if (!enableLCD                                  && 
  1C44  370015     bra 0x001c70
24:                               ((ADC_LUM_AMB > LUM_LCD_OFF_THRESHOLD_HIGH) ||
25:                                (alarmData.CurrentBinaryTime < (lastUserPush + PUSH_BUTTON_TIMEOUT_SEC)))) {
  1C46  AF8885     btsc.b 0x0885,#4
  1C48  370013     bra 0x001c70
  1C4A  804B14     mov.w 0x0962,0x0008
  1C4C  208003     mov.w #0x800,0x0006
  1C4E  E11804     cp.w 0x0006,0x0008
  1C50  39000D     bra nc, 0x001c6c
  1C52  804AF4     mov.w 0x095e,0x0008
  1C54  42026A     add.w 0x0008,#10,0x0008
  1C56  780004     mov.w 0x0008,0x0000
  1C58  804B04     mov.w 0x0960,0x0008
  1C5A  4A0260     addc.w 0x0008,#0,0x0008
  1C5C  780084     mov.w 0x0008,0x0002
  1C5E  804344     mov.w 0x0868,0x0008
  1C60  E12001     cp.w 0x0008,0x0002
  1C62  3E0006     bra gtu, 0x001c70
  1C64  390003     bra nc, 0x001c6c
  1C66  804334     mov.w 0x0866,0x0008
  1C68  E12000     cp.w 0x0008,0x0000
  1C6A  310002     bra c, 0x001c70
26:                        initLCD();
  1C6C  020B74     call 0x000b74
27:                    }
28:                }
  1C70  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\Menu.c  --------------------------
1:                 #include "includes.h"
2:                 #define SET_CURSOR_HOME (writeToLCD(LCD_WRITE_CFG,LCD_CSR_HM))
3:                 #DEFINE DISABLE_BLINKING_AND_CURSOR (writeToLCD(LCD_WRITE_CFG,LCD_DSPL_BOFF))
4:                 #DEFINE ENABLE_BLINKING_AND_CURSOR (writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFTL))
5:                 
6:                 
7:                 void EditMenu()
8:                 {
  2D42  781F85     mov.w 0x000a,[0x001e++]
  2D44  EF2980     clr.w 0x0980
  2D46  A90982     bclr.b 0x0982,#0
  2D48  BFC886     mov.b 0x0886,0x0000
  2D4A  B7E983     mov.b 0x0000,0x0983
9:                 	int16 currentPOS;
10:                	int16 previousPOS = 0;
11:                	int1 exitMenu = false;
12:                	int8 cursorLocation = EDIT_ALARM_OPTIONS_LOCATION[0];
13:                	
14:                	//Enter select mode
15:                	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  2D4C  B3CF80     mov.b #0xf8,0x0000
  2D4E  B7E9B4     mov.b 0x0000,0x09b4
  2D50  B3C0F0     mov.b #0xf,0x0000
  2D52  B7E9B5     mov.b 0x0000,0x09b5
  2D54  020B2C     call 0x000b2c
16:                	
17:                	int1  direction = UP;
18:                	int1  firstLoopRun = TRUE;
  2D58  A82982     bset.b 0x0982,#1
  2D5A  A84982     bset.b 0x0982,#2
19:                
20:                    insideMenu = true;
  2D5C  A80885     bset.b 0x0885,#0
21:                	
22:                	while (!exitMenu){
  2D5E  AF0982     btsc.b 0x0982,#0
  2D60  37007F     bra 0x002e60
23:                		
24:                		currentPOS = POSCNT;
  2D62  F80126     push.w 0x0126
  2D64  F9097E     pop.w 0x097e
25:                		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2D66  804BF0     mov.w 0x097e,0x0000
  2D68  E30980     cp.w 0x0980
  2D6A  3A0002     bra nz, 0x002d70
  2D6C  AE4982     btss.b 0x0982,#2
  2D6E  37003B     bra 0x002de6
26:                			
27:                			if (!firstLoopRun)
  2D70  AF4982     btsc.b 0x0982,#2
  2D72  37001D     bra 0x002dae
28:                			{
29:                				direction = UPDN;
  2D74  A92982     bclr.b 0x0982,#1
  2D76  AF6123     btsc.b 0x0123,#3
  2D78  A82982     bset.b 0x0982,#1
30:                				cursorLocation += ((int8)UPDN)*2-1;
  2D7A  EB4000     clr.b 0x0000
  2D7C  AF6123     btsc.b 0x0123,#3
  2D7E  E80000     inc.w 0x0000,0x0000
  2D80  784200     mov.b 0x0000,0x0008
  2D82  EF6009     clr.b 0x0009
  2D84  B82062     mul.uu 0x0008,#2,0x0000
  2D86  504061     sub.b 0x0000,#1,0x0000
  2D88  B46983     add.b 0x0983
31:                				cursorLocation %= EDIT_ALARM_OPTIONS_PH_LOCATION;
  2D8A  BFC983     mov.b 0x0983,0x0000
  2D8C  EF6001     clr.b 0x0001
  2D8E  EF6001     clr.b 0x0001
  2D90  200094     mov.w #0x9,0x0008
  2D92  FB0000     se 0x0000,0x0000
  2D94  090011     repeat #17
  2D96  D80004     div.sw 0x0000,0x0008
  2D98  784001     mov.b 0x0002,0x0000
  2D9A  B7E983     mov.b 0x0000,0x0983
32:                				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_OPTIONS_PH_LOCATION;
  2D9C  804C14     mov.w 0x0982,0x0008
  2D9E  DE2248     lsr 0x0008,#8,0x0008
  2DA0  E12460     cp.b 0x0008,#0
  2DA2  3D0005     bra ges, 0x002dae
  2DA4  804C14     mov.w 0x0982,0x0008
  2DA6  DE2248     lsr 0x0008,#8,0x0008
  2DA8  424269     add.b 0x0008,#9,0x0008
  2DAA  784004     mov.b 0x0008,0x0000
  2DAC  B7E983     mov.b 0x0000,0x0983
33:                				
34:                			}
35:                			firstLoopRun = false;
  2DAE  A94982     bclr.b 0x0982,#2
36:                			
37:                			displayEditAlarmOptions();
  2DB0  021DC4     call 0x001dc4
38:                			
39:                			SET_CURSOR_HOME;
  2DB4  B3CF80     mov.b #0xf8,0x0000
  2DB6  B7E9B4     mov.b 0x0000,0x09b4
  2DB8  B3C020     mov.b #0x2,0x0000
  2DBA  B7E9B5     mov.b 0x0000,0x09b5
  2DBC  020B2C     call 0x000b2c
40:                			int i;
41:                			for (i = 0 ; i < EDIT_ALARM_OPTIONS_LOCATION[cursorLocation] ; i++)
  2DC0  EF2984     clr.w 0x0984
  2DC2  BFC983     mov.b 0x0983,0x0000
  2DC4  FB0000     se 0x0000,0x0000
  2DC6  208864     mov.w #0x886,0x0008
  2DC8  400004     add.w 0x0000,0x0008,0x0000
  2DCA  780200     mov.w 0x0000,0x0008
  2DCC  784014     mov.b [0x0008],0x0000
  2DCE  FB0000     se 0x0000,0x0000
  2DD0  804C24     mov.w 0x0984,0x0008
  2DD2  E12000     cp.w 0x0008,0x0000
  2DD4  3D0008     bra ges, 0x002de6
42:                			{
43:                				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2DD6  B3CF80     mov.b #0xf8,0x0000
  2DD8  B7E9B4     mov.b 0x0000,0x09b4
  2DDA  B3C140     mov.b #0x14,0x0000
  2DDC  B7E9B5     mov.b 0x0000,0x09b5
  2DDE  020B2C     call 0x000b2c
44:                			}
  2DE2  EC2984     inc.w 0x0984
  2DE4  37FFEE     bra 0x002dc2
45:                			
46:                		}
47:                		
48:                		if (pushAck)
  2DE6  AE2966     btss.b 0x0966,#1
  2DE8  370038     bra 0x002e5a
49:                		{
50:                            pushAck = false;
  2DEA  A92966     bclr.b 0x0966,#1
51:                           
52:                			beep(true);
  2DEC  B3C010     mov.b #0x1,0x0000
  2DEE  B7E9AC     mov.b 0x0000,0x09ac
  2DF0  021E22     call 0x001e22
53:                			delay_ms(BUZZER_ON_TIME);
  2DF4  200320     mov.w #0x32,0x0000
  2DF6  020AEC     call 0x000aec
54:                			beep(false);
  2DFA  EF69AC     clr.b 0x09ac
  2DFC  021E22     call 0x001e22
55:                
56:                            
57:                			//GO TO EDIT OR EXIT MODE
58:                			switch (cursorLocation)
59:                			{
  2E00  BFC983     mov.b 0x0983,0x0000
  2E02  EF6001     clr.b 0x0001
  2E04  B28000     xor.w #0x0,0x0000
  2E06  320011     bra z, 0x002e2a
  2E08  B28010     xor.w #0x1,0x0000
  2E0A  320012     bra z, 0x002e30
  2E0C  B28030     xor.w #0x3,0x0000
  2E0E  320013     bra z, 0x002e36
  2E10  B28010     xor.w #0x1,0x0000
  2E12  320014     bra z, 0x002e3c
  2E14  B28070     xor.w #0x7,0x0000
  2E16  320015     bra z, 0x002e42
  2E18  B28010     xor.w #0x1,0x0000
  2E1A  320016     bra z, 0x002e48
  2E1C  B28030     xor.w #0x3,0x0000
  2E1E  320017     bra z, 0x002e4e
  2E20  B28010     xor.w #0x1,0x0000
  2E22  320016     bra z, 0x002e50
  2E24  B280F0     xor.w #0xf,0x0000
  2E26  320017     bra z, 0x002e56
  2E28  370018     bra 0x002e5a
60:                				case 0:
61:                					EditAlarmTime();
  2E2A  022464     call 0x002464
62:                					break;
  2E2E  370015     bra 0x002e5a
63:                				case 1:
64:                					EditCarillon();
  2E30  022604     call 0x002604
65:                					break;
  2E34  370012     bra 0x002e5a
66:                				case 2:
67:                					EditDateAndTime();
  2E36  0226E4     call 0x0026e4
68:                					break;
  2E3A  37000F     bra 0x002e5a
69:                				case 3:
70:                					EditLoadLighting();
  2E3C  022882     call 0x002882
71:                					break;
  2E40  37000C     bra 0x002e5a
72:                				case 4:
73:                					EditRGBLighting();
  2E42  022994     call 0x002994
74:                					break;
  2E46  370009     bra 0x002e5a
75:                				case 5:
76:                					EditVolume();
  2E48  022ACE     call 0x002ace
77:                					break;
  2E4C  370006     bra 0x002e5a
78:                				case 6:
79:                					//EditBattery();
80:                					break;
  2E4E  370005     bra 0x002e5a
81:                				case 7:
82:                					EditPowerCtrls();
  2E50  022C62     call 0x002c62
83:                					break;
  2E54  370002     bra 0x002e5a
84:                				case 8:
85:                					exitMenu = true;
  2E56  A80982     bset.b 0x0982,#0
86:                					break;
  2E58  370000     bra 0x002e5a
87:                			}
88:                		}
89:                		
90:                		previousPOS = currentPOS;
  2E5A  F8097E     push.w 0x097e
  2E5C  F90980     pop.w 0x0980
91:                	}
  2E5E  37FF7F     bra 0x002d5e
92:                	
93:                	DISABLE_BLINKING_AND_CURSOR;
  2E60  B3CF80     mov.b #0xf8,0x0000
  2E62  B7E9B4     mov.b 0x0000,0x09b4
  2E64  B3C0C0     mov.b #0xc,0x0000
  2E66  B7E9B5     mov.b 0x0000,0x09b5
  2E68  020B2C     call 0x000b2c
94:                	
95:                	insideMenu = false;
  2E6C  A90885     bclr.b 0x0885,#0
96:                }
  2E6E  7802CF     mov.w [--0x001e],0x000a
  2E70  060000     return
97:                
98:                void EditDateAndTime()
99:                {
  26E4  781F85     mov.w 0x000a,[0x001e++]
100:               	disable_interrupts(INT_TIMER1);
  26E6  A9608C     bclr.b 0x008c,#3
101:               	int16 currentPOS;
102:               	int16 previousPOS;
103:               	int1 exitEditDateAndTime = false;
104:               	int8 cursorLocation = 0;
105:               	int1  direction = UP;
106:               	int1  firstLoopRun = TRUE;
  26E8  A9098A     bclr.b 0x098a,#0
  26EA  EF698B     clr.b 0x098b
  26EC  A8298A     bset.b 0x098a,#1
  26EE  A8498A     bset.b 0x098a,#2
107:               	
108:               	//Enter select mode
109:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  26F0  B3CF80     mov.b #0xf8,0x0000
  26F2  B7E9B4     mov.b 0x0000,0x09b4
  26F4  B3C0F0     mov.b #0xf,0x0000
  26F6  B7E9B5     mov.b 0x0000,0x09b5
  26F8  020B2C     call 0x000b2c
110:               	
111:               	while (!exitEditDateAndTime){
  26FC  AF098A     btsc.b 0x098a,#0
  26FE  3700B6     bra 0x00286c
112:               		
113:               		
114:               		currentPOS = POSCNT;
  2700  F80126     push.w 0x0126
  2702  F90986     pop.w 0x0986
115:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2704  804C30     mov.w 0x0986,0x0000
  2706  E30988     cp.w 0x0988
  2708  3A0002     bra nz, 0x00270e
  270A  AE498A     btss.b 0x098a,#2
  270C  37003B     bra 0x002784
116:               			
117:               			
118:               			if (!firstLoopRun)
  270E  AF498A     btsc.b 0x098a,#2
  2710  37001D     bra 0x00274c
119:               			{
120:               				direction = UPDN;
  2712  A9298A     bclr.b 0x098a,#1
  2714  AF6123     btsc.b 0x0123,#3
  2716  A8298A     bset.b 0x098a,#1
121:               				cursorLocation += ((int8)UPDN)*2-1;
  2718  EB4000     clr.b 0x0000
  271A  AF6123     btsc.b 0x0123,#3
  271C  E80000     inc.w 0x0000,0x0000
  271E  784200     mov.b 0x0000,0x0008
  2720  EF6009     clr.b 0x0009
  2722  B82062     mul.uu 0x0008,#2,0x0000
  2724  504061     sub.b 0x0000,#1,0x0000
  2726  B4698B     add.b 0x098b
122:               				cursorLocation %= EDIT_DATE_TIME_PH_COUNT;
  2728  BFC98B     mov.b 0x098b,0x0000
  272A  EF6001     clr.b 0x0001
  272C  EF6001     clr.b 0x0001
  272E  200074     mov.w #0x7,0x0008
  2730  FB0000     se 0x0000,0x0000
  2732  090011     repeat #17
  2734  D80004     div.sw 0x0000,0x0008
  2736  784001     mov.b 0x0002,0x0000
  2738  B7E98B     mov.b 0x0000,0x098b
123:               				if (cursorLocation < 0) cursorLocation += EDIT_DATE_TIME_PH_COUNT;
  273A  804C54     mov.w 0x098a,0x0008
  273C  DE2248     lsr 0x0008,#8,0x0008
  273E  E12460     cp.b 0x0008,#0
  2740  3D0005     bra ges, 0x00274c
  2742  804C54     mov.w 0x098a,0x0008
  2744  DE2248     lsr 0x0008,#8,0x0008
  2746  424267     add.b 0x0008,#7,0x0008
  2748  784004     mov.b 0x0008,0x0000
  274A  B7E98B     mov.b 0x0000,0x098b
124:               				
125:               			}
126:               			firstLoopRun = false;
  274C  A9498A     bclr.b 0x098a,#2
127:               			
128:               			displayEditDateAndTime();
  274E  021EA8     call 0x001ea8
129:               			
130:               			SET_CURSOR_HOME;
  2752  B3CF80     mov.b #0xf8,0x0000
  2754  B7E9B4     mov.b 0x0000,0x09b4
  2756  B3C020     mov.b #0x2,0x0000
  2758  B7E9B5     mov.b 0x0000,0x09b5
  275A  020B2C     call 0x000b2c
131:               			int i;
132:               			for (i = 0 ; i < EDIT_DATE_TIME_PH_LOCATION[cursorLocation] ; i++)
  275E  EF298C     clr.w 0x098c
  2760  BFC98B     mov.b 0x098b,0x0000
  2762  FB0000     se 0x0000,0x0000
  2764  2087E4     mov.w #0x87e,0x0008
  2766  400004     add.w 0x0000,0x0008,0x0000
  2768  780200     mov.w 0x0000,0x0008
  276A  784014     mov.b [0x0008],0x0000
  276C  FB0000     se 0x0000,0x0000
  276E  804C64     mov.w 0x098c,0x0008
  2770  E12000     cp.w 0x0008,0x0000
  2772  3D0008     bra ges, 0x002784
133:               			{
134:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2774  B3CF80     mov.b #0xf8,0x0000
  2776  B7E9B4     mov.b 0x0000,0x09b4
  2778  B3C140     mov.b #0x14,0x0000
  277A  B7E9B5     mov.b 0x0000,0x09b5
  277C  020B2C     call 0x000b2c
135:               			}
  2780  EC298C     inc.w 0x098c
  2782  37FFEE     bra 0x002760
136:               
137:               		}
138:               		
139:               		if (pushAck)
  2784  AE2966     btss.b 0x0966,#1
  2786  37006F     bra 0x002866
140:               		{
141:                           pushAck = false;
  2788  A92966     bclr.b 0x0966,#1
142:               			beep(true);
  278A  B3C010     mov.b #0x1,0x0000
  278C  B7E9AC     mov.b 0x0000,0x09ac
  278E  021E22     call 0x001e22
143:               			delay_ms(BUZZER_ON_TIME);
  2792  200320     mov.w #0x32,0x0000
  2794  020AEC     call 0x000aec
144:               			beep(false);
  2798  EF69AC     clr.b 0x09ac
  279A  021E22     call 0x001e22
145:               
146:               			//GO TO EDIT OR EXIT MODE			
147:               			switch (cursorLocation)
148:               			{
  279E  BFC98B     mov.b 0x098b,0x0000
  27A0  EF6001     clr.b 0x0001
  27A2  B28000     xor.w #0x0,0x0000
  27A4  32000D     bra z, 0x0027c0
  27A6  B28010     xor.w #0x1,0x0000
  27A8  320018     bra z, 0x0027da
  27AA  B28030     xor.w #0x3,0x0000
  27AC  320023     bra z, 0x0027f4
  27AE  B28010     xor.w #0x1,0x0000
  27B0  32002E     bra z, 0x00280e
  27B2  B28070     xor.w #0x7,0x0000
  27B4  32003A     bra z, 0x00282a
  27B6  B28010     xor.w #0x1,0x0000
  27B8  320046     bra z, 0x002846
  27BA  B28030     xor.w #0x3,0x0000
  27BC  320052     bra z, 0x002862
  27BE  370053     bra 0x002866
149:               				case 0:
150:               					editIntField(&CurrentTime.tm_hour, 0, 23,displayEditDateAndTime);
  27C0  000000     nop
  27C2  B7E001     mov.b 0x0000,0x0001
  27C4  21EA80     mov.w #0x1ea8,0x0000
  27C6  780280     mov.w 0x0000,0x000a
  27C8  EF2994     clr.w 0x0994
  27CA  200174     mov.w #0x17,0x0008
  27CC  884CB4     mov.w 0x0008,0x0996
  27CE  2092C4     mov.w #0x92c,0x0008
  27D0  884C94     mov.w 0x0008,0x0992
  27D2  884CC5     mov.w 0x000a,0x0998
  27D4  0220F2     call 0x0020f2
151:               					break;
  27D8  370046     bra 0x002866
152:               				case 1:
153:               					editIntField(&CurrentTime.tm_min, 0, 59,displayEditDateAndTime);
  27DA  000000     nop
  27DC  B7E001     mov.b 0x0000,0x0001
  27DE  21EA80     mov.w #0x1ea8,0x0000
  27E0  780280     mov.w 0x0000,0x000a
  27E2  EF2994     clr.w 0x0994
  27E4  2003B4     mov.w #0x3b,0x0008
  27E6  884CB4     mov.w 0x0008,0x0996
  27E8  2092A4     mov.w #0x92a,0x0008
  27EA  884C94     mov.w 0x0008,0x0992
  27EC  884CC5     mov.w 0x000a,0x0998
  27EE  0220F2     call 0x0020f2
154:               					break;
  27F2  370039     bra 0x002866
155:               				case 2:
156:               					editIntField(&CurrentTime.tm_sec, 0, 59,displayEditDateAndTime);
  27F4  000000     nop
  27F6  B7E001     mov.b 0x0000,0x0001
  27F8  21EA80     mov.w #0x1ea8,0x0000
  27FA  780280     mov.w 0x0000,0x000a
  27FC  EF2994     clr.w 0x0994
  27FE  2003B4     mov.w #0x3b,0x0008
  2800  884CB4     mov.w 0x0008,0x0996
  2802  209284     mov.w #0x928,0x0008
  2804  884C94     mov.w 0x0008,0x0992
  2806  884CC5     mov.w 0x000a,0x0998
  2808  0220F2     call 0x0020f2
157:               					break;
  280C  37002C     bra 0x002866
158:               				case 3:
159:               					editIntField(&CurrentTime.tm_mday, 1, 31,displayEditDateAndTime);
  280E  000000     nop
  2810  B7E001     mov.b 0x0000,0x0001
  2812  21EA80     mov.w #0x1ea8,0x0000
  2814  780280     mov.w 0x0000,0x000a
  2816  200014     mov.w #0x1,0x0008
  2818  884CA4     mov.w 0x0008,0x0994
  281A  2001F4     mov.w #0x1f,0x0008
  281C  884CB4     mov.w 0x0008,0x0996
  281E  2092E4     mov.w #0x92e,0x0008
  2820  884C94     mov.w 0x0008,0x0992
  2822  884CC5     mov.w 0x000a,0x0998
  2824  0220F2     call 0x0020f2
160:               					break;
  2828  37001E     bra 0x002866
161:               				case 4:
162:               					editIntField(&CurrentTime.tm_mon, 1, 12,displayEditDateAndTime);
  282A  000000     nop
  282C  B7E001     mov.b 0x0000,0x0001
  282E  21EA80     mov.w #0x1ea8,0x0000
  2830  780280     mov.w 0x0000,0x000a
  2832  200014     mov.w #0x1,0x0008
  2834  884CA4     mov.w 0x0008,0x0994
  2836  2000C4     mov.w #0xc,0x0008
  2838  884CB4     mov.w 0x0008,0x0996
  283A  209304     mov.w #0x930,0x0008
  283C  884C94     mov.w 0x0008,0x0992
  283E  884CC5     mov.w 0x000a,0x0998
  2840  0220F2     call 0x0020f2
163:               					break;
  2844  370010     bra 0x002866
164:               				case 5:
165:               					editIntField(&CurrentTime.tm_year, 2000, 2050,displayEditDateAndTime);
  2846  000000     nop
  2848  B7E001     mov.b 0x0000,0x0001
  284A  21EA80     mov.w #0x1ea8,0x0000
  284C  780280     mov.w 0x0000,0x000a
  284E  209324     mov.w #0x932,0x0008
  2850  884C94     mov.w 0x0008,0x0992
  2852  207D04     mov.w #0x7d0,0x0008
  2854  884CA4     mov.w 0x0008,0x0994
  2856  208024     mov.w #0x802,0x0008
  2858  884CB4     mov.w 0x0008,0x0996
  285A  884CC5     mov.w 0x000a,0x0998
  285C  0220F2     call 0x0020f2
166:               					break;
  2860  370002     bra 0x002866
167:               				case 6:
168:               					exitEditDateAndTime = true;
  2862  A8098A     bset.b 0x098a,#0
169:               					break;
  2864  370000     bra 0x002866
170:               
171:               
172:               			}
173:               		}
174:               		
175:               		previousPOS = currentPOS;
  2866  F80986     push.w 0x0986
  2868  F90988     pop.w 0x0988
176:               	}
  286A  37FF48     bra 0x0026fc
177:               	//DISABLE_BLINKING_AND_CURSOR;
178:               
179:               	// Recalculate new current date
180:               	alarmData.CurrentBinaryTime = DS1371_DateToBinary(&CurrentTime);
  286C  209284     mov.w #0x928,0x0008
  286E  884CE4     mov.w 0x0008,0x099c
  2870  02091E     call 0x00091e
  2874  884330     mov.w 0x0000,0x0866
  2876  884341     mov.w 0x0002,0x0868
181:                   // Recalculate next alarm
182:                   FindNextAlarmTime();
  2878  021830     call 0x001830
183:               	// Reenable 
184:               	enable_interrupts(INT_TIMER1);
  287C  A8608C     bset.b 0x008c,#3
185:               }
  287E  7802CF     mov.w [--0x001e],0x000a
  2880  060000     return
186:               
187:               void EditAlarmDays()
188:               {
  21E0  781F85     mov.w 0x000a,[0x001e++]
  21E2  EF2990     clr.w 0x0990
  21E4  A90992     bclr.b 0x0992,#0
  21E6  BFC898     mov.b 0x0898,0x0000
  21E8  B7E993     mov.b 0x0000,0x0993
189:               	int16 currentPOS;
190:               	int16 previousPOS = 0;
191:               	int1 exitMenu = false;
192:               	int8 cursorLocation = EDIT_ALARM_DAYS_LOCATION[0];
193:               	
194:               	//Enter select mode
195:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  21EA  B3CF80     mov.b #0xf8,0x0000
  21EC  B7E9B4     mov.b 0x0000,0x09b4
  21EE  B3C0F0     mov.b #0xf,0x0000
  21F0  B7E9B5     mov.b 0x0000,0x09b5
  21F2  020B2C     call 0x000b2c
196:               	
197:               	int1  direction = UP;
198:               	int1  firstLoopRun = TRUE;
  21F6  A82992     bset.b 0x0992,#1
  21F8  A84992     bset.b 0x0992,#2
199:               	
200:               	while (!exitMenu){
  21FA  AF0992     btsc.b 0x0992,#0
  21FC  370068     bra 0x0022ce
201:               		
202:               		currentPOS = POSCNT;
  21FE  F80126     push.w 0x0126
  2200  F9098E     pop.w 0x098e
203:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2202  804C70     mov.w 0x098e,0x0000
  2204  E30990     cp.w 0x0990
  2206  3A0002     bra nz, 0x00220c
  2208  AE4992     btss.b 0x0992,#2
  220A  37003B     bra 0x002282
204:               			
205:               			if (!firstLoopRun)
  220C  AF4992     btsc.b 0x0992,#2
  220E  37001D     bra 0x00224a
206:               			{
207:               				direction = UPDN;
  2210  A92992     bclr.b 0x0992,#1
  2212  AF6123     btsc.b 0x0123,#3
  2214  A82992     bset.b 0x0992,#1
208:               				cursorLocation += ((int8)UPDN)*2-1;
  2216  EB4000     clr.b 0x0000
  2218  AF6123     btsc.b 0x0123,#3
  221A  E80000     inc.w 0x0000,0x0000
  221C  784200     mov.b 0x0000,0x0008
  221E  EF6009     clr.b 0x0009
  2220  B82062     mul.uu 0x0008,#2,0x0000
  2222  504061     sub.b 0x0000,#1,0x0000
  2224  B46993     add.b 0x0993
209:               				cursorLocation %= EDIT_ALARM_DAYS_PH_LOCATION;
  2226  BFC993     mov.b 0x0993,0x0000
  2228  EF6001     clr.b 0x0001
  222A  EF6001     clr.b 0x0001
  222C  200084     mov.w #0x8,0x0008
  222E  FB0000     se 0x0000,0x0000
  2230  090011     repeat #17
  2232  D80004     div.sw 0x0000,0x0008
  2234  784001     mov.b 0x0002,0x0000
  2236  B7E993     mov.b 0x0000,0x0993
210:               				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_DAYS_PH_LOCATION;
  2238  804C94     mov.w 0x0992,0x0008
  223A  DE2248     lsr 0x0008,#8,0x0008
  223C  E12460     cp.b 0x0008,#0
  223E  3D0005     bra ges, 0x00224a
  2240  804C94     mov.w 0x0992,0x0008
  2242  DE2248     lsr 0x0008,#8,0x0008
  2244  424268     add.b 0x0008,#8,0x0008
  2246  784004     mov.b 0x0008,0x0000
  2248  B7E993     mov.b 0x0000,0x0993
211:               				
212:               			}
213:               			firstLoopRun = false;
  224A  A94992     bclr.b 0x0992,#2
214:               			
215:               			displayAlarmDays();
  224C  02217A     call 0x00217a
216:               			
217:               			SET_CURSOR_HOME;
  2250  B3CF80     mov.b #0xf8,0x0000
  2252  B7E9B4     mov.b 0x0000,0x09b4
  2254  B3C020     mov.b #0x2,0x0000
  2256  B7E9B5     mov.b 0x0000,0x09b5
  2258  020B2C     call 0x000b2c
218:               			int i;
219:               			for (i = 0 ; i < EDIT_ALARM_DAYS_LOCATION[cursorLocation] ; i++)
  225C  EF2994     clr.w 0x0994
  225E  BFC993     mov.b 0x0993,0x0000
  2260  FB0000     se 0x0000,0x0000
  2262  208984     mov.w #0x898,0x0008
  2264  400004     add.w 0x0000,0x0008,0x0000
  2266  780200     mov.w 0x0000,0x0008
  2268  784014     mov.b [0x0008],0x0000
  226A  FB0000     se 0x0000,0x0000
  226C  804CA4     mov.w 0x0994,0x0008
  226E  E12000     cp.w 0x0008,0x0000
  2270  3D0008     bra ges, 0x002282
220:               			{
221:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2272  B3CF80     mov.b #0xf8,0x0000
  2274  B7E9B4     mov.b 0x0000,0x09b4
  2276  B3C140     mov.b #0x14,0x0000
  2278  B7E9B5     mov.b 0x0000,0x09b5
  227A  020B2C     call 0x000b2c
222:               			}
  227E  EC2994     inc.w 0x0994
  2280  37FFEE     bra 0x00225e
223:               			
224:               		}
225:               		
226:               		if (pushAck)
  2282  AE2966     btss.b 0x0966,#1
  2284  370021     bra 0x0022c8
227:               		{
228:                           pushAck = false;
  2286  A92966     bclr.b 0x0966,#1
229:               			beep(true);
  2288  B3C010     mov.b #0x1,0x0000
  228A  B7E9AC     mov.b 0x0000,0x09ac
  228C  021E22     call 0x001e22
230:               			delay_ms(BUZZER_ON_TIME);
  2290  200320     mov.w #0x32,0x0000
  2292  020AEC     call 0x000aec
231:               			beep(false);
  2296  EF69AC     clr.b 0x09ac
  2298  021E22     call 0x001e22
232:               
233:               			//GO TO EDIT OR EXIT MODE
234:               			
235:               			if (cursorLocation == 7)
  229C  804C94     mov.w 0x0992,0x0008
  229E  DE2248     lsr 0x0008,#8,0x0008
  22A0  E12467     cp.b 0x0008,#7
  22A2  3A0002     bra nz, 0x0022a8
236:               			{
237:               				exitMenu = true;
  22A4  A80992     bset.b 0x0992,#0
238:               			}
239:               			else
  22A6  37000E     bra 0x0022c4
240:               			{
241:               				ALARM_DAYS[cursorLocation] = !ALARM_DAYS[cursorLocation];
  22A8  BFC993     mov.b 0x0993,0x0000
  22AA  FB0000     se 0x0000,0x0000
  22AC  209204     mov.w #0x920,0x0008
  22AE  400284     add.w 0x0000,0x0008,0x000a
  22B0  BFC993     mov.b 0x0993,0x0000
  22B2  FB0000     se 0x0000,0x0000
  22B4  209204     mov.w #0x920,0x0008
  22B6  400004     add.w 0x0000,0x0008,0x0000
  22B8  E00410     cp0.b [0x0000]
  22BA  320002     bra z, 0x0022c0
  22BC  EB4000     clr.b 0x0000
  22BE  370001     bra 0x0022c2
  22C0  B3C010     mov.b #0x1,0x0000
  22C2  784A80     mov.b 0x0000,[0x000a]
242:               			}
243:               			
244:               			displayAlarmDays();
  22C4  02217A     call 0x00217a
245:               		}
246:               		
247:               		previousPOS = currentPOS;
  22C8  F8098E     push.w 0x098e
  22CA  F90990     pop.w 0x0990
248:               	}
  22CC  37FF96     bra 0x0021fa
249:               
250:                   FindNextAlarmTime();
  22CE  021830     call 0x001830
251:               }
  22D2  7802CF     mov.w [--0x001e],0x000a
  22D4  060000     return
252:               
253:               void EditAlarmTime()
254:               {
  2464  781F85     mov.w 0x000a,[0x001e++]
  2466  EF2988     clr.w 0x0988
  2468  A9098A     bclr.b 0x098a,#0
  246A  BFC892     mov.b 0x0892,0x0000
  246C  B7E98B     mov.b 0x0000,0x098b
255:               	int16 currentPOS;
256:               	int16 previousPOS = 0;
257:               	int1 exitMenu = false;
258:               	int8 cursorLocation = EDIT_ALARM_TIME_LOCATION[0];
259:               	
260:               	//Enter select mode
261:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  246E  B3CF80     mov.b #0xf8,0x0000
  2470  B7E9B4     mov.b 0x0000,0x09b4
  2472  B3C0F0     mov.b #0xf,0x0000
  2474  B7E9B5     mov.b 0x0000,0x09b5
  2476  020B2C     call 0x000b2c
262:               	
263:               	int1  direction = UP;
264:               	int1  firstLoopRun = TRUE;
  247A  A8298A     bset.b 0x098a,#1
  247C  A8498A     bset.b 0x098a,#2
265:               	
266:               	while (!exitMenu){
  247E  AF098A     btsc.b 0x098a,#0
  2480  37008D     bra 0x00259c
267:               		
268:               		currentPOS = POSCNT;
  2482  F80126     push.w 0x0126
  2484  F90986     pop.w 0x0986
269:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2486  804C30     mov.w 0x0986,0x0000
  2488  E30988     cp.w 0x0988
  248A  3A0002     bra nz, 0x002490
  248C  AE498A     btss.b 0x098a,#2
  248E  37003B     bra 0x002506
270:               			
271:               			if (!firstLoopRun)
  2490  AF498A     btsc.b 0x098a,#2
  2492  37001D     bra 0x0024ce
272:               			{
273:               				direction = UPDN;
  2494  A9298A     bclr.b 0x098a,#1
  2496  AF6123     btsc.b 0x0123,#3
  2498  A8298A     bset.b 0x098a,#1
274:               				cursorLocation += ((int8)UPDN)*2-1;
  249A  EB4000     clr.b 0x0000
  249C  AF6123     btsc.b 0x0123,#3
  249E  E80000     inc.w 0x0000,0x0000
  24A0  784200     mov.b 0x0000,0x0008
  24A2  EF6009     clr.b 0x0009
  24A4  B82062     mul.uu 0x0008,#2,0x0000
  24A6  504061     sub.b 0x0000,#1,0x0000
  24A8  B4698B     add.b 0x098b
275:               				cursorLocation %= EDIT_ALARM_TIME_PH_LOCATION;
  24AA  BFC98B     mov.b 0x098b,0x0000
  24AC  EF6001     clr.b 0x0001
  24AE  EF6001     clr.b 0x0001
  24B0  200064     mov.w #0x6,0x0008
  24B2  FB0000     se 0x0000,0x0000
  24B4  090011     repeat #17
  24B6  D80004     div.sw 0x0000,0x0008
  24B8  784001     mov.b 0x0002,0x0000
  24BA  B7E98B     mov.b 0x0000,0x098b
276:               				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_TIME_PH_LOCATION;
  24BC  804C54     mov.w 0x098a,0x0008
  24BE  DE2248     lsr 0x0008,#8,0x0008
  24C0  E12460     cp.b 0x0008,#0
  24C2  3D0005     bra ges, 0x0024ce
  24C4  804C54     mov.w 0x098a,0x0008
  24C6  DE2248     lsr 0x0008,#8,0x0008
  24C8  424266     add.b 0x0008,#6,0x0008
  24CA  784004     mov.b 0x0008,0x0000
  24CC  B7E98B     mov.b 0x0000,0x098b
277:               				
278:               			}
279:               			firstLoopRun = false;
  24CE  A9498A     bclr.b 0x098a,#2
280:               			
281:               			displayEditAlarmTime();
  24D0  021E2A     call 0x001e2a
282:               			
283:               			SET_CURSOR_HOME;
  24D4  B3CF80     mov.b #0xf8,0x0000
  24D6  B7E9B4     mov.b 0x0000,0x09b4
  24D8  B3C020     mov.b #0x2,0x0000
  24DA  B7E9B5     mov.b 0x0000,0x09b5
  24DC  020B2C     call 0x000b2c
284:               			int i;
285:               			for (i = 0 ; i < EDIT_ALARM_TIME_LOCATION[cursorLocation] ; i++)
  24E0  EF298C     clr.w 0x098c
  24E2  BFC98B     mov.b 0x098b,0x0000
  24E4  FB0000     se 0x0000,0x0000
  24E6  208924     mov.w #0x892,0x0008
  24E8  400004     add.w 0x0000,0x0008,0x0000
  24EA  780200     mov.w 0x0000,0x0008
  24EC  784014     mov.b [0x0008],0x0000
  24EE  FB0000     se 0x0000,0x0000
  24F0  804C64     mov.w 0x098c,0x0008
  24F2  E12000     cp.w 0x0008,0x0000
  24F4  3D0008     bra ges, 0x002506
286:               			{
287:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  24F6  B3CF80     mov.b #0xf8,0x0000
  24F8  B7E9B4     mov.b 0x0000,0x09b4
  24FA  B3C140     mov.b #0x14,0x0000
  24FC  B7E9B5     mov.b 0x0000,0x09b5
  24FE  020B2C     call 0x000b2c
288:               			}
  2502  EC298C     inc.w 0x098c
  2504  37FFEE     bra 0x0024e2
289:               			
290:               		}
291:               		
292:               		if (pushAck)
  2506  AE2966     btss.b 0x0966,#1
  2508  370046     bra 0x002596
293:               		{
294:                           pushAck = false;
  250A  A92966     bclr.b 0x0966,#1
295:               			beep(true);
  250C  B3C010     mov.b #0x1,0x0000
  250E  B7E9AC     mov.b 0x0000,0x09ac
  2510  021E22     call 0x001e22
296:               			delay_ms(BUZZER_ON_TIME);
  2514  200320     mov.w #0x32,0x0000
  2516  020AEC     call 0x000aec
297:               			beep(false);
  251A  EF69AC     clr.b 0x09ac
  251C  021E22     call 0x001e22
298:               
299:               			//GO TO EDIT OR EXIT MODE
300:               			switch (cursorLocation)
301:               			{
  2520  BFC98B     mov.b 0x098b,0x0000
  2522  EF6001     clr.b 0x0001
  2524  B28000     xor.w #0x0,0x0000
  2526  32000B     bra z, 0x00253e
  2528  B28010     xor.w #0x1,0x0000
  252A  320011     bra z, 0x00254e
  252C  B28030     xor.w #0x3,0x0000
  252E  32001C     bra z, 0x002568
  2530  B28010     xor.w #0x1,0x0000
  2532  320027     bra z, 0x002582
  2534  B28070     xor.w #0x7,0x0000
  2536  320028     bra z, 0x002588
  2538  B28010     xor.w #0x1,0x0000
  253A  320029     bra z, 0x00258e
  253C  37002A     bra 0x002592
302:               				case 0:
303:               					ALARM_ENABLED = !ALARM_ENABLED;
  253E  AAA885     btg.b 0x0885,#5
304:                                   
305:                                   if (ALARM_ENABLED) {
  2540  AEA885     btss.b 0x0885,#5
  2542  370003     bra 0x00254a
306:                                       RTCC_TransitionToSTANDBY();
  2544  0218A0     call 0x0018a0
307:                                   }
308:                                   else {
  2548  370001     bra 0x00254c
309:                                       alarmData.AlarmState = ALARM_MASTER_OFF;
  254A  EF6876     clr.b 0x0876
310:                                   }
311:               
312:               					
313:               					break;
  254C  370022     bra 0x002592
314:               				case 1:
315:               					editIntField(&AlarmTime.tm_hour, 0, 23,displayEditAlarmTime);
  254E  000000     nop
  2550  B7E001     mov.b 0x0000,0x0001
  2552  21E2A0     mov.w #0x1e2a,0x0000
  2554  780280     mov.w 0x0000,0x000a
  2556  EF2994     clr.w 0x0994
  2558  200174     mov.w #0x17,0x0008
  255A  884CB4     mov.w 0x0008,0x0996
  255C  2093E4     mov.w #0x93e,0x0008
  255E  884C94     mov.w 0x0008,0x0992
  2560  884CC5     mov.w 0x000a,0x0998
  2562  0220F2     call 0x0020f2
316:               					break;
  2566  370015     bra 0x002592
317:               				case 2:
318:               					editIntField(&AlarmTime.tm_min, 0, 59,displayEditAlarmTime);
  2568  000000     nop
  256A  B7E001     mov.b 0x0000,0x0001
  256C  21E2A0     mov.w #0x1e2a,0x0000
  256E  780280     mov.w 0x0000,0x000a
  2570  EF2994     clr.w 0x0994
  2572  2003B4     mov.w #0x3b,0x0008
  2574  884CB4     mov.w 0x0008,0x0996
  2576  2093C4     mov.w #0x93c,0x0008
  2578  884C94     mov.w 0x0008,0x0992
  257A  884CC5     mov.w 0x000a,0x0998
  257C  0220F2     call 0x0020f2
319:               					break;
  2580  370008     bra 0x002592
320:               				case 3:
321:               					EditAlarmDays();
  2582  0221E0     call 0x0021e0
322:               					break;
  2586  370005     bra 0x002592
323:               				case 4:
324:               					EditAlarmSnooze();
  2588  02236C     call 0x00236c
325:               					break;
  258C  370002     bra 0x002592
326:               				case 5:
327:               					exitMenu = true;
  258E  A8098A     bset.b 0x098a,#0
328:               					break;
  2590  370000     bra 0x002592
329:               			}
330:               			displayEditAlarmTime();
  2592  021E2A     call 0x001e2a
331:               		}
332:               		
333:               		previousPOS = currentPOS;
  2596  F80986     push.w 0x0986
  2598  F90988     pop.w 0x0988
334:               	}
  259A  37FF71     bra 0x00247e
335:               
336:               	FindNextAlarmTime();
  259C  021830     call 0x001830
337:                   //updateSnoozeTimeWithAlarmTime();
338:               }
  25A0  7802CF     mov.w [--0x001e],0x000a
  25A2  060000     return
339:               
340:               void EditLoadLighting()
341:               {
  2882  781F85     mov.w 0x000a,[0x001e++]
  2884  EF2988     clr.w 0x0988
  2886  A9098A     bclr.b 0x098a,#0
  2888  BFC8A2     mov.b 0x08a2,0x0000
  288A  B7E98B     mov.b 0x0000,0x098b
342:               	int16 currentPOS;
343:               	int16 previousPOS = 0;
344:               	int1 exitMenu = false;
345:               	int8 cursorLocation = EDIT_LOAD_LIGHT_LOCATION[0];
346:               	
347:               	//Enter select mode
348:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  288C  B3CF80     mov.b #0xf8,0x0000
  288E  B7E9B4     mov.b 0x0000,0x09b4
  2890  B3C0F0     mov.b #0xf,0x0000
  2892  B7E9B5     mov.b 0x0000,0x09b5
  2894  020B2C     call 0x000b2c
349:               	
350:               	int1  direction = UP;
351:               	int1  firstLoopRun = TRUE;
  2898  A8298A     bset.b 0x098a,#1
  289A  A8498A     bset.b 0x098a,#2
352:               	
353:               	while (!exitMenu){
  289C  AF098A     btsc.b 0x098a,#0
  289E  370078     bra 0x002990
354:               		
355:               		currentPOS = POSCNT;
  28A0  F80126     push.w 0x0126
  28A2  F90986     pop.w 0x0986
356:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  28A4  804C30     mov.w 0x0986,0x0000
  28A6  E30988     cp.w 0x0988
  28A8  3A0002     bra nz, 0x0028ae
  28AA  AE498A     btss.b 0x098a,#2
  28AC  37003B     bra 0x002924
357:               			
358:               			if (!firstLoopRun)
  28AE  AF498A     btsc.b 0x098a,#2
  28B0  37001D     bra 0x0028ec
359:               			{
360:               				direction = UPDN;
  28B2  A9298A     bclr.b 0x098a,#1
  28B4  AF6123     btsc.b 0x0123,#3
  28B6  A8298A     bset.b 0x098a,#1
361:               				cursorLocation += ((int8)UPDN)*2-1;
  28B8  EB4000     clr.b 0x0000
  28BA  AF6123     btsc.b 0x0123,#3
  28BC  E80000     inc.w 0x0000,0x0000
  28BE  784200     mov.b 0x0000,0x0008
  28C0  EF6009     clr.b 0x0009
  28C2  B82062     mul.uu 0x0008,#2,0x0000
  28C4  504061     sub.b 0x0000,#1,0x0000
  28C6  B4698B     add.b 0x098b
362:               				cursorLocation %= EDIT_LOAD_LIGHT_PH_LOCATION;
  28C8  BFC98B     mov.b 0x098b,0x0000
  28CA  EF6001     clr.b 0x0001
  28CC  EF6001     clr.b 0x0001
  28CE  200034     mov.w #0x3,0x0008
  28D0  FB0000     se 0x0000,0x0000
  28D2  090011     repeat #17
  28D4  D80004     div.sw 0x0000,0x0008
  28D6  784001     mov.b 0x0002,0x0000
  28D8  B7E98B     mov.b 0x0000,0x098b
363:               				if (cursorLocation < 0) cursorLocation += EDIT_LOAD_LIGHT_PH_LOCATION;
  28DA  804C54     mov.w 0x098a,0x0008
  28DC  DE2248     lsr 0x0008,#8,0x0008
  28DE  E12460     cp.b 0x0008,#0
  28E0  3D0005     bra ges, 0x0028ec
  28E2  804C54     mov.w 0x098a,0x0008
  28E4  DE2248     lsr 0x0008,#8,0x0008
  28E6  424263     add.b 0x0008,#3,0x0008
  28E8  784004     mov.b 0x0008,0x0000
  28EA  B7E98B     mov.b 0x0000,0x098b
364:               				
365:               			}
366:               			firstLoopRun = false;
  28EC  A9498A     bclr.b 0x098a,#2
367:               			
368:               			displayLoadLighting();
  28EE  021F84     call 0x001f84
369:               			
370:               			SET_CURSOR_HOME;
  28F2  B3CF80     mov.b #0xf8,0x0000
  28F4  B7E9B4     mov.b 0x0000,0x09b4
  28F6  B3C020     mov.b #0x2,0x0000
  28F8  B7E9B5     mov.b 0x0000,0x09b5
  28FA  020B2C     call 0x000b2c
371:               			int i;
372:               			for (i = 0 ; i < EDIT_LOAD_LIGHT_LOCATION[cursorLocation] ; i++)
  28FE  EF298C     clr.w 0x098c
  2900  BFC98B     mov.b 0x098b,0x0000
  2902  FB0000     se 0x0000,0x0000
  2904  208A24     mov.w #0x8a2,0x0008
  2906  400004     add.w 0x0000,0x0008,0x0000
  2908  780200     mov.w 0x0000,0x0008
  290A  784014     mov.b [0x0008],0x0000
  290C  FB0000     se 0x0000,0x0000
  290E  804C64     mov.w 0x098c,0x0008
  2910  E12000     cp.w 0x0008,0x0000
  2912  3D0008     bra ges, 0x002924
373:               			{
374:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2914  B3CF80     mov.b #0xf8,0x0000
  2916  B7E9B4     mov.b 0x0000,0x09b4
  2918  B3C140     mov.b #0x14,0x0000
  291A  B7E9B5     mov.b 0x0000,0x09b5
  291C  020B2C     call 0x000b2c
375:               			}
  2920  EC298C     inc.w 0x098c
  2922  37FFEE     bra 0x002900
376:               			
377:               		}
378:               		
379:               		if (pushAck)
  2924  AE2966     btss.b 0x0966,#1
  2926  370031     bra 0x00298a
380:               		{
381:                           pushAck = false;
  2928  A92966     bclr.b 0x0966,#1
382:               			beep(true);
  292A  B3C010     mov.b #0x1,0x0000
  292C  B7E9AC     mov.b 0x0000,0x09ac
  292E  021E22     call 0x001e22
383:               			delay_ms(BUZZER_ON_TIME);
  2932  200320     mov.w #0x32,0x0000
  2934  020AEC     call 0x000aec
384:               			beep(false);
  2938  EF69AC     clr.b 0x09ac
  293A  021E22     call 0x001e22
385:               
386:               			//GO TO EDIT OR EXIT MODE
387:               			switch (cursorLocation)
388:               			{
  293E  BFC98B     mov.b 0x098b,0x0000
  2940  EF6001     clr.b 0x0001
  2942  B28000     xor.w #0x0,0x0000
  2944  320005     bra z, 0x002950
  2946  B28010     xor.w #0x1,0x0000
  2948  320010     bra z, 0x00296a
  294A  B28030     xor.w #0x3,0x0000
  294C  32001C     bra z, 0x002986
  294E  37001D     bra 0x00298a
389:               				case 0:
390:               					editField(&maxLoadLighting, 0, 100,displayLoadLighting);
  2950  000000     nop
  2952  B7E001     mov.b 0x0000,0x0001
  2954  21F840     mov.w #0x1f84,0x0000
  2956  780280     mov.w 0x0000,0x000a
  2958  EF699C     clr.b 0x099c
  295A  B3C640     mov.b #0x64,0x0000
  295C  B7E99D     mov.b 0x0000,0x099d
  295E  208BF4     mov.w #0x8bf,0x0008
  2960  884CD4     mov.w 0x0008,0x099a
  2962  884CF5     mov.w 0x000a,0x099e
  2964  0222D6     call 0x0022d6
391:               					break;
  2968  370010     bra 0x00298a
392:               				case 1:
393:               					editField(&delayLoadLighting, 1, 59,displayLoadLighting);
  296A  000000     nop
  296C  B7E001     mov.b 0x0000,0x0001
  296E  21F840     mov.w #0x1f84,0x0000
  2970  780280     mov.w 0x0000,0x000a
  2972  B3C010     mov.b #0x1,0x0000
  2974  B7E99C     mov.b 0x0000,0x099c
  2976  B3C3B0     mov.b #0x3b,0x0000
  2978  B7E99D     mov.b 0x0000,0x099d
  297A  208E04     mov.w #0x8e0,0x0008
  297C  884CD4     mov.w 0x0008,0x099a
  297E  884CF5     mov.w 0x000a,0x099e
  2980  0222D6     call 0x0022d6
394:               					break;
  2984  370002     bra 0x00298a
395:               				case 2:
396:               					exitMenu = true;
  2986  A8098A     bset.b 0x098a,#0
397:               					break;
  2988  370000     bra 0x00298a
398:               			}
399:               		}
400:               		
401:               		previousPOS = currentPOS;
  298A  F80986     push.w 0x0986
  298C  F90988     pop.w 0x0988
402:               	}
  298E  37FF86     bra 0x00289c
403:               }
  2990  7802CF     mov.w [--0x001e],0x000a
  2992  060000     return
404:               
405:               void EditBattery()
406:               {}
407:               
408:               void EditVolume()
409:               {
  2ACE  781F85     mov.w 0x000a,[0x001e++]
  2AD0  EF2988     clr.w 0x0988
  2AD2  A9098A     bclr.b 0x098a,#0
  2AD4  BFC8AC     mov.b 0x08ac,0x0000
  2AD6  B7E98B     mov.b 0x0000,0x098b
410:               	int16 currentPOS;
411:               	int16 previousPOS = 0;
412:               	int1 exitMenu = false;
413:               	int8 cursorLocation = EDIT_VOLUME_LOCATION[0];
414:               	
415:               	//Enter select mode
416:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  2AD8  B3CF80     mov.b #0xf8,0x0000
  2ADA  B7E9B4     mov.b 0x0000,0x09b4
  2ADC  B3C0F0     mov.b #0xf,0x0000
  2ADE  B7E9B5     mov.b 0x0000,0x09b5
  2AE0  020B2C     call 0x000b2c
417:               	
418:               	int1  direction = UP;
419:               	int1  firstLoopRun = TRUE;
  2AE4  A8298A     bset.b 0x098a,#1
  2AE6  A8498A     bset.b 0x098a,#2
420:               	
421:               	
422:               	while (!exitMenu){
  2AE8  AF098A     btsc.b 0x098a,#0
  2AEA  370079     bra 0x002bde
423:               		
424:               		currentPOS = POSCNT;
  2AEC  F80126     push.w 0x0126
  2AEE  F90986     pop.w 0x0986
425:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2AF0  804C30     mov.w 0x0986,0x0000
  2AF2  E30988     cp.w 0x0988
  2AF4  3A0002     bra nz, 0x002afa
  2AF6  AE498A     btss.b 0x098a,#2
  2AF8  37003B     bra 0x002b70
426:               			
427:               			if (!firstLoopRun)
  2AFA  AF498A     btsc.b 0x098a,#2
  2AFC  37001D     bra 0x002b38
428:               			{
429:               				direction = UPDN;
  2AFE  A9298A     bclr.b 0x098a,#1
  2B00  AF6123     btsc.b 0x0123,#3
  2B02  A8298A     bset.b 0x098a,#1
430:               				cursorLocation += ((int8)UPDN)*2-1;
  2B04  EB4000     clr.b 0x0000
  2B06  AF6123     btsc.b 0x0123,#3
  2B08  E80000     inc.w 0x0000,0x0000
  2B0A  784200     mov.b 0x0000,0x0008
  2B0C  EF6009     clr.b 0x0009
  2B0E  B82062     mul.uu 0x0008,#2,0x0000
  2B10  504061     sub.b 0x0000,#1,0x0000
  2B12  B4698B     add.b 0x098b
431:               				cursorLocation %= EDIT_VOLUME_PH_LOCATION;
  2B14  BFC98B     mov.b 0x098b,0x0000
  2B16  EF6001     clr.b 0x0001
  2B18  EF6001     clr.b 0x0001
  2B1A  200034     mov.w #0x3,0x0008
  2B1C  FB0000     se 0x0000,0x0000
  2B1E  090011     repeat #17
  2B20  D80004     div.sw 0x0000,0x0008
  2B22  784001     mov.b 0x0002,0x0000
  2B24  B7E98B     mov.b 0x0000,0x098b
432:               				if (cursorLocation < 0) cursorLocation += EDIT_VOLUME_PH_LOCATION;
  2B26  804C54     mov.w 0x098a,0x0008
  2B28  DE2248     lsr 0x0008,#8,0x0008
  2B2A  E12460     cp.b 0x0008,#0
  2B2C  3D0005     bra ges, 0x002b38
  2B2E  804C54     mov.w 0x098a,0x0008
  2B30  DE2248     lsr 0x0008,#8,0x0008
  2B32  424263     add.b 0x0008,#3,0x0008
  2B34  784004     mov.b 0x0008,0x0000
  2B36  B7E98B     mov.b 0x0000,0x098b
433:               				
434:               			}
435:               			firstLoopRun = false;
  2B38  A9498A     bclr.b 0x098a,#2
436:               			
437:               			displayVolume();
  2B3A  022090     call 0x002090
438:               			
439:               			SET_CURSOR_HOME;
  2B3E  B3CF80     mov.b #0xf8,0x0000
  2B40  B7E9B4     mov.b 0x0000,0x09b4
  2B42  B3C020     mov.b #0x2,0x0000
  2B44  B7E9B5     mov.b 0x0000,0x09b5
  2B46  020B2C     call 0x000b2c
440:               			int i;
441:               			for (i = 0 ; i < EDIT_VOLUME_LOCATION[cursorLocation] ; i++)
  2B4A  EF298C     clr.w 0x098c
  2B4C  BFC98B     mov.b 0x098b,0x0000
  2B4E  FB0000     se 0x0000,0x0000
  2B50  208AC4     mov.w #0x8ac,0x0008
  2B52  400004     add.w 0x0000,0x0008,0x0000
  2B54  780200     mov.w 0x0000,0x0008
  2B56  784014     mov.b [0x0008],0x0000
  2B58  FB0000     se 0x0000,0x0000
  2B5A  804C64     mov.w 0x098c,0x0008
  2B5C  E12000     cp.w 0x0008,0x0000
  2B5E  3D0008     bra ges, 0x002b70
442:               			{
443:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2B60  B3CF80     mov.b #0xf8,0x0000
  2B62  B7E9B4     mov.b 0x0000,0x09b4
  2B64  B3C140     mov.b #0x14,0x0000
  2B66  B7E9B5     mov.b 0x0000,0x09b5
  2B68  020B2C     call 0x000b2c
444:               			}
  2B6C  EC298C     inc.w 0x098c
  2B6E  37FFEE     bra 0x002b4c
445:               			
446:               		}
447:               		
448:               		if (pushAck)
  2B70  AE2966     btss.b 0x0966,#1
  2B72  370032     bra 0x002bd8
449:               		{
450:                           pushAck = false;
  2B74  A92966     bclr.b 0x0966,#1
451:               			beep(true);
  2B76  B3C010     mov.b #0x1,0x0000
  2B78  B7E9AC     mov.b 0x0000,0x09ac
  2B7A  021E22     call 0x001e22
452:               			delay_ms(BUZZER_ON_TIME);
  2B7E  200320     mov.w #0x32,0x0000
  2B80  020AEC     call 0x000aec
453:               			beep(false);
  2B84  EF69AC     clr.b 0x09ac
  2B86  021E22     call 0x001e22
454:               			//GO TO EDIT OR EXIT MODE
455:               			switch (cursorLocation)
456:               			{
  2B8A  BFC98B     mov.b 0x098b,0x0000
  2B8C  EF6001     clr.b 0x0001
  2B8E  B28000     xor.w #0x0,0x0000
  2B90  320005     bra z, 0x002b9c
  2B92  B28010     xor.w #0x1,0x0000
  2B94  320011     bra z, 0x002bb8
  2B96  B28030     xor.w #0x3,0x0000
  2B98  32001D     bra z, 0x002bd4
  2B9A  37001E     bra 0x002bd8
457:               				case 0:
458:               					editField(&chimeVolume, MIN_VOLUME, MAX_VOLUME,displayVolume);
  2B9C  000000     nop
  2B9E  B7E001     mov.b 0x0000,0x0001
  2BA0  220900     mov.w #0x2090,0x0000
  2BA2  780280     mov.w 0x0000,0x000a
  2BA4  B3C010     mov.b #0x1,0x0000
  2BA6  B7E99C     mov.b 0x0000,0x099c
  2BA8  B3C640     mov.b #0x64,0x0000
  2BAA  B7E99D     mov.b 0x0000,0x099d
  2BAC  208B34     mov.w #0x8b3,0x0008
  2BAE  884CD4     mov.w 0x0008,0x099a
  2BB0  884CF5     mov.w 0x000a,0x099e
  2BB2  0222D6     call 0x0022d6
459:               					break;
  2BB6  370010     bra 0x002bd8
460:               				case 1:
461:               					editField(&toneSelect, 1, TONE_COUNT,displayVolume);
  2BB8  000000     nop
  2BBA  B7E001     mov.b 0x0000,0x0001
  2BBC  220900     mov.w #0x2090,0x0000
  2BBE  780280     mov.w 0x0000,0x000a
  2BC0  B3C010     mov.b #0x1,0x0000
  2BC2  B7E99C     mov.b 0x0000,0x099c
  2BC4  B3C010     mov.b #0x1,0x0000
  2BC6  B7E99D     mov.b 0x0000,0x099d
  2BC8  208BE4     mov.w #0x8be,0x0008
  2BCA  884CD4     mov.w 0x0008,0x099a
  2BCC  884CF5     mov.w 0x000a,0x099e
  2BCE  0222D6     call 0x0022d6
462:               					break;
  2BD2  370002     bra 0x002bd8
463:               				case 2:
464:               					exitMenu = true;
  2BD4  A8098A     bset.b 0x098a,#0
465:               					break;
  2BD6  370000     bra 0x002bd8
466:               			}
467:               		}
468:               		
469:               		previousPOS = currentPOS;
  2BD8  F80986     push.w 0x0986
  2BDA  F90988     pop.w 0x0988
470:               	}
  2BDC  37FF85     bra 0x002ae8
471:               }
  2BDE  7802CF     mov.w [--0x001e],0x000a
  2BE0  060000     return
472:               
473:               
474:               void EditCarillon()
475:               {
  2604  781F85     mov.w 0x000a,[0x001e++]
  2606  EF2988     clr.w 0x0988
  2608  A9098A     bclr.b 0x098a,#0
  260A  BFC890     mov.b 0x0890,0x0000
  260C  B7E98B     mov.b 0x0000,0x098b
476:               	int16 currentPOS;
477:               	int16 previousPOS = 0;
478:               	int1 exitMenu = false;
479:               	int8 cursorLocation = EDIT_CARILLON_LOCATION[0];
480:               	
481:               	//Enter select mode
482:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  260E  B3CF80     mov.b #0xf8,0x0000
  2610  B7E9B4     mov.b 0x0000,0x09b4
  2612  B3C0F0     mov.b #0xf,0x0000
  2614  B7E9B5     mov.b 0x0000,0x09b5
  2616  020B2C     call 0x000b2c
483:               	
484:               	int1  direction = UP;
485:               	int1  firstLoopRun = TRUE;
  261A  A8298A     bset.b 0x098a,#1
  261C  A8498A     bset.b 0x098a,#2
486:               	
487:               	
488:               	while (!exitMenu){
  261E  AF098A     btsc.b 0x098a,#0
  2620  37005F     bra 0x0026e0
489:               		
490:               		currentPOS = POSCNT;
  2622  F80126     push.w 0x0126
  2624  F90986     pop.w 0x0986
491:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2626  804C30     mov.w 0x0986,0x0000
  2628  E30988     cp.w 0x0988
  262A  3A0002     bra nz, 0x002630
  262C  AE498A     btss.b 0x098a,#2
  262E  37003B     bra 0x0026a6
492:               			
493:               			if (!firstLoopRun)
  2630  AF498A     btsc.b 0x098a,#2
  2632  37001D     bra 0x00266e
494:               			{
495:               				direction = UPDN;
  2634  A9298A     bclr.b 0x098a,#1
  2636  AF6123     btsc.b 0x0123,#3
  2638  A8298A     bset.b 0x098a,#1
496:               				cursorLocation += ((int8)UPDN)*2-1;
  263A  EB4000     clr.b 0x0000
  263C  AF6123     btsc.b 0x0123,#3
  263E  E80000     inc.w 0x0000,0x0000
  2640  784200     mov.b 0x0000,0x0008
  2642  EF6009     clr.b 0x0009
  2644  B82062     mul.uu 0x0008,#2,0x0000
  2646  504061     sub.b 0x0000,#1,0x0000
  2648  B4698B     add.b 0x098b
497:               				cursorLocation %= EDIT_CARILLON_PH_LOCATION;
  264A  BFC98B     mov.b 0x098b,0x0000
  264C  EF6001     clr.b 0x0001
  264E  EF6001     clr.b 0x0001
  2650  200024     mov.w #0x2,0x0008
  2652  FB0000     se 0x0000,0x0000
  2654  090011     repeat #17
  2656  D80004     div.sw 0x0000,0x0008
  2658  784001     mov.b 0x0002,0x0000
  265A  B7E98B     mov.b 0x0000,0x098b
498:               				if (cursorLocation < 0) cursorLocation += EDIT_CARILLON_PH_LOCATION;
  265C  804C54     mov.w 0x098a,0x0008
  265E  DE2248     lsr 0x0008,#8,0x0008
  2660  E12460     cp.b 0x0008,#0
  2662  3D0005     bra ges, 0x00266e
  2664  804C54     mov.w 0x098a,0x0008
  2666  DE2248     lsr 0x0008,#8,0x0008
  2668  424262     add.b 0x0008,#2,0x0008
  266A  784004     mov.b 0x0008,0x0000
  266C  B7E98B     mov.b 0x0000,0x098b
499:               				
500:               			}
501:               			firstLoopRun = false;
  266E  A9498A     bclr.b 0x098a,#2
502:               			
503:               			displayCarillon();
  2670  0225A4     call 0x0025a4
504:               			
505:               			SET_CURSOR_HOME;
  2674  B3CF80     mov.b #0xf8,0x0000
  2676  B7E9B4     mov.b 0x0000,0x09b4
  2678  B3C020     mov.b #0x2,0x0000
  267A  B7E9B5     mov.b 0x0000,0x09b5
  267C  020B2C     call 0x000b2c
506:               			int i;
507:               			for (i = 0 ; i < EDIT_CARILLON_LOCATION[cursorLocation] ; i++)
  2680  EF298C     clr.w 0x098c
  2682  BFC98B     mov.b 0x098b,0x0000
  2684  FB0000     se 0x0000,0x0000
  2686  208904     mov.w #0x890,0x0008
  2688  400004     add.w 0x0000,0x0008,0x0000
  268A  780200     mov.w 0x0000,0x0008
  268C  784014     mov.b [0x0008],0x0000
  268E  FB0000     se 0x0000,0x0000
  2690  804C64     mov.w 0x098c,0x0008
  2692  E12000     cp.w 0x0008,0x0000
  2694  3D0008     bra ges, 0x0026a6
508:               			{
509:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2696  B3CF80     mov.b #0xf8,0x0000
  2698  B7E9B4     mov.b 0x0000,0x09b4
  269A  B3C140     mov.b #0x14,0x0000
  269C  B7E9B5     mov.b 0x0000,0x09b5
  269E  020B2C     call 0x000b2c
510:               			}
  26A2  EC298C     inc.w 0x098c
  26A4  37FFEE     bra 0x002682
511:               			
512:               		}
513:               		
514:               		if (pushAck)
  26A6  AE2966     btss.b 0x0966,#1
  26A8  370018     bra 0x0026da
515:               		{
516:                           pushAck = false;
  26AA  A92966     bclr.b 0x0966,#1
517:               			beep(true);
  26AC  B3C010     mov.b #0x1,0x0000
  26AE  B7E9AC     mov.b 0x0000,0x09ac
  26B0  021E22     call 0x001e22
518:               			delay_ms(BUZZER_ON_TIME);
  26B4  200320     mov.w #0x32,0x0000
  26B6  020AEC     call 0x000aec
519:               			beep(false);
  26BA  EF69AC     clr.b 0x09ac
  26BC  021E22     call 0x001e22
520:               
521:               			//GO TO EDIT OR EXIT MODE
522:               			switch (cursorLocation)
523:               			{
  26C0  BFC98B     mov.b 0x098b,0x0000
  26C2  EF6001     clr.b 0x0001
  26C4  B28000     xor.w #0x0,0x0000
  26C6  320003     bra z, 0x0026ce
  26C8  B28010     xor.w #0x1,0x0000
  26CA  320005     bra z, 0x0026d6
  26CC  370006     bra 0x0026da
524:               				case 0:
525:               					carillon = !carillon;
  26CE  AA4885     btg.b 0x0885,#2
526:               					displayCarillon();
  26D0  0225A4     call 0x0025a4
527:               					break;
  26D4  370002     bra 0x0026da
528:               				case 1:
529:               					exitMenu = true;
  26D6  A8098A     bset.b 0x098a,#0
530:               					break;
  26D8  370000     bra 0x0026da
531:               			}
532:               		}
533:               		
534:               		previousPOS = currentPOS;
  26DA  F80986     push.w 0x0986
  26DC  F90988     pop.w 0x0988
535:               	}
  26DE  37FF9F     bra 0x00261e
536:               }
  26E0  7802CF     mov.w [--0x001e],0x000a
  26E2  060000     return
537:               
538:               
539:               void EditAlarmSnooze()
540:               {
  236C  781F85     mov.w 0x000a,[0x001e++]
  236E  EF2990     clr.w 0x0990
  2370  A90992     bclr.b 0x0992,#0
  2372  BFC8A0     mov.b 0x08a0,0x0000
  2374  B7E993     mov.b 0x0000,0x0993
541:               	int16 currentPOS;
542:               	int16 previousPOS = 0;
543:               	int1 exitMenu = false;
544:               	int8 cursorLocation = EDIT_ALARM_SNOOZE_LOCATION[0];
545:               	
546:               	//Enter select mode
547:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  2376  B3CF80     mov.b #0xf8,0x0000
  2378  B7E9B4     mov.b 0x0000,0x09b4
  237A  B3C0F0     mov.b #0xf,0x0000
  237C  B7E9B5     mov.b 0x0000,0x09b5
  237E  020B2C     call 0x000b2c
548:               	
549:               	int1  direction = UP;
550:               	int1  firstLoopRun = TRUE;
  2382  A82992     bset.b 0x0992,#1
  2384  A84992     bset.b 0x0992,#2
551:               	
552:               	while (!exitMenu){
  2386  AF0992     btsc.b 0x0992,#0
  2388  370069     bra 0x00245c
553:               		
554:               		currentPOS = POSCNT;
  238A  F80126     push.w 0x0126
  238C  F9098E     pop.w 0x098e
555:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  238E  804C70     mov.w 0x098e,0x0000
  2390  E30990     cp.w 0x0990
  2392  3A0002     bra nz, 0x002398
  2394  AE4992     btss.b 0x0992,#2
  2396  37003B     bra 0x00240e
556:               			
557:               			if (!firstLoopRun)
  2398  AF4992     btsc.b 0x0992,#2
  239A  37001D     bra 0x0023d6
558:               			{
559:               				direction = UPDN;
  239C  A92992     bclr.b 0x0992,#1
  239E  AF6123     btsc.b 0x0123,#3
  23A0  A82992     bset.b 0x0992,#1
560:               				cursorLocation += ((int8)UPDN)*2-1;
  23A2  EB4000     clr.b 0x0000
  23A4  AF6123     btsc.b 0x0123,#3
  23A6  E80000     inc.w 0x0000,0x0000
  23A8  784200     mov.b 0x0000,0x0008
  23AA  EF6009     clr.b 0x0009
  23AC  B82062     mul.uu 0x0008,#2,0x0000
  23AE  504061     sub.b 0x0000,#1,0x0000
  23B0  B46993     add.b 0x0993
561:               				cursorLocation %= EDIT_ALARM_SNOOZE_PH_LOCATION;
  23B2  BFC993     mov.b 0x0993,0x0000
  23B4  EF6001     clr.b 0x0001
  23B6  EF6001     clr.b 0x0001
  23B8  200024     mov.w #0x2,0x0008
  23BA  FB0000     se 0x0000,0x0000
  23BC  090011     repeat #17
  23BE  D80004     div.sw 0x0000,0x0008
  23C0  784001     mov.b 0x0002,0x0000
  23C2  B7E993     mov.b 0x0000,0x0993
562:               				if (cursorLocation < 0) cursorLocation += EDIT_ALARM_SNOOZE_PH_LOCATION;
  23C4  804C94     mov.w 0x0992,0x0008
  23C6  DE2248     lsr 0x0008,#8,0x0008
  23C8  E12460     cp.b 0x0008,#0
  23CA  3D0005     bra ges, 0x0023d6
  23CC  804C94     mov.w 0x0992,0x0008
  23CE  DE2248     lsr 0x0008,#8,0x0008
  23D0  424262     add.b 0x0008,#2,0x0008
  23D2  784004     mov.b 0x0008,0x0000
  23D4  B7E993     mov.b 0x0000,0x0993
563:               				
564:               			}
565:               			firstLoopRun = false;
  23D6  A94992     bclr.b 0x0992,#2
566:               			
567:               			displaySnooze();
  23D8  021F2C     call 0x001f2c
568:               			
569:               			SET_CURSOR_HOME;
  23DC  B3CF80     mov.b #0xf8,0x0000
  23DE  B7E9B4     mov.b 0x0000,0x09b4
  23E0  B3C020     mov.b #0x2,0x0000
  23E2  B7E9B5     mov.b 0x0000,0x09b5
  23E4  020B2C     call 0x000b2c
570:               			int i;
571:               			for (i = 0 ; i < EDIT_ALARM_SNOOZE_LOCATION[cursorLocation] ; i++)
  23E8  EF2994     clr.w 0x0994
  23EA  BFC993     mov.b 0x0993,0x0000
  23EC  FB0000     se 0x0000,0x0000
  23EE  208A04     mov.w #0x8a0,0x0008
  23F0  400004     add.w 0x0000,0x0008,0x0000
  23F2  780200     mov.w 0x0000,0x0008
  23F4  784014     mov.b [0x0008],0x0000
  23F6  FB0000     se 0x0000,0x0000
  23F8  804CA4     mov.w 0x0994,0x0008
  23FA  E12000     cp.w 0x0008,0x0000
  23FC  3D0008     bra ges, 0x00240e
572:               			{
573:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  23FE  B3CF80     mov.b #0xf8,0x0000
  2400  B7E9B4     mov.b 0x0000,0x09b4
  2402  B3C140     mov.b #0x14,0x0000
  2404  B7E9B5     mov.b 0x0000,0x09b5
  2406  020B2C     call 0x000b2c
574:               			}
  240A  EC2994     inc.w 0x0994
  240C  37FFEE     bra 0x0023ea
575:               			
576:               		}
577:               		
578:               		if (pushAck)
  240E  AE2966     btss.b 0x0966,#1
  2410  370022     bra 0x002456
579:               		{
580:                           pushAck = false;
  2412  A92966     bclr.b 0x0966,#1
581:               			beep(true);
  2414  B3C010     mov.b #0x1,0x0000
  2416  B7E9AC     mov.b 0x0000,0x09ac
  2418  021E22     call 0x001e22
582:               			delay_ms(BUZZER_ON_TIME);
  241C  200320     mov.w #0x32,0x0000
  241E  020AEC     call 0x000aec
583:               			beep(false);
  2422  EF69AC     clr.b 0x09ac
  2424  021E22     call 0x001e22
584:               
585:               			//GO TO EDIT OR EXIT MODE
586:               			switch (cursorLocation)
587:               			{
  2428  BFC993     mov.b 0x0993,0x0000
  242A  EF6001     clr.b 0x0001
  242C  B28000     xor.w #0x0,0x0000
  242E  320003     bra z, 0x002436
  2430  B28010     xor.w #0x1,0x0000
  2432  32000F     bra z, 0x002452
  2434  370010     bra 0x002456
588:               				case 0:
589:               					editField(&AlarmSnoozeTime,1,30,displaySnooze);
  2436  000000     nop
  2438  B7E001     mov.b 0x0000,0x0001
  243A  21F2C0     mov.w #0x1f2c,0x0000
  243C  780280     mov.w 0x0000,0x000a
  243E  B3C010     mov.b #0x1,0x0000
  2440  B7E99C     mov.b 0x0000,0x099c
  2442  B3C1E0     mov.b #0x1e,0x0000
  2444  B7E99D     mov.b 0x0000,0x099d
  2446  208E14     mov.w #0x8e1,0x0008
  2448  884CD4     mov.w 0x0008,0x099a
  244A  884CF5     mov.w 0x000a,0x099e
  244C  0222D6     call 0x0022d6
590:               					break;
  2450  370002     bra 0x002456
591:               				case 1:
592:               					exitMenu = true;
  2452  A80992     bset.b 0x0992,#0
593:               					break;
  2454  370000     bra 0x002456
594:               			}
595:               		}
596:               		
597:               		previousPOS = currentPOS;
  2456  F8098E     push.w 0x098e
  2458  F90990     pop.w 0x0990
598:               	}
  245A  37FF95     bra 0x002386
599:                   
600:                   FindNextAlarmTime();
  245C  021830     call 0x001830
601:               }
  2460  7802CF     mov.w [--0x001e],0x000a
  2462  060000     return
602:               
603:               void EditRGBLighting()
604:               {
  2994  781F85     mov.w 0x000a,[0x001e++]
  2996  EF2988     clr.w 0x0988
  2998  A9098A     bclr.b 0x098a,#0
  299A  BFC8A6     mov.b 0x08a6,0x0000
  299C  B7E98B     mov.b 0x0000,0x098b
605:               	int16 currentPOS;
606:               	int16 previousPOS = 0;
607:               	int1 exitMenu = false;
608:               	int8 cursorLocation = EDIT_RGB_LIGHT_LOCATION[0];
609:               	
610:               	//Enter select mode
611:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  299E  B3CF80     mov.b #0xf8,0x0000
  29A0  B7E9B4     mov.b 0x0000,0x09b4
  29A2  B3C0F0     mov.b #0xf,0x0000
  29A4  B7E9B5     mov.b 0x0000,0x09b5
  29A6  020B2C     call 0x000b2c
612:               	
613:               	int1  direction = UP;
614:               	int1  firstLoopRun = TRUE;
  29AA  A8298A     bset.b 0x098a,#1
  29AC  A8498A     bset.b 0x098a,#2
615:               	
616:               	while (!exitMenu){
  29AE  AF098A     btsc.b 0x098a,#0
  29B0  37008C     bra 0x002aca
617:               		
618:               		currentPOS = POSCNT;
  29B2  F80126     push.w 0x0126
  29B4  F90986     pop.w 0x0986
619:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  29B6  804C30     mov.w 0x0986,0x0000
  29B8  E30988     cp.w 0x0988
  29BA  3A0002     bra nz, 0x0029c0
  29BC  AE498A     btss.b 0x098a,#2
  29BE  37003B     bra 0x002a36
620:               			
621:               			if (!firstLoopRun)
  29C0  AF498A     btsc.b 0x098a,#2
  29C2  37001D     bra 0x0029fe
622:               			{
623:               				direction = UPDN;
  29C4  A9298A     bclr.b 0x098a,#1
  29C6  AF6123     btsc.b 0x0123,#3
  29C8  A8298A     bset.b 0x098a,#1
624:               				cursorLocation += ((int8)UPDN)*2-1;
  29CA  EB4000     clr.b 0x0000
  29CC  AF6123     btsc.b 0x0123,#3
  29CE  E80000     inc.w 0x0000,0x0000
  29D0  784200     mov.b 0x0000,0x0008
  29D2  EF6009     clr.b 0x0009
  29D4  B82062     mul.uu 0x0008,#2,0x0000
  29D6  504061     sub.b 0x0000,#1,0x0000
  29D8  B4698B     add.b 0x098b
625:               				cursorLocation %= EDIT_RGB_LIGHT_PH_LOCATION;
  29DA  BFC98B     mov.b 0x098b,0x0000
  29DC  EF6001     clr.b 0x0001
  29DE  EF6001     clr.b 0x0001
  29E0  200054     mov.w #0x5,0x0008
  29E2  FB0000     se 0x0000,0x0000
  29E4  090011     repeat #17
  29E6  D80004     div.sw 0x0000,0x0008
  29E8  784001     mov.b 0x0002,0x0000
  29EA  B7E98B     mov.b 0x0000,0x098b
626:               				if (cursorLocation < 0) cursorLocation += EDIT_RGB_LIGHT_PH_LOCATION;
  29EC  804C54     mov.w 0x098a,0x0008
  29EE  DE2248     lsr 0x0008,#8,0x0008
  29F0  E12460     cp.b 0x0008,#0
  29F2  3D0005     bra ges, 0x0029fe
  29F4  804C54     mov.w 0x098a,0x0008
  29F6  DE2248     lsr 0x0008,#8,0x0008
  29F8  424265     add.b 0x0008,#5,0x0008
  29FA  784004     mov.b 0x0008,0x0000
  29FC  B7E98B     mov.b 0x0000,0x098b
627:               				
628:               			}
629:               			firstLoopRun = false;
  29FE  A9498A     bclr.b 0x098a,#2
630:               			
631:               			displayRGBLight();
  2A00  021FE6     call 0x001fe6
632:               			
633:               			SET_CURSOR_HOME;
  2A04  B3CF80     mov.b #0xf8,0x0000
  2A06  B7E9B4     mov.b 0x0000,0x09b4
  2A08  B3C020     mov.b #0x2,0x0000
  2A0A  B7E9B5     mov.b 0x0000,0x09b5
  2A0C  020B2C     call 0x000b2c
634:               			int i;
635:               			for (i = 0 ; i < EDIT_RGB_LIGHT_LOCATION[cursorLocation] ; i++)
  2A10  EF298C     clr.w 0x098c
  2A12  BFC98B     mov.b 0x098b,0x0000
  2A14  FB0000     se 0x0000,0x0000
  2A16  208A64     mov.w #0x8a6,0x0008
  2A18  400004     add.w 0x0000,0x0008,0x0000
  2A1A  780200     mov.w 0x0000,0x0008
  2A1C  784014     mov.b [0x0008],0x0000
  2A1E  FB0000     se 0x0000,0x0000
  2A20  804C64     mov.w 0x098c,0x0008
  2A22  E12000     cp.w 0x0008,0x0000
  2A24  3D0008     bra ges, 0x002a36
636:               			{
637:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2A26  B3CF80     mov.b #0xf8,0x0000
  2A28  B7E9B4     mov.b 0x0000,0x09b4
  2A2A  B3C140     mov.b #0x14,0x0000
  2A2C  B7E9B5     mov.b 0x0000,0x09b5
  2A2E  020B2C     call 0x000b2c
638:               			}
  2A32  EC298C     inc.w 0x098c
  2A34  37FFEE     bra 0x002a12
639:               			
640:               		}
641:               		
642:               		if (pushAck)
  2A36  AE2966     btss.b 0x0966,#1
  2A38  370045     bra 0x002ac4
643:               		{
644:                           pushAck = false;
  2A3A  A92966     bclr.b 0x0966,#1
645:               			beep(true);
  2A3C  B3C010     mov.b #0x1,0x0000
  2A3E  B7E9AC     mov.b 0x0000,0x09ac
  2A40  021E22     call 0x001e22
646:               			delay_ms(BUZZER_ON_TIME);
  2A44  200320     mov.w #0x32,0x0000
  2A46  020AEC     call 0x000aec
647:               			beep(false);
  2A4A  EF69AC     clr.b 0x09ac
  2A4C  021E22     call 0x001e22
648:               
649:               			//GO TO EDIT OR EXIT MODE
650:               			switch (cursorLocation)
651:               			{
  2A50  BFC98B     mov.b 0x098b,0x0000
  2A52  EF6001     clr.b 0x0001
  2A54  B28000     xor.w #0x0,0x0000
  2A56  320009     bra z, 0x002a6a
  2A58  B28010     xor.w #0x1,0x0000
  2A5A  32000B     bra z, 0x002a72
  2A5C  B28030     xor.w #0x3,0x0000
  2A5E  320016     bra z, 0x002a8c
  2A60  B28010     xor.w #0x1,0x0000
  2A62  320021     bra z, 0x002aa6
  2A64  B28070     xor.w #0x7,0x0000
  2A66  32002C     bra z, 0x002ac0
  2A68  37002D     bra 0x002ac4
652:               				case 0:
653:               					moodEnable = !moodEnable;
  2A6A  AA2885     btg.b 0x0885,#1
654:               					displayRGBLight();
  2A6C  021FE6     call 0x001fe6
655:               					break;
  2A70  370029     bra 0x002ac4
656:               				case 1:
657:               					editIntField(&hsvColor.hue,0,359,displayRGBLight);
  2A72  000000     nop
  2A74  B7E001     mov.b 0x0000,0x0001
  2A76  21FE60     mov.w #0x1fe6,0x0000
  2A78  780280     mov.w 0x0000,0x000a
  2A7A  EF2994     clr.w 0x0994
  2A7C  208B84     mov.w #0x8b8,0x0008
  2A7E  884C94     mov.w 0x0008,0x0992
  2A80  201674     mov.w #0x167,0x0008
  2A82  884CB4     mov.w 0x0008,0x0996
  2A84  884CC5     mov.w 0x000a,0x0998
  2A86  0220F2     call 0x0020f2
658:               					break;
  2A8A  37001C     bra 0x002ac4
659:               				case 2:
660:               					editField(&hsvColor.saturation,0,255,displayRGBLight);
  2A8C  000000     nop
  2A8E  B7E001     mov.b 0x0000,0x0001
  2A90  21FE60     mov.w #0x1fe6,0x0000
  2A92  780280     mov.w 0x0000,0x000a
  2A94  EF699C     clr.b 0x099c
  2A96  B3CFF0     mov.b #0xff,0x0000
  2A98  B7E99D     mov.b 0x0000,0x099d
  2A9A  208BA4     mov.w #0x8ba,0x0008
  2A9C  884CD4     mov.w 0x0008,0x099a
  2A9E  884CF5     mov.w 0x000a,0x099e
  2AA0  0222D6     call 0x0022d6
661:               					break;
  2AA4  37000F     bra 0x002ac4
662:               				case 3:
663:               					editField(&hsvColor.value,0,255,displayRGBLight);
  2AA6  000000     nop
  2AA8  B7E001     mov.b 0x0000,0x0001
  2AAA  21FE60     mov.w #0x1fe6,0x0000
  2AAC  780280     mov.w 0x0000,0x000a
  2AAE  EF699C     clr.b 0x099c
  2AB0  B3CFF0     mov.b #0xff,0x0000
  2AB2  B7E99D     mov.b 0x0000,0x099d
  2AB4  208BB4     mov.w #0x8bb,0x0008
  2AB6  884CD4     mov.w 0x0008,0x099a
  2AB8  884CF5     mov.w 0x000a,0x099e
  2ABA  0222D6     call 0x0022d6
664:               					break;
  2ABE  370002     bra 0x002ac4
665:               				case 4:
666:               					exitMenu = true;
  2AC0  A8098A     bset.b 0x098a,#0
667:               					break;
  2AC2  370000     bra 0x002ac4
668:               			}
669:               		}
670:               		
671:               		previousPOS = currentPOS;
  2AC4  F80986     push.w 0x0986
  2AC6  F90988     pop.w 0x0988
672:               	}
  2AC8  37FF72     bra 0x0029ae
673:               }
  2ACA  7802CF     mov.w [--0x001e],0x000a
  2ACC  060000     return
674:               
675:               void EditPowerCtrls()
676:               {
  2C62  781F85     mov.w 0x000a,[0x001e++]
  2C64  EF2988     clr.w 0x0988
  2C66  A9098A     bclr.b 0x098a,#0
  2C68  BFC8B0     mov.b 0x08b0,0x0000
  2C6A  B7E98B     mov.b 0x0000,0x098b
677:               	int16 currentPOS;
678:               	int16 previousPOS = 0;
679:               	int1 exitMenu = false;
680:               	int8 cursorLocation = EDIT_LOAD_DISPLAY_LOCATION[0];
681:               	
682:               	//Enter select mode
683:               	writeToLCD(LCD_WRITE_CFG,LCD_DSPL_DFLT);
  2C6C  B3CF80     mov.b #0xf8,0x0000
  2C6E  B7E9B4     mov.b 0x0000,0x09b4
  2C70  B3C0F0     mov.b #0xf,0x0000
  2C72  B7E9B5     mov.b 0x0000,0x09b5
  2C74  020B2C     call 0x000b2c
684:               	
685:               	int1  direction = UP;
686:               	int1  firstLoopRun = TRUE;
  2C78  A8298A     bset.b 0x098a,#1
  2C7A  A8498A     bset.b 0x098a,#2
687:               	
688:               	while (!exitMenu){
  2C7C  AF098A     btsc.b 0x098a,#0
  2C7E  37005F     bra 0x002d3e
689:               		
690:               		currentPOS = POSCNT;
  2C80  F80126     push.w 0x0126
  2C82  F90986     pop.w 0x0986
691:               		if ((currentPOS != previousPOS) || (firstLoopRun)) {
  2C84  804C30     mov.w 0x0986,0x0000
  2C86  E30988     cp.w 0x0988
  2C88  3A0002     bra nz, 0x002c8e
  2C8A  AE498A     btss.b 0x098a,#2
  2C8C  370039     bra 0x002d00
692:               			
693:               			if (!firstLoopRun)
  2C8E  AF498A     btsc.b 0x098a,#2
  2C90  37001D     bra 0x002ccc
694:               			{
695:               				direction = UPDN;
  2C92  A9298A     bclr.b 0x098a,#1
  2C94  AF6123     btsc.b 0x0123,#3
  2C96  A8298A     bset.b 0x098a,#1
696:               				cursorLocation += ((int8)UPDN)*2-1;
  2C98  EB4000     clr.b 0x0000
  2C9A  AF6123     btsc.b 0x0123,#3
  2C9C  E80000     inc.w 0x0000,0x0000
  2C9E  784200     mov.b 0x0000,0x0008
  2CA0  EF6009     clr.b 0x0009
  2CA2  B82062     mul.uu 0x0008,#2,0x0000
  2CA4  504061     sub.b 0x0000,#1,0x0000
  2CA6  B4698B     add.b 0x098b
697:               				cursorLocation %= EDIT_LOAD_DISPLAY_PH_LOCATION;
  2CA8  BFC98B     mov.b 0x098b,0x0000
  2CAA  EF6001     clr.b 0x0001
  2CAC  EF6001     clr.b 0x0001
  2CAE  200034     mov.w #0x3,0x0008
  2CB0  FB0000     se 0x0000,0x0000
  2CB2  090011     repeat #17
  2CB4  D80004     div.sw 0x0000,0x0008
  2CB6  784001     mov.b 0x0002,0x0000
  2CB8  B7E98B     mov.b 0x0000,0x098b
698:               				if (cursorLocation < 0) cursorLocation += EDIT_LOAD_DISPLAY_PH_LOCATION;
  2CBA  804C54     mov.w 0x098a,0x0008
  2CBC  DE2248     lsr 0x0008,#8,0x0008
  2CBE  E12460     cp.b 0x0008,#0
  2CC0  3D0005     bra ges, 0x002ccc
  2CC2  804C54     mov.w 0x098a,0x0008
  2CC4  DE2248     lsr 0x0008,#8,0x0008
  2CC6  424263     add.b 0x0008,#3,0x0008
  2CC8  784004     mov.b 0x0008,0x0000
  2CCA  B7E98B     mov.b 0x0000,0x098b
699:               				
700:               			}
701:               			firstLoopRun = false;
  2CCC  A9498A     bclr.b 0x098a,#2
702:               			
703:               			//displayPowerCtrls();
704:               			
705:               			SET_CURSOR_HOME;
  2CCE  B3CF80     mov.b #0xf8,0x0000
  2CD0  B7E9B4     mov.b 0x0000,0x09b4
  2CD2  B3C020     mov.b #0x2,0x0000
  2CD4  B7E9B5     mov.b 0x0000,0x09b5
  2CD6  020B2C     call 0x000b2c
706:               			int i;
707:               			for (i = 0 ; i < EDIT_LOAD_DISPLAY_LOCATION[cursorLocation] ; i++)
  2CDA  EF298C     clr.w 0x098c
  2CDC  BFC98B     mov.b 0x098b,0x0000
  2CDE  FB0000     se 0x0000,0x0000
  2CE0  208B04     mov.w #0x8b0,0x0008
  2CE2  400004     add.w 0x0000,0x0008,0x0000
  2CE4  780200     mov.w 0x0000,0x0008
  2CE6  784014     mov.b [0x0008],0x0000
  2CE8  FB0000     se 0x0000,0x0000
  2CEA  804C64     mov.w 0x098c,0x0008
  2CEC  E12000     cp.w 0x0008,0x0000
  2CEE  3D0008     bra ges, 0x002d00
708:               			{
709:               				writeToLCD(LCD_WRITE_CFG, LCD_CSR_RIGHT);
  2CF0  B3CF80     mov.b #0xf8,0x0000
  2CF2  B7E9B4     mov.b 0x0000,0x09b4
  2CF4  B3C140     mov.b #0x14,0x0000
  2CF6  B7E9B5     mov.b 0x0000,0x09b5
  2CF8  020B2C     call 0x000b2c
710:               			}
  2CFC  EC298C     inc.w 0x098c
  2CFE  37FFEE     bra 0x002cdc
711:               			
712:               		}
713:               		
714:               		if (pushAck)
  2D00  AE2966     btss.b 0x0966,#1
  2D02  370018     bra 0x002d34
715:               		{
716:                           pushAck = false;
  2D04  A92966     bclr.b 0x0966,#1
717:               			beep(true);
  2D06  B3C010     mov.b #0x1,0x0000
  2D08  B7E9AC     mov.b 0x0000,0x09ac
  2D0A  021E22     call 0x001e22
718:               			delay_ms(BUZZER_ON_TIME);
  2D0E  200320     mov.w #0x32,0x0000
  2D10  020AEC     call 0x000aec
719:               			beep(false);
  2D14  EF69AC     clr.b 0x09ac
  2D16  021E22     call 0x001e22
720:               
721:               			//GO TO EDIT OR EXIT MODE
722:               			switch (cursorLocation)
723:               			{
  2D1A  BFC98B     mov.b 0x098b,0x0000
  2D1C  EF6001     clr.b 0x0001
  2D1E  B28000     xor.w #0x0,0x0000
  2D20  320005     bra z, 0x002d2c
  2D22  B28010     xor.w #0x1,0x0000
  2D24  320004     bra z, 0x002d2e
  2D26  B28030     xor.w #0x3,0x0000
  2D28  320003     bra z, 0x002d30
  2D2A  370004     bra 0x002d34
724:               				case 0:
725:               					//editIntField(&phaseOffset,0,0x7FFF,displayPowerCtrls);
726:               					break;
  2D2C  370003     bra 0x002d34
727:               				case 1:
728:               					//editIntField(&pulseWidth,0,0x7FFF,displayPowerCtrls);
729:               					break;
  2D2E  370002     bra 0x002d34
730:               				case 2:
731:               					exitMenu = true;
  2D30  A8098A     bset.b 0x098a,#0
732:               					break;
  2D32  370000     bra 0x002d34
733:               			}
734:               		}
735:               		displayPowerCtrls();
  2D34  022BE2     call 0x002be2
736:               		previousPOS = currentPOS;
  2D38  F80986     push.w 0x0986
  2D3A  F90988     pop.w 0x0988
737:               	}
  2D3C  37FF9F     bra 0x002c7c
738:               }
  2D3E  7802CF     mov.w [--0x001e],0x000a
  2D40  060000     return
739:               
740:               void editField(byte * field, byte minimum, byte maximum, funPtr displayFunction)
741:               {
  22D6  781F85     mov.w 0x000a,[0x001e++]
  22D8  F80126     push.w 0x0126
  22DA  F909A0     pop.w 0x09a0
742:               	//PUSH POSCNT CONTEXT
743:               	int16 initialPOSCNT = POSCNT;
744:               	//Load field into POSCNT
745:               	POSCNT = *field;
  22DC  804CD0     mov.w 0x099a,0x0000
  22DE  780200     mov.w 0x0000,0x0008
  22E0  784014     mov.b [0x0008],0x0000
  22E2  EF6001     clr.b 0x0001
  22E4  880930     mov.w 0x0000,0x0126
746:               	
747:               	int16 previousPOS = POSCNT;
748:               	int16 currentPOS = POSCNT;
  22E6  F80126     push.w 0x0126
  22E8  F909A2     pop.w 0x09a2
  22EA  F80126     push.w 0x0126
  22EC  F909A4     pop.w 0x09a4
749:               	
750:               	//While User doesn't push button
751:               	while(!pushAck)
752:               	{
  22EE  AF2966     btsc.b 0x0966,#1
  22F0  37002E     bra 0x00234e
753:               		currentPOS = POSCNT;
  22F2  F80126     push.w 0x0126
  22F4  F909A4     pop.w 0x09a4
754:               		*field = currentPOS;
  22F6  804CD5     mov.w 0x099a,0x000a
  22F8  BFC9A4     mov.b 0x09a4,0x0000
  22FA  984280     mov.b 0x0000,[0x000a+0]
755:               		
756:               		if (*field == minimum-1)
  22FC  804CD0     mov.w 0x099a,0x0000
  22FE  784290     mov.b [0x0000],0x000a
  2300  804CE4     mov.w 0x099c,0x0008
  2302  524061     sub.b 0x0008,#1,0x0000
  2304  E12C00     cp.b 0x000a,0x0000
  2306  3A000A     bra nz, 0x00231c
757:               		{
758:               			currentPOS = maximum;
  2308  BFC99D     mov.b 0x099d,0x0000
  230A  B7E9A4     mov.b 0x0000,0x09a4
  230C  EF69A5     clr.b 0x09a5
759:               			POSCNT = maximum;
  230E  BFC99D     mov.b 0x099d,0x0000
  2310  B7E126     mov.b 0x0000,0x0126
  2312  EF6127     clr.b 0x0127
760:               			*field = currentPOS;
  2314  804CD5     mov.w 0x099a,0x000a
  2316  BFC9A4     mov.b 0x09a4,0x0000
  2318  984280     mov.b 0x0000,[0x000a+0]
761:               		}
762:               		else if (*field > maximum) {
  231A  37000F     bra 0x00233a
  231C  804CD0     mov.w 0x099a,0x0000
  231E  784010     mov.b [0x0000],0x0000
  2320  804CE4     mov.w 0x099c,0x0008
  2322  DE2248     lsr 0x0008,#8,0x0008
  2324  E12400     cp.b 0x0008,0x0000
  2326  310009     bra c, 0x00233a
763:               			currentPOS = minimum;
  2328  BFC99C     mov.b 0x099c,0x0000
  232A  B7E9A4     mov.b 0x0000,0x09a4
  232C  EF69A5     clr.b 0x09a5
764:               			POSCNT = minimum;
  232E  BFC99C     mov.b 0x099c,0x0000
  2330  B7E126     mov.b 0x0000,0x0126
  2332  EF6127     clr.b 0x0127
765:               			*field = currentPOS;
  2334  804CD5     mov.w 0x099a,0x000a
  2336  BFC9A4     mov.b 0x09a4,0x0000
  2338  984280     mov.b 0x0000,[0x000a+0]
766:               		}
767:               		if (previousPOS != currentPOS)
  233A  804D10     mov.w 0x09a2,0x0000
  233C  E309A4     cp.w 0x09a4
  233E  320004     bra z, 0x002348
768:               		{
769:               			(*displayFunction)();
  2340  804CF2     mov.w 0x099e,0x0004
  2342  200003     mov.w #0x0,0x0006
  2344  0202B6     call 0x0002b6
770:               			//displayEditDateAndTime();
771:               		}
772:               		previousPOS = currentPOS;
  2348  F809A4     push.w 0x09a4
  234A  F909A2     pop.w 0x09a2
773:               	}
  234C  37FFD0     bra 0x0022ee
774:                   
775:                   pushAck = false;
  234E  A92966     bclr.b 0x0966,#1
776:               	
777:               	beep(true);
  2350  B3C010     mov.b #0x1,0x0000
  2352  B7E9AC     mov.b 0x0000,0x09ac
  2354  021E22     call 0x001e22
778:               	delay_ms(BUZZER_ON_TIME);
  2358  200320     mov.w #0x32,0x0000
  235A  020AEC     call 0x000aec
779:               	beep(false);
  235E  EF69AC     clr.b 0x09ac
  2360  021E22     call 0x001e22
780:                   
781:               	//POP POSCNT CONTEXT
782:               	POSCNT = initialPOSCNT;
  2364  F809A0     push.w 0x09a0
  2366  F90126     pop.w 0x0126
783:               }
  2368  7802CF     mov.w [--0x001e],0x000a
  236A  060000     return
784:               
785:               void editIntField(int * field, int minimum, int maximum, funPtr displayFunction)
786:               {
  20F2  781F85     mov.w 0x000a,[0x001e++]
  20F4  F80126     push.w 0x0126
  20F6  F9099A     pop.w 0x099a
787:               	//PUSH POSCNT CONTEXT
788:               	int16 initialPOSCNT = POSCNT;
789:               	//Load field into POSCNT
790:               	POSCNT = *field;
  20F8  804C90     mov.w 0x0992,0x0000
  20FA  781F90     mov.w [0x0000],[0x001e++]
  20FC  F90126     pop.w 0x0126
791:               	
792:               	int16 previousPOS = POSCNT;
793:               	int16 currentPOS = POSCNT;
  20FE  F80126     push.w 0x0126
  2100  F9099C     pop.w 0x099c
  2102  F80126     push.w 0x0126
  2104  F9099E     pop.w 0x099e
794:               	
795:               	//While User doesn't push button
796:               	while(!pushAck)
797:               	{
  2106  AF2966     btsc.b 0x0966,#1
  2108  370029     bra 0x00215c
798:               		currentPOS = POSCNT;
  210A  F80126     push.w 0x0126
  210C  F9099E     pop.w 0x099e
799:               		*field = currentPOS;
  210E  804C95     mov.w 0x0992,0x000a
  2110  804CF4     mov.w 0x099e,0x0008
  2112  980284     mov.w 0x0008,[0x000a+0]
800:               		
801:               		if (*field == minimum-1)
  2114  804C90     mov.w 0x0992,0x0000
  2116  780290     mov.w [0x0000],0x000a
  2118  804CA4     mov.w 0x0994,0x0008
  211A  520061     sub.w 0x0008,#1,0x0000
  211C  E12800     cp.w 0x000a,0x0000
  211E  3A0008     bra nz, 0x002130
802:               		{
803:               			currentPOS = maximum;
  2120  F80996     push.w 0x0996
  2122  F9099E     pop.w 0x099e
804:               			POSCNT = maximum;
  2124  F80996     push.w 0x0996
  2126  F90126     pop.w 0x0126
805:               			*field = currentPOS;
  2128  804C95     mov.w 0x0992,0x000a
  212A  804CF4     mov.w 0x099e,0x0008
  212C  980284     mov.w 0x0008,[0x000a+0]
806:               		}
807:               		else if (*field > maximum) {
  212E  37000C     bra 0x002148
  2130  804C90     mov.w 0x0992,0x0000
  2132  780290     mov.w [0x0000],0x000a
  2134  804CB4     mov.w 0x0996,0x0008
  2136  E12005     cp.w 0x0008,0x000a
  2138  3D0007     bra ges, 0x002148
808:               			currentPOS = minimum;
  213A  F80994     push.w 0x0994
  213C  F9099E     pop.w 0x099e
809:               			POSCNT = minimum;
  213E  F80994     push.w 0x0994
  2140  F90126     pop.w 0x0126
810:               			*field = currentPOS;
  2142  804C95     mov.w 0x0992,0x000a
  2144  804CF4     mov.w 0x099e,0x0008
  2146  980284     mov.w 0x0008,[0x000a+0]
811:               		}
812:               		if (previousPOS != currentPOS)
  2148  804CE0     mov.w 0x099c,0x0000
  214A  E3099E     cp.w 0x099e
  214C  320004     bra z, 0x002156
813:               		{
814:               			(*displayFunction)();
  214E  804CC2     mov.w 0x0998,0x0004
  2150  200003     mov.w #0x0,0x0006
  2152  0202B6     call 0x0002b6
815:               		}
816:               		previousPOS = currentPOS;
  2156  F8099E     push.w 0x099e
  2158  F9099C     pop.w 0x099c
817:               	}
  215A  37FFD5     bra 0x002106
818:               	
819:                   pushAck = false;
  215C  A92966     bclr.b 0x0966,#1
820:                   
821:               	beep(true);
  215E  B3C010     mov.b #0x1,0x0000
  2160  B7E9AC     mov.b 0x0000,0x09ac
  2162  021E22     call 0x001e22
822:               	delay_ms(BUZZER_ON_TIME);
  2166  200320     mov.w #0x32,0x0000
  2168  020AEC     call 0x000aec
823:               	beep(false);
  216C  EF69AC     clr.b 0x09ac
  216E  021E22     call 0x001e22
824:               	
825:               	//POP POSCNT CONTEXT
826:               	POSCNT = initialPOSCNT;
  2172  F8099A     push.w 0x099a
  2174  F90126     pop.w 0x0126
827:               }
  2176  7802CF     mov.w [--0x001e],0x000a
  2178  060000     return
828:               
829:               ////////////////////////////////////////////////////////////////
830:               // Fonctions de rafraîchissement du LCD
831:               ////////////////////////////////////////////////////////////////
832:               
833:               void displayEditDateAndTime()
834:               {
  1EA8  781F85     mov.w 0x000a,[0x001e++]
835:               	clearLCDLines();
  1EAA  020B4E     call 0x000b4e
836:               	sprintf(LCD_Line1,"%02u:%02u:%02u TIMESET",CurrentTime.tm_hour,CurrentTime.tm_min,CurrentTime.tm_sec);
  1EAE  208C04     mov.w #0x8c0,0x0008
  1EB0  884BE4     mov.w 0x0008,0x097c
  1EB2  804960     mov.w 0x092c,0x0000
  1EB4  280024     mov.w #0x8002,0x0008
  1EB6  021C80     call 0x001c80
  1EBA  B3C3A0     mov.b #0x3a,0x0000
  1EBC  021C72     call 0x001c72
  1EC0  804950     mov.w 0x092a,0x0000
  1EC2  280024     mov.w #0x8002,0x0008
  1EC4  021C80     call 0x001c80
  1EC8  B3C3A0     mov.b #0x3a,0x0000
  1ECA  021C72     call 0x001c72
  1ECE  804940     mov.w 0x0928,0x0000
  1ED0  280024     mov.w #0x8002,0x0008
  1ED2  021C80     call 0x001c80
  1ED6  2000E1     mov.w #0xe,0x0002
  1ED8  780001     mov.w 0x0002,0x0000
  1EDA  020100     call 0x000100
  1EDE  E80081     inc.w 0x0002,0x0002
  1EE0  781F81     mov.w 0x0002,[0x001e++]
  1EE2  781F80     mov.w 0x0000,[0x001e++]
  1EE4  78004F     mov.w [--0x001e],0x0000
  1EE6  021C72     call 0x001c72
  1EEA  7800CF     mov.w [--0x001e],0x0002
  1EEC  200150     mov.w #0x15,0x0000
  1EEE  E60800     cpsgt.w 0x0002,0x0000
  1EF0  37FFF3     bra 0x001ed8
837:               	sprintf(LCD_Line2,"%02u %02u %02u",CurrentTime.tm_mday,CurrentTime.tm_mon,CurrentTime.tm_year+1900);
  1EF2  2076C4     mov.w #0x76c,0x0008
  1EF4  804993     mov.w 0x0932,0x0006
  1EF6  418284     add.w 0x0006,0x0008,0x000a
  1EF8  208D04     mov.w #0x8d0,0x0008
  1EFA  884BE4     mov.w 0x0008,0x097c
  1EFC  804970     mov.w 0x092e,0x0000
  1EFE  280024     mov.w #0x8002,0x0008
  1F00  021C80     call 0x001c80
  1F04  B3C200     mov.b #0x20,0x0000
  1F06  021C72     call 0x001c72
  1F0A  804980     mov.w 0x0930,0x0000
  1F0C  280024     mov.w #0x8002,0x0008
  1F0E  021C80     call 0x001c80
  1F12  B3C200     mov.b #0x20,0x0000
  1F14  021C72     call 0x001c72
  1F18  780005     mov.w 0x000a,0x0000
  1F1A  280024     mov.w #0x8002,0x0008
  1F1C  021C80     call 0x001c80
838:               	LCD_Line2[15] = 0x9D;	//Return sign
  1F20  B3C9D0     mov.b #0x9d,0x0000
  1F22  B7E8DF     mov.b 0x0000,0x08df
839:               	//addSelector();
840:               	refreshLCD();
  1F24  021D90     call 0x001d90
841:               }
  1F28  7802CF     mov.w [--0x001e],0x000a
  1F2A  060000     return
842:               
843:               void displayEditAlarmOptions()
844:               {
845:               	clearLCDLines();
  1DC4  020B4E     call 0x000b4e
846:               	sprintf(LCD_Line1,"%02u:%02u",CurrentTime.tm_hour,CurrentTime.tm_min);
  1DC8  208C04     mov.w #0x8c0,0x0008
  1DCA  884BE4     mov.w 0x0008,0x097c
  1DCC  804960     mov.w 0x092c,0x0000
  1DCE  280024     mov.w #0x8002,0x0008
  1DD0  021C80     call 0x001c80
  1DD4  B3C3A0     mov.b #0x3a,0x0000
  1DD6  021C72     call 0x001c72
  1DDA  804950     mov.w 0x092a,0x0000
  1DDC  280024     mov.w #0x8002,0x0008
  1DDE  021C80     call 0x001c80
847:               	sprintf(LCD_Line2,"%02u:%02u  ACTLMVBP",AlarmTime.tm_hour,AlarmTime.tm_min);
  1DE2  208D04     mov.w #0x8d0,0x0008
  1DE4  884BE4     mov.w 0x0008,0x097c
  1DE6  8049F0     mov.w 0x093e,0x0000
  1DE8  280024     mov.w #0x8002,0x0008
  1DEA  021C80     call 0x001c80
  1DEE  B3C3A0     mov.b #0x3a,0x0000
  1DF0  021C72     call 0x001c72
  1DF4  8049E0     mov.w 0x093c,0x0000
  1DF6  280024     mov.w #0x8002,0x0008
  1DF8  021C80     call 0x001c80
  1DFC  200091     mov.w #0x9,0x0002
  1DFE  780001     mov.w 0x0002,0x0000
  1E00  020124     call 0x000124
  1E04  E80081     inc.w 0x0002,0x0002
  1E06  781F81     mov.w 0x0002,[0x001e++]
  1E08  781F80     mov.w 0x0000,[0x001e++]
  1E0A  78004F     mov.w [--0x001e],0x0000
  1E0C  021C72     call 0x001c72
  1E10  7800CF     mov.w [--0x001e],0x0002
  1E12  200120     mov.w #0x12,0x0000
  1E14  E60800     cpsgt.w 0x0002,0x0000
  1E16  37FFF3     bra 0x001dfe
848:               	LCD_Line2[15] = 0x9D;	//Return sign
  1E18  B3C9D0     mov.b #0x9d,0x0000
  1E1A  B7E8DF     mov.b 0x0000,0x08df
849:               	//addSelector();
850:               	refreshLCD();
  1E1C  021D90     call 0x001d90
851:               }
  1E20  060000     return
852:               
853:               void displayEditAlarmTime()
854:               {
855:               	clearLCDLines();
  1E2A  020B4E     call 0x000b4e
856:               	sprintf(LCD_Line1,"ALARME    ");
  1E2E  208C04     mov.w #0x8c0,0x0008
  1E30  884BE4     mov.w 0x0008,0x097c
  1E32  200001     mov.w #0x0,0x0002
  1E34  780001     mov.w 0x0002,0x0000
  1E36  020144     call 0x000144
  1E3A  E80081     inc.w 0x0002,0x0002
  1E3C  781F81     mov.w 0x0002,[0x001e++]
  1E3E  781F80     mov.w 0x0000,[0x001e++]
  1E40  78004F     mov.w [--0x001e],0x0000
  1E42  021C72     call 0x001c72
  1E46  7800CF     mov.w [--0x001e],0x0002
  1E48  200090     mov.w #0x9,0x0000
  1E4A  E60800     cpsgt.w 0x0002,0x0000
  1E4C  37FFF3     bra 0x001e34
857:               	sprintf(LCD_Line2,"%02u:%02u      J S",AlarmTime.tm_hour,AlarmTime.tm_min);
  1E4E  208D04     mov.w #0x8d0,0x0008
  1E50  884BE4     mov.w 0x0008,0x097c
  1E52  8049F0     mov.w 0x093e,0x0000
  1E54  280024     mov.w #0x8002,0x0008
  1E56  021C80     call 0x001c80
  1E5A  B3C3A0     mov.b #0x3a,0x0000
  1E5C  021C72     call 0x001c72
  1E60  8049E0     mov.w 0x093c,0x0000
  1E62  280024     mov.w #0x8002,0x0008
  1E64  021C80     call 0x001c80
  1E68  200091     mov.w #0x9,0x0002
  1E6A  780001     mov.w 0x0002,0x0000
  1E6C  02015C     call 0x00015c
  1E70  E80081     inc.w 0x0002,0x0002
  1E72  781F81     mov.w 0x0002,[0x001e++]
  1E74  781F80     mov.w 0x0000,[0x001e++]
  1E76  78004F     mov.w [--0x001e],0x0000
  1E78  021C72     call 0x001c72
  1E7C  7800CF     mov.w [--0x001e],0x0002
  1E7E  200110     mov.w #0x11,0x0000
  1E80  E60800     cpsgt.w 0x0002,0x0000
  1E82  37FFF3     bra 0x001e6a
858:               	LCD_Line2[15] = 0x9D;	//Return sign
  1E84  B3C9D0     mov.b #0x9d,0x0000
  1E86  B7E8DF     mov.b 0x0000,0x08df
859:               	
860:               	if (ALARM_ENABLED)
  1E88  AEA885     btss.b 0x0885,#5
  1E8A  370005     bra 0x001e96
861:               	{
862:               		LCD_Line1[8] = 'O';
  1E8C  B3C4F0     mov.b #0x4f,0x0000
  1E8E  B7E8C8     mov.b 0x0000,0x08c8
863:               		LCD_Line1[9] = 'N';
  1E90  B3C4E0     mov.b #0x4e,0x0000
  1E92  B7E8C9     mov.b 0x0000,0x08c9
864:               	}
865:               	else
  1E94  370006     bra 0x001ea2
866:               	{
867:               		LCD_Line1[7] = 'O';
  1E96  B3C4F0     mov.b #0x4f,0x0000
  1E98  B7E8C7     mov.b 0x0000,0x08c7
868:               		LCD_Line1[8] = 'F';
  1E9A  B3C460     mov.b #0x46,0x0000
  1E9C  B7E8C8     mov.b 0x0000,0x08c8
869:               		LCD_Line1[9] = 'F';
  1E9E  B3C460     mov.b #0x46,0x0000
  1EA0  B7E8C9     mov.b 0x0000,0x08c9
870:               	}
871:               	
872:               	//addSelector();
873:               	refreshLCD();	
  1EA2  021D90     call 0x001d90
874:               }
  1EA6  060000     return
875:               
876:               void displayCarillon()
877:               {
878:               	clearLCDLines();
  25A4  020B4E     call 0x000b4e
879:               	sprintf(LCD_Line1,"CARILLON");
  25A8  208C04     mov.w #0x8c0,0x0008
  25AA  884BE4     mov.w 0x0008,0x097c
  25AC  200001     mov.w #0x0,0x0002
  25AE  780001     mov.w 0x0002,0x0000
  25B0  02017C     call 0x00017c
  25B4  E80081     inc.w 0x0002,0x0002
  25B6  781F81     mov.w 0x0002,[0x001e++]
  25B8  781F80     mov.w 0x0000,[0x001e++]
  25BA  78004F     mov.w [--0x001e],0x0000
  25BC  021C72     call 0x001c72
  25C0  7800CF     mov.w [--0x001e],0x0002
  25C2  200070     mov.w #0x7,0x0000
  25C4  E60800     cpsgt.w 0x0002,0x0000
  25C6  37FFF3     bra 0x0025ae
880:               	if (carillon)
  25C8  AE4885     btss.b 0x0885,#2
  25CA  37000C     bra 0x0025e4
881:               	{
882:               		sprintf(LCD_Line2," ON");
  25CC  208D04     mov.w #0x8d0,0x0008
  25CE  884BE4     mov.w 0x0008,0x097c
  25D0  B3C200     mov.b #0x20,0x0000
  25D2  021C72     call 0x001c72
  25D6  B3C4F0     mov.b #0x4f,0x0000
  25D8  021C72     call 0x001c72
  25DC  B3C4E0     mov.b #0x4e,0x0000
  25DE  021C72     call 0x001c72
883:               	}
884:               	else {
  25E2  37000B     bra 0x0025fa
885:               		sprintf(LCD_Line2,"OFF");
  25E4  208D04     mov.w #0x8d0,0x0008
  25E6  884BE4     mov.w 0x0008,0x097c
  25E8  B3C4F0     mov.b #0x4f,0x0000
  25EA  021C72     call 0x001c72
  25EE  B3C460     mov.b #0x46,0x0000
  25F0  021C72     call 0x001c72
  25F4  B3C460     mov.b #0x46,0x0000
  25F6  021C72     call 0x001c72
886:               	}
887:               
888:               	LCD_Line2[15] = 0x9D;	//Return sign
  25FA  B3C9D0     mov.b #0x9d,0x0000
  25FC  B7E8DF     mov.b 0x0000,0x08df
889:               	//addSelector();
890:               	refreshLCD();
  25FE  021D90     call 0x001d90
891:               }
  2602  060000     return
892:               
893:               void displayLoadLighting()
894:               {
895:               	clearLCDLines();
  1F84  020B4E     call 0x000b4e
896:               	sprintf(LCD_Line1,"LUM    MAX %03u",maxLoadLighting);
  1F88  208C04     mov.w #0x8c0,0x0008
  1F8A  884BE4     mov.w 0x0008,0x097c
  1F8C  200001     mov.w #0x0,0x0002
  1F8E  780001     mov.w 0x0002,0x0000
  1F90  020192     call 0x000192
  1F94  E80081     inc.w 0x0002,0x0002
  1F96  781F81     mov.w 0x0002,[0x001e++]
  1F98  781F80     mov.w 0x0000,[0x001e++]
  1F9A  78004F     mov.w [--0x001e],0x0000
  1F9C  021C72     call 0x001c72
  1FA0  7800CF     mov.w [--0x001e],0x0002
  1FA2  2000A0     mov.w #0xa,0x0000
  1FA4  E60800     cpsgt.w 0x0002,0x0000
  1FA6  37FFF3     bra 0x001f8e
  1FA8  BFC8BF     mov.b 0x08bf,0x0000
  1FAA  FB0000     se 0x0000,0x0000
  1FAC  280034     mov.w #0x8003,0x0008
  1FAE  021C80     call 0x001c80
897:               	sprintf(LCD_Line2,"    DELAIS  %02u",delayLoadLighting);
  1FB2  208D04     mov.w #0x8d0,0x0008
  1FB4  884BE4     mov.w 0x0008,0x097c
  1FB6  200001     mov.w #0x0,0x0002
  1FB8  780001     mov.w 0x0002,0x0000
  1FBA  0201AE     call 0x0001ae
  1FBE  E80081     inc.w 0x0002,0x0002
  1FC0  781F81     mov.w 0x0002,[0x001e++]
  1FC2  781F80     mov.w 0x0000,[0x001e++]
  1FC4  78004F     mov.w [--0x001e],0x0000
  1FC6  021C72     call 0x001c72
  1FCA  7800CF     mov.w [--0x001e],0x0002
  1FCC  2000B0     mov.w #0xb,0x0000
  1FCE  E60800     cpsgt.w 0x0002,0x0000
  1FD0  37FFF3     bra 0x001fb8
  1FD2  BFC8E0     mov.b 0x08e0,0x0000
  1FD4  FB0000     se 0x0000,0x0000
  1FD6  280024     mov.w #0x8002,0x0008
  1FD8  021C80     call 0x001c80
898:               	LCD_Line2[15] = 0x9D;	//Return sign
  1FDC  B3C9D0     mov.b #0x9d,0x0000
  1FDE  B7E8DF     mov.b 0x0000,0x08df
899:               	//addSelector();
900:               	refreshLCD();
  1FE0  021D90     call 0x001d90
901:               }
  1FE4  060000     return
902:               
903:               void displayAlarmDays()
904:               {
  217A  781F85     mov.w 0x000a,[0x001e++]
905:               	//ALARM_DAYS
906:               	clearLCDLines();
  217C  020B4E     call 0x000b4e
907:               	sprintf(LCD_Line1,"JOURS  DLMMJVS");
  2180  208C04     mov.w #0x8c0,0x0008
  2182  884BE4     mov.w 0x0008,0x097c
  2184  200001     mov.w #0x0,0x0002
  2186  780001     mov.w 0x0002,0x0000
  2188  0201CC     call 0x0001cc
  218C  E80081     inc.w 0x0002,0x0002
  218E  781F81     mov.w 0x0002,[0x001e++]
  2190  781F80     mov.w 0x0000,[0x001e++]
  2192  78004F     mov.w [--0x001e],0x0000
  2194  021C72     call 0x001c72
  2198  7800CF     mov.w [--0x001e],0x0002
  219A  2000D0     mov.w #0xd,0x0000
  219C  E60800     cpsgt.w 0x0002,0x0000
  219E  37FFF3     bra 0x002186
908:               	int i;
909:               	for (i = 0 ; i < 7 ; i++)
  21A0  EF2996     clr.w 0x0996
  21A2  804CB4     mov.w 0x0996,0x0008
  21A4  E12067     cp.w 0x0008,#7
  21A6  3D0016     bra ges, 0x0021d4
910:               	{
911:               		if (ALARM_DAYS[i])
  21A8  209204     mov.w #0x920,0x0008
  21AA  804CB3     mov.w 0x0996,0x0006
  21AC  418004     add.w 0x0006,0x0008,0x0000
  21AE  E00410     cp0.b [0x0000]
  21B0  320008     bra z, 0x0021c2
912:               		{
913:               			LCD_Line2[i+7] = 0x96;
  21B2  804CB4     mov.w 0x0996,0x0008
  21B4  420267     add.w 0x0008,#7,0x0008
  21B6  780284     mov.w 0x0008,0x000a
  21B8  208D04     mov.w #0x8d0,0x0008
  21BA  428284     add.w 0x000a,0x0008,0x000a
  21BC  B3C960     mov.b #0x96,0x0000
  21BE  784A80     mov.b 0x0000,[0x000a]
914:               		}
915:               		else
  21C0  370007     bra 0x0021d0
916:               		{
917:               			LCD_Line2[i+7] = ' ';
  21C2  804CB4     mov.w 0x0996,0x0008
  21C4  420267     add.w 0x0008,#7,0x0008
  21C6  780284     mov.w 0x0008,0x000a
  21C8  208D04     mov.w #0x8d0,0x0008
  21CA  428284     add.w 0x000a,0x0008,0x000a
  21CC  B3C200     mov.b #0x20,0x0000
  21CE  784A80     mov.b 0x0000,[0x000a]
918:               		}
919:               	}
  21D0  EC2996     inc.w 0x0996
  21D2  37FFE7     bra 0x0021a2
920:               	LCD_Line2[15] = 0x9D;	//Return sign
  21D4  B3C9D0     mov.b #0x9d,0x0000
  21D6  B7E8DF     mov.b 0x0000,0x08df
921:               	//addSelector();
922:               	refreshLCD();
  21D8  021D90     call 0x001d90
923:               }
  21DC  7802CF     mov.w [--0x001e],0x000a
  21DE  060000     return
924:               
925:               void displaySnooze()
926:               {
927:               	clearLCDLines();
  1F2C  020B4E     call 0x000b4e
928:               	sprintf(LCD_Line1,"SNOOZE");
  1F30  208C04     mov.w #0x8c0,0x0008
  1F32  884BE4     mov.w 0x0008,0x097c
  1F34  200001     mov.w #0x0,0x0002
  1F36  780001     mov.w 0x0002,0x0000
  1F38  0201E8     call 0x0001e8
  1F3C  E80081     inc.w 0x0002,0x0002
  1F3E  781F81     mov.w 0x0002,[0x001e++]
  1F40  781F80     mov.w 0x0000,[0x001e++]
  1F42  78004F     mov.w [--0x001e],0x0000
  1F44  021C72     call 0x001c72
  1F48  7800CF     mov.w [--0x001e],0x0002
  1F4A  200050     mov.w #0x5,0x0000
  1F4C  E60800     cpsgt.w 0x0002,0x0000
  1F4E  37FFF3     bra 0x001f36
929:               	sprintf(LCD_Line2,"%02u min",AlarmSnoozeTime);
  1F50  208D04     mov.w #0x8d0,0x0008
  1F52  884BE4     mov.w 0x0008,0x097c
  1F54  BFC8E1     mov.b 0x08e1,0x0000
  1F56  EF6001     clr.b 0x0001
  1F58  280024     mov.w #0x8002,0x0008
  1F5A  021C80     call 0x001c80
  1F5E  200041     mov.w #0x4,0x0002
  1F60  780001     mov.w 0x0002,0x0000
  1F62  0201FC     call 0x0001fc
  1F66  E80081     inc.w 0x0002,0x0002
  1F68  781F81     mov.w 0x0002,[0x001e++]
  1F6A  781F80     mov.w 0x0000,[0x001e++]
  1F6C  78004F     mov.w [--0x001e],0x0000
  1F6E  021C72     call 0x001c72
  1F72  7800CF     mov.w [--0x001e],0x0002
  1F74  200070     mov.w #0x7,0x0000
  1F76  E60800     cpsgt.w 0x0002,0x0000
  1F78  37FFF3     bra 0x001f60
930:               	LCD_Line2[15] = 0x9D;	//Return sign
  1F7A  B3C9D0     mov.b #0x9d,0x0000
  1F7C  B7E8DF     mov.b 0x0000,0x08df
931:               	//addSelector();
932:               	refreshLCD();	
  1F7E  021D90     call 0x001d90
933:               }
  1F82  060000     return
934:               
935:               void displayRGBLight()
936:               {
937:               	clearLCDLines();
  1FE6  020B4E     call 0x000b4e
938:               	sprintf(LCD_Line1,"MOOD     H %03u", hsvColor.hue);
  1FEA  208C04     mov.w #0x8c0,0x0008
  1FEC  884BE4     mov.w 0x0008,0x097c
  1FEE  200001     mov.w #0x0,0x0002
  1FF0  780001     mov.w 0x0002,0x0000
  1FF2  020212     call 0x000212
  1FF6  E80081     inc.w 0x0002,0x0002
  1FF8  781F81     mov.w 0x0002,[0x001e++]
  1FFA  781F80     mov.w 0x0000,[0x001e++]
  1FFC  78004F     mov.w [--0x001e],0x0000
  1FFE  021C72     call 0x001c72
  2002  7800CF     mov.w [--0x001e],0x0002
  2004  2000A0     mov.w #0xa,0x0000
  2006  E60800     cpsgt.w 0x0002,0x0000
  2008  37FFF3     bra 0x001ff0
  200A  8045C0     mov.w 0x08b8,0x0000
  200C  280034     mov.w #0x8003,0x0008
  200E  021C80     call 0x001c80
939:               	sprintf(LCD_Line2,"   S %03u V %03u",hsvColor.saturation,hsvColor.value);
  2012  208D04     mov.w #0x8d0,0x0008
  2014  884BE4     mov.w 0x0008,0x097c
  2016  200001     mov.w #0x0,0x0002
  2018  780001     mov.w 0x0002,0x0000
  201A  02022E     call 0x00022e
  201E  E80081     inc.w 0x0002,0x0002
  2020  781F81     mov.w 0x0002,[0x001e++]
  2022  781F80     mov.w 0x0000,[0x001e++]
  2024  78004F     mov.w [--0x001e],0x0000
  2026  021C72     call 0x001c72
  202A  7800CF     mov.w [--0x001e],0x0002
  202C  200040     mov.w #0x4,0x0000
  202E  E60800     cpsgt.w 0x0002,0x0000
  2030  37FFF3     bra 0x002018
  2032  BFC8BA     mov.b 0x08ba,0x0000
  2034  EF6001     clr.b 0x0001
  2036  280034     mov.w #0x8003,0x0008
  2038  021C80     call 0x001c80
  203C  B3C200     mov.b #0x20,0x0000
  203E  021C72     call 0x001c72
  2042  B3C560     mov.b #0x56,0x0000
  2044  021C72     call 0x001c72
  2048  B3C200     mov.b #0x20,0x0000
  204A  021C72     call 0x001c72
  204E  BFC8BB     mov.b 0x08bb,0x0000
  2050  EF6001     clr.b 0x0001
  2052  280034     mov.w #0x8003,0x0008
  2054  021C80     call 0x001c80
940:               	if (moodEnable)
  2058  AE2885     btss.b 0x0885,#1
  205A  370005     bra 0x002066
941:               	{
942:               		LCD_Line1[6] = 'O';
  205C  B3C4F0     mov.b #0x4f,0x0000
  205E  B7E8C6     mov.b 0x0000,0x08c6
943:               		LCD_Line1[7] = 'N';
  2060  B3C4E0     mov.b #0x4e,0x0000
  2062  B7E8C7     mov.b 0x0000,0x08c7
944:               	}
945:               	else {
  2064  370006     bra 0x002072
946:               		LCD_Line1[5] = 'O';
  2066  B3C4F0     mov.b #0x4f,0x0000
  2068  B7E8C5     mov.b 0x0000,0x08c5
947:               		LCD_Line1[6] = 'F';
  206A  B3C460     mov.b #0x46,0x0000
  206C  B7E8C6     mov.b 0x0000,0x08c6
948:               		LCD_Line1[7] = 'F';
  206E  B3C460     mov.b #0x46,0x0000
  2070  B7E8C7     mov.b 0x0000,0x08c7
949:               	}
950:               	LCD_Line2[15] = 0x9D;	//Return sign
  2072  B3C9D0     mov.b #0x9d,0x0000
  2074  B7E8DF     mov.b 0x0000,0x08df
951:               	//addSelector();
952:               	refreshLCD();
  2076  021D90     call 0x001d90
953:               	HSVtoRGB(&hsvColor,&rgbColor);
  207A  208B84     mov.w #0x8b8,0x0008
  207C  884D64     mov.w 0x0008,0x09ac
  207E  208B44     mov.w #0x8b4,0x0008
  2080  884D74     mov.w 0x0008,0x09ae
  2082  021288     call 0x001288
954:                   UpdateRGB_Out(&rgbColor);
  2086  208B44     mov.w #0x8b4,0x0008
  2088  884D64     mov.w 0x0008,0x09ac
  208A  021492     call 0x001492
955:               	//refreshRGB();
956:               }
  208E  060000     return
957:               
958:               void displayVolume()
959:               {
960:               	clearLCDLines();
  2090  020B4E     call 0x000b4e
961:               	sprintf(LCD_Line1,"VOLUME  %03u",chimeVolume);
  2094  208C04     mov.w #0x8c0,0x0008
  2096  884BE4     mov.w 0x0008,0x097c
  2098  200001     mov.w #0x0,0x0002
  209A  780001     mov.w 0x0002,0x0000
  209C  02024C     call 0x00024c
  20A0  E80081     inc.w 0x0002,0x0002
  20A2  781F81     mov.w 0x0002,[0x001e++]
  20A4  781F80     mov.w 0x0000,[0x001e++]
  20A6  78004F     mov.w [--0x001e],0x0000
  20A8  021C72     call 0x001c72
  20AC  7800CF     mov.w [--0x001e],0x0002
  20AE  200070     mov.w #0x7,0x0000
  20B0  E60800     cpsgt.w 0x0002,0x0000
  20B2  37FFF3     bra 0x00209a
  20B4  BFC8B3     mov.b 0x08b3,0x0000
  20B6  FB0000     se 0x0000,0x0000
  20B8  280034     mov.w #0x8003,0x0008
  20BA  021C80     call 0x001c80
962:               	sprintf(LCD_Line2,"TONE      %u",toneSelect);
  20BE  208D04     mov.w #0x8d0,0x0008
  20C0  884BE4     mov.w 0x0008,0x097c
  20C2  200001     mov.w #0x0,0x0002
  20C4  780001     mov.w 0x0002,0x0000
  20C6  020266     call 0x000266
  20CA  E80081     inc.w 0x0002,0x0002
  20CC  781F81     mov.w 0x0002,[0x001e++]
  20CE  781F80     mov.w 0x0000,[0x001e++]
  20D0  78004F     mov.w [--0x001e],0x0000
  20D2  021C72     call 0x001c72
  20D6  7800CF     mov.w [--0x001e],0x0002
  20D8  200090     mov.w #0x9,0x0000
  20DA  E60800     cpsgt.w 0x0002,0x0000
  20DC  37FFF3     bra 0x0020c4
  20DE  BFC8BE     mov.b 0x08be,0x0000
  20E0  FB0000     se 0x0000,0x0000
  20E2  200004     mov.w #0x0,0x0008
  20E4  021C80     call 0x001c80
963:               	LCD_Line2[15] = 0x9D;	//Return sign
  20E8  B3C9D0     mov.b #0x9d,0x0000
  20EA  B7E8DF     mov.b 0x0000,0x08df
964:               	//addSelector();
965:               	refreshLCD();	
  20EC  021D90     call 0x001d90
966:               }
  20F0  060000     return
967:               
968:               void displayPowerCtrls()
969:               {
970:               	clearLCDLines();
  2BE2  020B4E     call 0x000b4e
971:               	sprintf(LCD_Line1,"PHS %04u %05u",LoadStruct.PhaseOffset, TMR4IntrCnt1);
  2BE6  208C04     mov.w #0x8c0,0x0008
  2BE8  884BE4     mov.w 0x0008,0x097c
  2BEA  200001     mov.w #0x0,0x0002
  2BEC  780001     mov.w 0x0002,0x0000
  2BEE  020280     call 0x000280
  2BF2  E80081     inc.w 0x0002,0x0002
  2BF4  781F81     mov.w 0x0002,[0x001e++]
  2BF6  781F80     mov.w 0x0000,[0x001e++]
  2BF8  78004F     mov.w [--0x001e],0x0000
  2BFA  021C72     call 0x001c72
  2BFE  7800CF     mov.w [--0x001e],0x0002
  2C00  200030     mov.w #0x3,0x0000
  2C02  E60800     cpsgt.w 0x0002,0x0000
  2C04  37FFF3     bra 0x002bec
  2C06  804710     mov.w 0x08e2,0x0000
  2C08  280044     mov.w #0x8004,0x0008
  2C0A  021C80     call 0x001c80
  2C0E  B3C200     mov.b #0x20,0x0000
  2C10  021C72     call 0x001c72
  2C14  804740     mov.w 0x08e8,0x0000
  2C16  280054     mov.w #0x8005,0x0008
  2C18  021C80     call 0x001c80
972:               	sprintf(LCD_Line2,"DLY %04u  %05u",LoadStruct.PulseWidth , TMR4IntrCnt2);
  2C1C  208D04     mov.w #0x8d0,0x0008
  2C1E  884BE4     mov.w 0x0008,0x097c
  2C20  200001     mov.w #0x0,0x0002
  2C22  780001     mov.w 0x0002,0x0000
  2C24  02029A     call 0x00029a
  2C28  E80081     inc.w 0x0002,0x0002
  2C2A  781F81     mov.w 0x0002,[0x001e++]
  2C2C  781F80     mov.w 0x0000,[0x001e++]
  2C2E  78004F     mov.w [--0x001e],0x0000
  2C30  021C72     call 0x001c72
  2C34  7800CF     mov.w [--0x001e],0x0002
  2C36  200030     mov.w #0x3,0x0000
  2C38  E60800     cpsgt.w 0x0002,0x0000
  2C3A  37FFF3     bra 0x002c22
  2C3C  804720     mov.w 0x08e4,0x0000
  2C3E  280044     mov.w #0x8004,0x0008
  2C40  021C80     call 0x001c80
  2C44  B3C200     mov.b #0x20,0x0000
  2C46  021C72     call 0x001c72
  2C4A  B3C200     mov.b #0x20,0x0000
  2C4C  021C72     call 0x001c72
  2C50  804750     mov.w 0x08ea,0x0000
  2C52  280054     mov.w #0x8005,0x0008
  2C54  021C80     call 0x001c80
973:               	LCD_Line2[15] = 0x9D;	//Return sign
  2C58  B3C9D0     mov.b #0x9d,0x0000
  2C5A  B7E8DF     mov.b 0x0000,0x08df
974:               	refreshLCD();
  2C5C  021D90     call 0x001d90
975:               }
  2C60  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\Menu.h  --------------------------
1:                 #ifndef __MENU__
2:                 #define __MENU__
3:                 
4:                 typedef void (*funPtr)(void); 
5:                 
6:                 #include <stdlib.h>
7:                 
8:                 
9:                 #define UP 1
10:                #define DOWN 0
11:                
12:                //#word QEICON = 0x0122
13:                //#bit  UPDN   = QEICON.11
14:                
15:                #define EDIT_DATE_TIME_PH_COUNT 7
16:                #define EDIT_ALARM_OPTIONS_PH_LOCATION 9
17:                #define EDIT_CARILLON_PH_LOCATION 2
18:                #define EDIT_ALARM_TIME_PH_LOCATION 6
19:                #define EDIT_ALARM_DAYS_PH_LOCATION 8
20:                #define EDIT_ALARM_SNOOZE_PH_LOCATION 2
21:                #define EDIT_LOAD_LIGHT_PH_LOCATION 3
22:                #define EDIT_RGB_LIGHT_PH_LOCATION 5
23:                #define EDIT_VOLUME_PH_LOCATION 3
24:                #define EDIT_LOAD_DISPLAY_PH_LOCATION 3
25:                
26:                
27:                int8 EDIT_DATE_TIME_PH_LOCATION[]  = {0x01, 0x04, 0x07, 0x29, 0x2C, 0x31, 0x37};
  2F18  204014     mov.w #0x401,0x0008
  2F1A  8843F4     mov.w 0x0008,0x087e
  2F1C  229074     mov.w #0x2907,0x0008
  2F1E  884404     mov.w 0x0008,0x0880
  2F20  2312C4     mov.w #0x312c,0x0008
  2F22  884414     mov.w 0x0008,0x0882
  2F24  B3C370     mov.b #0x37,0x0000
  2F26  B7E884     mov.b 0x0000,0x0884
28:                int8 EDIT_ALARM_OPTIONS_LOCATION[] = {0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37};
  2F28  2302F4     mov.w #0x302f,0x0008
  2F2A  884434     mov.w 0x0008,0x0886
  2F2C  232314     mov.w #0x3231,0x0008
  2F2E  884444     mov.w 0x0008,0x0888
  2F30  234334     mov.w #0x3433,0x0008
  2F32  884454     mov.w 0x0008,0x088a
  2F34  236354     mov.w #0x3635,0x0008
  2F36  884464     mov.w 0x0008,0x088c
  2F38  B3C370     mov.b #0x37,0x0000
  2F3A  B7E88E     mov.b 0x0000,0x088e
29:                int8 EDIT_CARILLON_LOCATION[] = {0x2A, 0x37};
  2F3C  2372A4     mov.w #0x372a,0x0008
  2F3E  884484     mov.w 0x0008,0x0890
30:                int8 EDIT_ALARM_TIME_LOCATION[] = {0x09, 0x29, 0x2C, 0x33, 0x35, 0x37};
  2F40  229094     mov.w #0x2909,0x0008
  2F42  884494     mov.w 0x0008,0x0892
  2F44  2332C4     mov.w #0x332c,0x0008
  2F46  8844A4     mov.w 0x0008,0x0894
  2F48  237354     mov.w #0x3735,0x0008
  2F4A  8844B4     mov.w 0x0008,0x0896
31:                int8 EDIT_ALARM_DAYS_LOCATION[] = {0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x37};
  2F4C  2302F4     mov.w #0x302f,0x0008
  2F4E  8844C4     mov.w 0x0008,0x0898
  2F50  232314     mov.w #0x3231,0x0008
  2F52  8844D4     mov.w 0x0008,0x089a
  2F54  234334     mov.w #0x3433,0x0008
  2F56  8844E4     mov.w 0x0008,0x089c
  2F58  237354     mov.w #0x3735,0x0008
  2F5A  8844F4     mov.w 0x0008,0x089e
32:                int8 EDIT_ALARM_SNOOZE_LOCATION[] = {0x29, 0x37};
  2F5C  237294     mov.w #0x3729,0x0008
  2F5E  884504     mov.w 0x0008,0x08a0
33:                int8 EDIT_LOAD_LIGHT_LOCATION[] = {0x0D, 0x35, 0x37};
  2F60  2350D4     mov.w #0x350d,0x0008
  2F62  884514     mov.w 0x0008,0x08a2
  2F64  B3C370     mov.b #0x37,0x0000
  2F66  B7E8A4     mov.b 0x0000,0x08a4
34:                int8 EDIT_RGB_LIGHT_LOCATION[] = {0x07, 0x0D, 0x2F, 0x35, 0x37};
  2F68  20D074     mov.w #0xd07,0x0008
  2F6A  884534     mov.w 0x0008,0x08a6
  2F6C  2352F4     mov.w #0x352f,0x0008
  2F6E  884544     mov.w 0x0008,0x08a8
  2F70  B3C370     mov.b #0x37,0x0000
  2F72  B7E8AA     mov.b 0x0000,0x08aa
35:                int8 EDIT_VOLUME_LOCATION[] = {0x0A, 0x32, 0x37};
  2F74  2320A4     mov.w #0x320a,0x0008
  2F76  884564     mov.w 0x0008,0x08ac
  2F78  B3C370     mov.b #0x37,0x0000
  2F7A  B7E8AE     mov.b 0x0000,0x08ae
36:                int8 EDIT_LOAD_DISPLAY_LOCATION[] = {0x09, 0x31, 0x37};
  2F7C  231094     mov.w #0x3109,0x0008
  2F7E  884584     mov.w 0x0008,0x08b0
  2F80  B3C370     mov.b #0x37,0x0000
  2F82  B7E8B2     mov.b 0x0000,0x08b2
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\RBGLighting.c  -------------------
1:                 /*
2:                  *  RBGLighting.c
3:                  *  DawnStar
4:                  *
5:                  *  Created by Alexis Ouellet-Patenaude on 10-12-09.
6:                  *  Copyright 2010 EmbVue Inc. All rights reserved.
7:                  *
8:                  */
9:                 
10:                #include "includes.h"
11:                
12:                #int_TIMER5
13:                void TIMER5_isr(void)
14:                {
  02B8  F80042     push.w 0x0042
  02BA  F80036     push.w 0x0036
  02BC  781F80     mov.w 0x0000,[0x001e++]
  02BE  200020     mov.w #0x2,0x0000
  02C0  09000C     repeat #12
  02C2  781FB0     mov.w [0x0000++],[0x001e++]
15:                    rgbColor.cntr++;
  02C4  EC68B7     inc.b 0x08b7
16:                    
17:                    if ((rgbColor.red == 0)             ||
18:                        (rgbColor.red  < rgbColor.cntr)) {
  02C6  E248B4     cp0.b 0x08b4
  02C8  320005     bra z, 0x0002d4
  02CA  BFC8B4     mov.b 0x08b4,0x0000
  02CC  8045B4     mov.w 0x08b6,0x0008
  02CE  DE2248     lsr 0x0008,#8,0x0008
  02D0  E12400     cp.b 0x0008,0x0000
  02D2  360003     bra leu, 0x0002da
19:                        output_low(LED_R);
  02D4  A9E2C6     bclr.b 0x02c6,#7
  02D6  A9E2CA     bclr.b 0x02ca,#7
20:                    } else {
  02D8  370002     bra 0x0002de
21:                        output_high(LED_R);
  02DA  A9E2C6     bclr.b 0x02c6,#7
  02DC  A8E2CA     bset.b 0x02ca,#7
22:                    }
23:                    
24:                    if ((rgbColor.green == 0)             ||
25:                        (rgbColor.green  < rgbColor.cntr)) {
  02DE  E248B5     cp0.b 0x08b5
  02E0  320005     bra z, 0x0002ec
  02E2  BFC8B5     mov.b 0x08b5,0x0000
  02E4  8045B4     mov.w 0x08b6,0x0008
  02E6  DE2248     lsr 0x0008,#8,0x0008
  02E8  E12400     cp.b 0x0008,0x0000
  02EA  360003     bra leu, 0x0002f2
26:                        output_low(LED_G);
  02EC  A922C6     bclr.b 0x02c6,#1
  02EE  A922CA     bclr.b 0x02ca,#1
27:                    } else {
  02F0  370002     bra 0x0002f6
28:                        output_high(LED_G);
  02F2  A922C6     bclr.b 0x02c6,#1
  02F4  A822CA     bset.b 0x02ca,#1
29:                    }
30:                    
31:                    if ((rgbColor.blue == 0)             ||
32:                        (rgbColor.blue  < rgbColor.cntr)) {
  02F6  E248B6     cp0.b 0x08b6
  02F8  320005     bra z, 0x000304
  02FA  BFC8B6     mov.b 0x08b6,0x0000
  02FC  8045B4     mov.w 0x08b6,0x0008
  02FE  DE2248     lsr 0x0008,#8,0x0008
  0300  E12400     cp.b 0x0008,0x0000
  0302  360003     bra leu, 0x00030a
33:                        output_low(LED_B);
  0304  A902C6     bclr.b 0x02c6,#0
  0306  A902CA     bclr.b 0x02ca,#0
34:                    } else {
  0308  370002     bra 0x00030e
35:                        output_high(LED_B);
  030A  A902C6     bclr.b 0x02c6,#0
  030C  A802CA     bset.b 0x02ca,#0
36:                    }
37:                }
38:                
  030E  A9C086     bclr.b 0x0086,#6
  0310  2001A0     mov.w #0x1a,0x0000
  0312  09000C     repeat #12
  0314  78104F     mov.w [--0x001e],[0x0000--]
  0316  78004F     mov.w [--0x001e],0x0000
  0318  F90036     pop.w 0x0036
  031A  F90042     pop.w 0x0042
  031C  064000     retfie
39:                void initRGBLighting()
40:                {
41:                	T5CON = T5CON_INIT;
  150C  280004     mov.w #0x8000,0x0008
  150E  880904     mov.w 0x0008,0x0120
42:                    PR5   = PR5_INIT;
  1510  207934     mov.w #0x793,0x0008
  1512  8808E4     mov.w 0x0008,0x011c
43:                    
44:                	hsvColor.hue        = 0;
  1514  EF28B8     clr.w 0x08b8
45:                	hsvColor.saturation = 255;
  1516  EFE8BA     setm.b 0x08ba
46:                	hsvColor.value      = 255;
  1518  B3CFF0     mov.b #0xff,0x0000
  151A  B7E8BB     mov.b 0x0000,0x08bb
47:                    
48:                    rgbColor.red        = 0;
  151C  EF68B4     clr.b 0x08b4
49:                    rgbColor.green      = 0;
  151E  EF68B5     clr.b 0x08b5
50:                    rgbColor.blue       = 0;
  1520  EF68B6     clr.b 0x08b6
51:                    rgbColor.cntr       = 0;
  1522  EF68B7     clr.b 0x08b7
52:                	
53:                	HSVtoRGB(&hsvColor,&rgbColor);
  1524  208B84     mov.w #0x8b8,0x0008
  1526  884D64     mov.w 0x0008,0x09ac
  1528  208B44     mov.w #0x8b4,0x0008
  152A  884D74     mov.w 0x0008,0x09ae
  152C  021288     call 0x001288
54:                	
55:                    UpdateRGB_Out(&rgbColor);
  1530  208B44     mov.w #0x8b4,0x0008
  1532  884D64     mov.w 0x0008,0x09ac
  1534  021492     call 0x001492
56:                    
57:                    enable_interrupts(INT_TIMER5);
  1538  A8C08E     bset.b 0x008e,#6
58:                }
  153A  060000     return
59:                
60:                //void updatePCA9533()
61:                //{
62:                //	i2c_start();
63:                //	i2c_out_byte(0xC4);
64:                //	i2c_nack();
65:                //	i2c_out_byte(0x11);
66:                //	i2c_nack();
67:                //	i2c_out_byte(0x00);
68:                //	i2c_nack();
69:                //	i2c_out_byte(dimmer0);
70:                //	i2c_nack();
71:                //	i2c_out_byte(0x00);
72:                //	i2c_nack();
73:                //	i2c_out_byte(dimmer1);
74:                //	i2c_nack();
75:                //	i2c_out_byte(dimmerCtrl);
76:                //	i2c_nack();
77:                //	i2c_stop();
78:                //}
79:                
80:                void RGBtoHSV(RGB* rgb, HSV* hsv)
81:                {
82:                
83:                }
84:                
85:                void HSVtoRGB(HSV* hsv, RGB* rgb)
86:                {
  1288  781F85     mov.w 0x000a,[0x001e++]
  128A  781F86     mov.w 0x000c,[0x001e++]
  128C  200030     mov.w #0x3,0x0000
  128E  B409AC     add.w 0x09ac,0x0000
  1290  784290     mov.b [0x0000],0x000a
  1292  EF600B     clr.b 0x000b
  1294  200020     mov.w #0x2,0x0000
  1296  B409AC     add.w 0x09ac,0x0000
  1298  780200     mov.w 0x0000,0x0008
  129A  784014     mov.b [0x0008],0x0000
  129C  EF6001     clr.b 0x0001
  129E  B82800     mul.uu 0x000a,0x0000,0x0000
  12A0  884D80     mov.w 0x0000,0x09b0
  12A2  804D80     mov.w 0x09b0,0x0000
  12A4  020C3E     call 0x000c3e
  12B8  884D90     mov.w 0x0000,0x09b2
  12BA  884DA1     mov.w 0x0002,0x09b4
  12BC  200000     mov.w #0x0,0x0000
  12BE  B409AC     add.w 0x09ac,0x0000
  12C0  780200     mov.w 0x0000,0x0008
  12C2  780014     mov.w [0x0008],0x0000
  12C4  020D42     call 0x000d42
  12D8  884DB0     mov.w 0x0000,0x09b6
  12DA  884DC1     mov.w 0x0002,0x09b8
  12DC  F809B6     push.w 0x09b6
  12DE  F909D2     pop.w 0x09d2
  12E0  F809B8     push.w 0x09b8
  12E2  F909D4     pop.w 0x09d4
  12E4  EF29D6     clr.w 0x09d6
  12E6  240004     mov.w #0x4000,0x0008
  12E8  884EC4     mov.w 0x0008,0x09d8
  12EA  0211FC     call 0x0011fc
  1304  780005     mov.w 0x000a,0x0000
  1306  780086     mov.w 0x000c,0x0002
  1308  A1F001     bclr 0x0002,#15
  130A  A80043     bset.b 0x0043,#0
  130C  780100     mov.w 0x0000,0x0004
  130E  780181     mov.w 0x0002,0x0006
  1310  200000     mov.w #0x0,0x0000
  1312  23F801     mov.w #0x3f80,0x0002
  1314  020E20     call 0x000e20
  1318  780100     mov.w 0x0000,0x0004
  131A  780181     mov.w 0x0002,0x0006
  131C  804D90     mov.w 0x09b2,0x0000
  131E  804DA1     mov.w 0x09b4,0x0002
  1320  020FC0     call 0x000fc0
  1324  884DD0     mov.w 0x0000,0x09ba
  1326  884DE1     mov.w 0x0002,0x09bc
  1328  EF29BE     clr.w 0x09be
  132A  EF29C0     clr.w 0x09c0
  132C  EF29C2     clr.w 0x09c2
  132E  EF29C4     clr.w 0x09c4
  1330  EF29C6     clr.w 0x09c6
  1332  EF29C8     clr.w 0x09c8
87:                	unsigned int cc = (unsigned int)(hsv->value) * (unsigned int)(hsv->saturation);
88:                	float c = (float)cc / 65025.0;
89:                	float h1 = (float)hsv->hue / 60.0;
90:                	//float h2 = h1 / 2;
91:                	//h2 -= (int)h2;
92:                	float x  = c * (1 - fabs(fmod(h1,2.0) - 1));
93:                	float r1 = 0;
94:                	float g1 = 0;
95:                	float b1 = 0;
96:                	
97:                	if (hsv->hue < 60)
  1334  200000     mov.w #0x0,0x0000
  1336  B409AC     add.w 0x09ac,0x0000
  1338  780290     mov.w [0x0000],0x000a
  133A  2003C4     mov.w #0x3c,0x0008
  133C  E12005     cp.w 0x0008,0x000a
  133E  340009     bra les, 0x001352
98:                	{
99:                		r1 = c;
  1340  F809B2     push.w 0x09b2
  1342  F909BE     pop.w 0x09be
  1344  F809B4     push.w 0x09b4
  1346  F909C0     pop.w 0x09c0
100:               		g1 = x;
  1348  F809BA     push.w 0x09ba
  134A  F909C2     pop.w 0x09c2
  134C  F809BC     push.w 0x09bc
  134E  F909C4     pop.w 0x09c4
101:               	}
102:               	else if (hsv->hue < 120)
  1350  37004A     bra 0x0013e6
  1352  200000     mov.w #0x0,0x0000
  1354  B409AC     add.w 0x09ac,0x0000
  1356  780290     mov.w [0x0000],0x000a
  1358  200784     mov.w #0x78,0x0008
  135A  E12005     cp.w 0x0008,0x000a
  135C  340009     bra les, 0x001370
103:               	{
104:               		r1 = x;
  135E  F809BA     push.w 0x09ba
  1360  F909BE     pop.w 0x09be
  1362  F809BC     push.w 0x09bc
  1364  F909C0     pop.w 0x09c0
105:               		g1 = c;
  1366  F809B2     push.w 0x09b2
  1368  F909C2     pop.w 0x09c2
  136A  F809B4     push.w 0x09b4
  136C  F909C4     pop.w 0x09c4
106:               	}
107:               	else if (hsv->hue < 180)
  136E  37003B     bra 0x0013e6
  1370  200000     mov.w #0x0,0x0000
  1372  B409AC     add.w 0x09ac,0x0000
  1374  780290     mov.w [0x0000],0x000a
  1376  200B44     mov.w #0xb4,0x0008
  1378  E12005     cp.w 0x0008,0x000a
  137A  340009     bra les, 0x00138e
108:               	{
109:               		g1 = c;
  137C  F809B2     push.w 0x09b2
  137E  F909C2     pop.w 0x09c2
  1380  F809B4     push.w 0x09b4
  1382  F909C4     pop.w 0x09c4
110:               		b1 = x;
  1384  F809BA     push.w 0x09ba
  1386  F909C6     pop.w 0x09c6
  1388  F809BC     push.w 0x09bc
  138A  F909C8     pop.w 0x09c8
111:               
112:               	}
113:               	else if (hsv->hue < 240)
  138C  37002C     bra 0x0013e6
  138E  200000     mov.w #0x0,0x0000
  1390  B409AC     add.w 0x09ac,0x0000
  1392  780290     mov.w [0x0000],0x000a
  1394  200F04     mov.w #0xf0,0x0008
  1396  E12005     cp.w 0x0008,0x000a
  1398  340009     bra les, 0x0013ac
114:               	{
115:               		g1 = x;
  139A  F809BA     push.w 0x09ba
  139C  F909C2     pop.w 0x09c2
  139E  F809BC     push.w 0x09bc
  13A0  F909C4     pop.w 0x09c4
116:               		b1 = c;
  13A2  F809B2     push.w 0x09b2
  13A4  F909C6     pop.w 0x09c6
  13A6  F809B4     push.w 0x09b4
  13A8  F909C8     pop.w 0x09c8
117:               	}
118:               	else if (hsv->hue < 300)
  13AA  37001D     bra 0x0013e6
  13AC  200000     mov.w #0x0,0x0000
  13AE  B409AC     add.w 0x09ac,0x0000
  13B0  780290     mov.w [0x0000],0x000a
  13B2  2012C4     mov.w #0x12c,0x0008
  13B4  E12005     cp.w 0x0008,0x000a
  13B6  340009     bra les, 0x0013ca
119:               	{
120:               		r1 = x;
  13B8  F809BA     push.w 0x09ba
  13BA  F909BE     pop.w 0x09be
  13BC  F809BC     push.w 0x09bc
  13BE  F909C0     pop.w 0x09c0
121:               		b1 = c;
  13C0  F809B2     push.w 0x09b2
  13C2  F909C6     pop.w 0x09c6
  13C4  F809B4     push.w 0x09b4
  13C6  F909C8     pop.w 0x09c8
122:               	}
123:               	else if (hsv->hue <= 360)
  13C8  37000E     bra 0x0013e6
  13CA  200000     mov.w #0x0,0x0000
  13CC  B409AC     add.w 0x09ac,0x0000
  13CE  780290     mov.w [0x0000],0x000a
  13D0  201684     mov.w #0x168,0x0008
  13D2  E12005     cp.w 0x0008,0x000a
  13D4  350008     bra lts, 0x0013e6
124:               	{
125:               		r1 = c;
  13D6  F809B2     push.w 0x09b2
  13D8  F909BE     pop.w 0x09be
  13DA  F809B4     push.w 0x09b4
  13DC  F909C0     pop.w 0x09c0
126:               		b1 = x;
  13DE  F809BA     push.w 0x09ba
  13E0  F909C6     pop.w 0x09c6
  13E2  F809BC     push.w 0x09bc
  13E4  F909C8     pop.w 0x09c8
127:               	}
128:               	
129:               	float m = ((float)(hsv->value) / 255) - c;
  13E6  200030     mov.w #0x3,0x0000
  13E8  B409AC     add.w 0x09ac,0x0000
  13EA  780200     mov.w 0x0000,0x0008
  13EC  784014     mov.b [0x0008],0x0000
  13EE  EF6001     clr.b 0x0001
  13F0  020C3E     call 0x000c3e
  1416  884E50     mov.w 0x0000,0x09ca
  1418  884E61     mov.w 0x0002,0x09cc
130:               	
131:               	rgb->red   = (unsigned int)(255.0 * (r1+m));
  141A  200000     mov.w #0x0,0x0000
  141C  B409AE     add.w 0x09ae,0x0000
  141E  780280     mov.w 0x0000,0x000a
  1420  A90043     bclr.b 0x0043,#0
  1422  804DF0     mov.w 0x09be,0x0000
  1424  804E01     mov.w 0x09c0,0x0002
  1426  804E52     mov.w 0x09ca,0x0004
  1428  804E63     mov.w 0x09cc,0x0006
  142A  020E20     call 0x000e20
  142E  780100     mov.w 0x0000,0x0004
  1430  780181     mov.w 0x0002,0x0006
  1432  200000     mov.w #0x0,0x0000
  1434  2437F1     mov.w #0x437f,0x0002
  1436  020FC0     call 0x000fc0
  143A  020DF4     call 0x000df4
  143E  784A80     mov.b 0x0000,[0x000a]
132:               	rgb->green = (unsigned int)(255.0 * (g1+m));
  1440  200010     mov.w #0x1,0x0000
  1442  B409AE     add.w 0x09ae,0x0000
  1444  780280     mov.w 0x0000,0x000a
  1446  A90043     bclr.b 0x0043,#0
  1448  804E10     mov.w 0x09c2,0x0000
  144A  804E21     mov.w 0x09c4,0x0002
  144C  804E52     mov.w 0x09ca,0x0004
  144E  804E63     mov.w 0x09cc,0x0006
  1450  020E20     call 0x000e20
  1454  780100     mov.w 0x0000,0x0004
  1456  780181     mov.w 0x0002,0x0006
  1458  200000     mov.w #0x0,0x0000
  145A  2437F1     mov.w #0x437f,0x0002
  145C  020FC0     call 0x000fc0
  1460  020DF4     call 0x000df4
  1464  784A80     mov.b 0x0000,[0x000a]
133:               	rgb->blue  = (unsigned int)(255.0 * (b1+m));
  1466  200020     mov.w #0x2,0x0000
  1468  B409AE     add.w 0x09ae,0x0000
  146A  780280     mov.w 0x0000,0x000a
  146C  A90043     bclr.b 0x0043,#0
  146E  804E30     mov.w 0x09c6,0x0000
  1470  804E41     mov.w 0x09c8,0x0002
  1472  804E52     mov.w 0x09ca,0x0004
  1474  804E63     mov.w 0x09cc,0x0006
  1476  020E20     call 0x000e20
  147A  780100     mov.w 0x0000,0x0004
  147C  780181     mov.w 0x0002,0x0006
  147E  200000     mov.w #0x0,0x0000
  1480  2437F1     mov.w #0x437f,0x0002
  1482  020FC0     call 0x000fc0
  1486  020DF4     call 0x000df4
  148A  784A80     mov.b 0x0000,[0x000a]
134:               
135:               }
  148C  78034F     mov.w [--0x001e],0x000c
  148E  7802CF     mov.w [--0x001e],0x000a
  1490  060000     return
136:               
137:               void UpdateRGB_Out(RGB* rgb)
138:               {
  1492  781F85     mov.w 0x000a,[0x001e++]
139:                   rgb->cntr++;
  1494  200030     mov.w #0x3,0x0000
  1496  B409AC     add.w 0x09ac,0x0000
  1498  780280     mov.w 0x0000,0x000a
  149A  E84A95     inc.b [0x000a],[0x000a]
140:                   
141:                   if ((rgb->red == 0)         &&
142:                       (rgb->red  < rgb->cntr)) {
  149C  200000     mov.w #0x0,0x0000
  149E  B409AC     add.w 0x09ac,0x0000
  14A0  E00410     cp0.b [0x0000]
  14A2  3A000C     bra nz, 0x0014bc
  14A4  200000     mov.w #0x0,0x0000
  14A6  B409AC     add.w 0x09ac,0x0000
  14A8  784290     mov.b [0x0000],0x000a
  14AA  200030     mov.w #0x3,0x0000
  14AC  B409AC     add.w 0x09ac,0x0000
  14AE  780200     mov.w 0x0000,0x0008
  14B0  784014     mov.b [0x0008],0x0000
  14B2  E12C00     cp.b 0x000a,0x0000
  14B4  310003     bra c, 0x0014bc
143:                       output_low(LED_R);
  14B6  A9E2C6     bclr.b 0x02c6,#7
  14B8  A9E2CA     bclr.b 0x02ca,#7
144:                   } else {
  14BA  370002     bra 0x0014c0
145:                       output_high(LED_R);
  14BC  A9E2C6     bclr.b 0x02c6,#7
  14BE  A8E2CA     bset.b 0x02ca,#7
146:                   }
147:                   
148:                   if ((rgb->green == 0)         &&
149:                       (rgb->green  < rgb->cntr)) {
  14C0  200010     mov.w #0x1,0x0000
  14C2  B409AC     add.w 0x09ac,0x0000
  14C4  E00410     cp0.b [0x0000]
  14C6  3A000C     bra nz, 0x0014e0
  14C8  200010     mov.w #0x1,0x0000
  14CA  B409AC     add.w 0x09ac,0x0000
  14CC  784290     mov.b [0x0000],0x000a
  14CE  200030     mov.w #0x3,0x0000
  14D0  B409AC     add.w 0x09ac,0x0000
  14D2  780200     mov.w 0x0000,0x0008
  14D4  784014     mov.b [0x0008],0x0000
  14D6  E12C00     cp.b 0x000a,0x0000
  14D8  310003     bra c, 0x0014e0
150:                       output_low(LED_G);
  14DA  A922C6     bclr.b 0x02c6,#1
  14DC  A922CA     bclr.b 0x02ca,#1
151:                   } else {
  14DE  370002     bra 0x0014e4
152:                       output_high(LED_G);
  14E0  A922C6     bclr.b 0x02c6,#1
  14E2  A822CA     bset.b 0x02ca,#1
153:                   }
154:                   
155:                   if ((rgb->blue == 0)         &&
156:                       (rgb->blue  < rgb->cntr)) {
  14E4  200020     mov.w #0x2,0x0000
  14E6  B409AC     add.w 0x09ac,0x0000
  14E8  E00410     cp0.b [0x0000]
  14EA  3A000C     bra nz, 0x001504
  14EC  200020     mov.w #0x2,0x0000
  14EE  B409AC     add.w 0x09ac,0x0000
  14F0  784290     mov.b [0x0000],0x000a
  14F2  200030     mov.w #0x3,0x0000
  14F4  B409AC     add.w 0x09ac,0x0000
  14F6  780200     mov.w 0x0000,0x0008
  14F8  784014     mov.b [0x0008],0x0000
  14FA  E12C00     cp.b 0x000a,0x0000
  14FC  310003     bra c, 0x001504
157:                       output_low(LED_B);
  14FE  A902C6     bclr.b 0x02c6,#0
  1500  A902CA     bclr.b 0x02ca,#0
158:                   } else {
  1502  370002     bra 0x001508
159:                       output_high(LED_B);
  1504  A902C6     bclr.b 0x02c6,#0
  1506  A802CA     bset.b 0x02ca,#0
160:                   }
161:                   
162:               }
  1508  7802CF     mov.w [--0x001e],0x000a
  150A  060000     return
163:               
164:               void IncreaseHue(HSV* hsv)
165:               {
  2E72  781F85     mov.w 0x000a,[0x001e++]
  2E74  781F86     mov.w 0x000c,[0x001e++]
166:                   hsv->hue = (++hsv->hue)%360;
  2E76  200000     mov.w #0x0,0x0000
  2E78  B4097E     add.w 0x097e,0x0000
  2E7A  780280     mov.w 0x0000,0x000a
  2E7C  200000     mov.w #0x0,0x0000
  2E7E  B4097E     add.w 0x097e,0x0000
  2E80  780300     mov.w 0x0000,0x000c
  2E82  E80B16     inc.w [0x000c],[0x000c]
  2E84  780216     mov.w [0x000c],0x0008
  2E86  201683     mov.w #0x168,0x0006
  2E88  090011     repeat #17
  2E8A  D80203     div.sw 0x0008,0x0006
  2E8C  780001     mov.w 0x0002,0x0000
  2E8E  780A80     mov.w 0x0000,[0x000a]
167:               }
  2E90  78034F     mov.w [--0x001e],0x000c
  2E92  7802CF     mov.w [--0x001e],0x000a
  2E94  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\RTCC.c  --------------------------
1:                 #include "includes.h"
2:                 
3:                 /*
4:                 int8	RTCC_S  = 0;
5:                 int8	RTCC_M  = 0;
6:                 int8	RTCC_H  = 0;
7:                 int8	RTCC_D  = 0;
8:                 int8	RTCC_MM = 0;
9:                 int8	RTCC_Y  = 0;
10:                */
11:                //int1 debugStatus = 0;
12:                int8 SnoozeCount;
13:                
14:                void timeToStruct(tm_struct * returnTimeStruct, int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second)
15:                {
  0888  781F85     mov.w 0x000a,[0x001e++]
  088A  781F86     mov.w 0x000c,[0x001e++]
16:                	returnTimeStruct->tm_sec  = second;
  088C  200000     mov.w #0x0,0x0000
  088E  B4097E     add.w 0x097e,0x0000
  0890  780280     mov.w 0x0000,0x000a
  0892  BFC985     mov.b 0x0985,0x0000
  0894  FB0000     se 0x0000,0x0000
  0896  780A80     mov.w 0x0000,[0x000a]
17:                	returnTimeStruct->tm_min  = minute;
  0898  200020     mov.w #0x2,0x0000
  089A  B4097E     add.w 0x097e,0x0000
  089C  780280     mov.w 0x0000,0x000a
  089E  BFC984     mov.b 0x0984,0x0000
  08A0  FB0000     se 0x0000,0x0000
  08A2  780A80     mov.w 0x0000,[0x000a]
18:                	returnTimeStruct->tm_hour = hour;
  08A4  200040     mov.w #0x4,0x0000
  08A6  B4097E     add.w 0x097e,0x0000
  08A8  780280     mov.w 0x0000,0x000a
  08AA  BFC983     mov.b 0x0983,0x0000
  08AC  FB0000     se 0x0000,0x0000
  08AE  780A80     mov.w 0x0000,[0x000a]
19:                	
20:                	returnTimeStruct->tm_mday = day;
  08B0  200060     mov.w #0x6,0x0000
  08B2  B4097E     add.w 0x097e,0x0000
  08B4  780280     mov.w 0x0000,0x000a
  08B6  BFC982     mov.b 0x0982,0x0000
  08B8  FB0000     se 0x0000,0x0000
  08BA  780A80     mov.w 0x0000,[0x000a]
21:                	returnTimeStruct->tm_mon  = month;
  08BC  200080     mov.w #0x8,0x0000
  08BE  B4097E     add.w 0x097e,0x0000
  08C0  780280     mov.w 0x0000,0x000a
  08C2  BFC981     mov.b 0x0981,0x0000
  08C4  FB0000     se 0x0000,0x0000
  08C6  780A80     mov.w 0x0000,[0x000a]
22:                	returnTimeStruct->tm_year = (int16)year + 100;
  08C8  2000A0     mov.w #0xa,0x0000
  08CA  B4097E     add.w 0x097e,0x0000
  08CC  780280     mov.w 0x0000,0x000a
  08CE  804C06     mov.w 0x0980,0x000c
  08D0  FB0306     se 0x000c,0x000c
  08D2  200644     mov.w #0x64,0x0008
  08D4  430A84     add.w 0x000c,0x0008,[0x000a]
23:                	
24:                }
  08D6  78034F     mov.w [--0x001e],0x000c
  08D8  7802CF     mov.w [--0x001e],0x000a
  08DA  060000     return
25:                
26:                void updateSnoozeTimeWithAlarmTime()
27:                {
28:                	SnoozeTime.tm_sec  = 0;
  0A04  EF294C     clr.w 0x094c
29:                	SnoozeTime.tm_min  = AlarmTime.tm_min;
  0A06  F8093C     push.w 0x093c
  0A08  F9094E     pop.w 0x094e
30:                	SnoozeTime.tm_hour = AlarmTime.tm_hour;
  0A0A  F8093E     push.w 0x093e
  0A0C  F90950     pop.w 0x0950
31:                	SnoozeTime.tm_mday = CurrentTime.tm_mday;
  0A0E  F8092E     push.w 0x092e
  0A10  F90952     pop.w 0x0952
32:                	SnoozeTime.tm_mon  = CurrentTime.tm_mon;
  0A12  F80930     push.w 0x0930
  0A14  F90954     pop.w 0x0954
33:                	SnoozeTime.tm_year = CurrentTime.tm_year;
  0A16  F80932     push.w 0x0932
  0A18  F90956     pop.w 0x0956
34:                	
35:                	alarmData.SnoozeBinaryTime = DS1371_DateToBinary(&SnoozeTime);
  0A1A  2094C4     mov.w #0x94c,0x0008
  0A1C  884CE4     mov.w 0x0008,0x099c
  0A1E  02091E     call 0x00091e
  0A22  8842F0     mov.w 0x0000,0x085e
  0A24  884301     mov.w 0x0002,0x0860
36:                }
  0A26  060000     return
37:                
38:                void updateAlarmTimeWithCurrentTime()
39:                {
40:                	AlarmTime.tm_sec  = 0;
  1814  EF293A     clr.w 0x093a
41:                	AlarmTime.tm_mday = CurrentTime.tm_mday;
  1816  F8092E     push.w 0x092e
  1818  F90940     pop.w 0x0940
42:                	AlarmTime.tm_mon  = CurrentTime.tm_mon;
  181A  F80930     push.w 0x0930
  181C  F90942     pop.w 0x0942
43:                	AlarmTime.tm_year = CurrentTime.tm_year;
  181E  F80932     push.w 0x0932
  1820  F90944     pop.w 0x0944
44:                	
45:                	alarmData.AlarmBinaryTime = DS1371_DateToBinary(&AlarmTime);
  1822  2093A4     mov.w #0x93a,0x0008
  1824  884CE4     mov.w 0x0008,0x099c
  1826  02091E     call 0x00091e
  182A  884310     mov.w 0x0000,0x0862
  182C  884321     mov.w 0x0002,0x0864
46:                }
  182E  060000     return
47:                
48:                float PowerToTimeOn(float x)
49:                {
  158C  781F85     mov.w 0x000a,[0x001e++]
  158E  781F86     mov.w 0x000c,[0x001e++]
  1590  781F87     mov.w 0x000e,[0x001e++]
  1592  781F88     mov.w 0x0010,[0x001e++]
50:                	return 0.98682f * x * x * x * x + 16.07637f * x * x * x - 25.78642f * x * x + 15.82152f * x + 0.63547f;
  1594  2A03C0     mov.w #0xa03c,0x0000
  1596  23F7C1     mov.w #0x3f7c,0x0002
  1598  804CD2     mov.w 0x099a,0x0004
  159A  804CE3     mov.w 0x099c,0x0006
  159C  020FC0     call 0x000fc0
  15A0  780280     mov.w 0x0000,0x000a
  15A2  780301     mov.w 0x0002,0x000c
  15A4  780005     mov.w 0x000a,0x0000
  15A6  780086     mov.w 0x000c,0x0002
  15A8  804CD2     mov.w 0x099a,0x0004
  15AA  804CE3     mov.w 0x099c,0x0006
  15AC  020FC0     call 0x000fc0
  15B0  780280     mov.w 0x0000,0x000a
  15B2  780301     mov.w 0x0002,0x000c
  15B4  780005     mov.w 0x000a,0x0000
  15B6  780086     mov.w 0x000c,0x0002
  15B8  804CD2     mov.w 0x099a,0x0004
  15BA  804CE3     mov.w 0x099c,0x0006
  15BC  020FC0     call 0x000fc0
  15C0  780280     mov.w 0x0000,0x000a
  15C2  780301     mov.w 0x0002,0x000c
  15C4  780005     mov.w 0x000a,0x0000
  15C6  780086     mov.w 0x000c,0x0002
  15C8  804CD2     mov.w 0x099a,0x0004
  15CA  804CE3     mov.w 0x099c,0x0006
  15CC  020FC0     call 0x000fc0
  15D0  780280     mov.w 0x0000,0x000a
  15D2  780301     mov.w 0x0002,0x000c
  15D4  29C680     mov.w #0x9c68,0x0000
  15D6  241801     mov.w #0x4180,0x0002
  15D8  804CD2     mov.w 0x099a,0x0004
  15DA  804CE3     mov.w 0x099c,0x0006
  15DC  020FC0     call 0x000fc0
  15E0  780380     mov.w 0x0000,0x000e
  15E2  780401     mov.w 0x0002,0x0010
  15E4  780007     mov.w 0x000e,0x0000
  15E6  780088     mov.w 0x0010,0x0002
  15E8  804CD2     mov.w 0x099a,0x0004
  15EA  804CE3     mov.w 0x099c,0x0006
  15EC  020FC0     call 0x000fc0
  15F0  780380     mov.w 0x0000,0x000e
  15F2  780401     mov.w 0x0002,0x0010
  15F4  780007     mov.w 0x000e,0x0000
  15F6  780088     mov.w 0x0010,0x0002
  15F8  804CD2     mov.w 0x099a,0x0004
  15FA  804CE3     mov.w 0x099c,0x0006
  15FC  020FC0     call 0x000fc0
  1600  A90043     bclr.b 0x0043,#0
  1602  780100     mov.w 0x0000,0x0004
  1604  780181     mov.w 0x0002,0x0006
  1606  780005     mov.w 0x000a,0x0000
  1608  780086     mov.w 0x000c,0x0002
  160A  020E20     call 0x000e20
  160E  780280     mov.w 0x0000,0x000a
  1610  780301     mov.w 0x0002,0x000c
  1612  24A970     mov.w #0x4a97,0x0000
  1614  241CE1     mov.w #0x41ce,0x0002
  1616  804CD2     mov.w 0x099a,0x0004
  1618  804CE3     mov.w 0x099c,0x0006
  161A  020FC0     call 0x000fc0
  161E  780380     mov.w 0x0000,0x000e
  1620  780401     mov.w 0x0002,0x0010
  1622  780007     mov.w 0x000e,0x0000
  1624  780088     mov.w 0x0010,0x0002
  1626  804CD2     mov.w 0x099a,0x0004
  1628  804CE3     mov.w 0x099c,0x0006
  162A  020FC0     call 0x000fc0
  162E  A80043     bset.b 0x0043,#0
  1630  780100     mov.w 0x0000,0x0004
  1632  780181     mov.w 0x0002,0x0006
  1634  780005     mov.w 0x000a,0x0000
  1636  780086     mov.w 0x000c,0x0002
  1638  020E20     call 0x000e20
  163C  780280     mov.w 0x0000,0x000a
  163E  780301     mov.w 0x0002,0x000c
  1640  224F20     mov.w #0x24f2,0x0000
  1642  2417D1     mov.w #0x417d,0x0002
  1644  804CD2     mov.w 0x099a,0x0004
  1646  804CE3     mov.w 0x099c,0x0006
  1648  020FC0     call 0x000fc0
  164C  A90043     bclr.b 0x0043,#0
  164E  780100     mov.w 0x0000,0x0004
  1650  780181     mov.w 0x0002,0x0006
  1652  780005     mov.w 0x000a,0x0000
  1654  780086     mov.w 0x000c,0x0002
  1656  020E20     call 0x000e20
  165A  780280     mov.w 0x0000,0x000a
  165C  780301     mov.w 0x0002,0x000c
  165E  A90043     bclr.b 0x0043,#0
  1660  780005     mov.w 0x000a,0x0000
  1662  780086     mov.w 0x000c,0x0002
  1664  2AE292     mov.w #0xae29,0x0004
  1666  23F223     mov.w #0x3f22,0x0006
  1668  020E20     call 0x000e20
  166C  BE0000     mov.d 0x0000,0x0000
51:                }
  166E  78044F     mov.w [--0x001e],0x0010
  1670  7803CF     mov.w [--0x001e],0x000e
  1672  78034F     mov.w [--0x001e],0x000c
  1674  7802CF     mov.w [--0x001e],0x000a
  1676  060000     return
52:                
53:                #int_TIMER1
54:                void  TIMER1_isr(void) 
55:                {
  0774  F80042     push.w 0x0042
  0776  F80036     push.w 0x0036
  0778  781F80     mov.w 0x0000,[0x001e++]
  077A  200020     mov.w #0x2,0x0000
  077C  09000C     repeat #12
  077E  781FB0     mov.w [0x0000++],[0x001e++]
56:                	
57:                	alarmData.CurrentBinaryTime++;
  0780  EC2866     inc.w 0x0866
  0782  AF2042     btsc.b 0x0042,#1
  0784  EC2868     inc.w 0x0868
58:                	DS1371_BinaryToDate(alarmData.CurrentBinaryTime,&CurrentTime);    // Increment time by 1 second
  0786  F80866     push.w 0x0866
  0788  F90A50     pop.w 0x0a50
  078A  F80868     push.w 0x0868
  078C  F90A52     pop.w 0x0a52
  078E  209284     mov.w #0x928,0x0008
  0790  8852A4     mov.w 0x0008,0x0a54
  0792  02053A     call 0x00053a
59:                
60:                }
61:                
  0796  A96084     bclr.b 0x0084,#3
  0798  2001A0     mov.w #0x1a,0x0000
  079A  09000C     repeat #12
  079C  78104F     mov.w [--0x001e],[0x0000--]
  079E  78004F     mov.w [--0x001e],0x0000
  07A0  F90036     pop.w 0x0036
  07A2  F90042     pop.w 0x0042
  07A4  064000     retfie
62:                void setDateAndTime(int8 year, int8 month, int8 day, int8 hour, int8 minute, int8 second)
63:                {	  
64:                	 CurrentTime.tm_sec  = second;
65:                	 CurrentTime.tm_min  = minute;
66:                	 CurrentTime.tm_hour = hour;
67:                	 CurrentTime.tm_mday = day;
68:                	 CurrentTime.tm_mon  = month;
69:                	 CurrentTime.tm_year = (int)year + 2000;
70:                	 
71:                	 CurrentTime = DS1371_DateToBinary(&CurrentTime);
72:                }
73:                
74:                /*
75:                ******************************************************************************************************
76:                *                                              InitRTCC()
77:                ******************************************************************************************************
78:                *
79:                * Description : Initialize the Real-Time Clock Calendar Timer.
80:                *
81:                * Arguments   : none.
82:                * 
83:                * Caller      : main().
84:                *
85:                * Returns     : none.
86:                * 
87:                * Notes       : none.
88:                ******************************************************************************************************
89:                */ 
90:                void InitRTCC()
91:                {
92:                                                                        /* Setup timer for 1 intr. per sec.         */
93:                	SETUP_TIMER1(T1_EXTERNAL_RTC);
  0A28  EF2104     clr.w 0x0104
  0A2A  207421     mov.w #0x742,0x0002
  0A2C  200024     mov.w #0x2,0x0008
  0A2E  200462     mov.w #0x46,0x0004
  0A30  200573     mov.w #0x57,0x0006
  0A32  784882     mov.b 0x0004,[0x0002]
  0A34  784883     mov.b 0x0006,[0x0002]
  0A36  784884     mov.b 0x0008,[0x0002]
  0A38  EFA102     setm.w 0x0102
  0A3A  A8C2CD     bset.b 0x02cd,#6
  0A3C  2C0024     mov.w #0xc002,0x0008
  0A3E  880824     mov.w 0x0008,0x0104
94:                	PR1 = 32768;                                        /* 32768                                    */
  0A40  280004     mov.w #0x8000,0x0008
  0A42  880814     mov.w 0x0008,0x0102
95:                  	enable_interrupts(INT_TIMER1);
  0A44  A8608C     bset.b 0x008c,#3
96:                                                                        /* Init Current Time, Alarm Time and ...    */
97:                    timeToStruct(&CurrentTime,11,9,29,18,00,0);         /* ... Snooze Time for Debuging.            */
  0A46  B3C0B0     mov.b #0xb,0x0000
  0A48  B7E980     mov.b 0x0000,0x0980
  0A4A  B3C090     mov.b #0x9,0x0000
  0A4C  B7E981     mov.b 0x0000,0x0981
  0A4E  B3C1D0     mov.b #0x1d,0x0000
  0A50  B7E982     mov.b 0x0000,0x0982
  0A52  B3C120     mov.b #0x12,0x0000
  0A54  B7E983     mov.b 0x0000,0x0983
  0A56  EF6984     clr.b 0x0984
  0A58  EF6985     clr.b 0x0985
  0A5A  209284     mov.w #0x928,0x0008
  0A5C  884BF4     mov.w 0x0008,0x097e
  0A5E  020888     call 0x000888
98:                	timeToStruct(&AlarmTime,  11,9,29,18,30,0);
  0A62  B3C0B0     mov.b #0xb,0x0000
  0A64  B7E980     mov.b 0x0000,0x0980
  0A66  B3C090     mov.b #0x9,0x0000
  0A68  B7E981     mov.b 0x0000,0x0981
  0A6A  B3C1D0     mov.b #0x1d,0x0000
  0A6C  B7E982     mov.b 0x0000,0x0982
  0A6E  B3C120     mov.b #0x12,0x0000
  0A70  B7E983     mov.b 0x0000,0x0983
  0A72  B3C1E0     mov.b #0x1e,0x0000
  0A74  B7E984     mov.b 0x0000,0x0984
  0A76  EF6985     clr.b 0x0985
  0A78  2093A4     mov.w #0x93a,0x0008
  0A7A  884BF4     mov.w 0x0008,0x097e
  0A7C  020888     call 0x000888
99:                    timeToStruct(&SnoozeTime, 11,9,29,18,30,0);
  0A80  B3C0B0     mov.b #0xb,0x0000
  0A82  B7E980     mov.b 0x0000,0x0980
  0A84  B3C090     mov.b #0x9,0x0000
  0A86  B7E981     mov.b 0x0000,0x0981
  0A88  B3C1D0     mov.b #0x1d,0x0000
  0A8A  B7E982     mov.b 0x0000,0x0982
  0A8C  B3C120     mov.b #0x12,0x0000
  0A8E  B7E983     mov.b 0x0000,0x0983
  0A90  B3C1E0     mov.b #0x1e,0x0000
  0A92  B7E984     mov.b 0x0000,0x0984
  0A94  EF6985     clr.b 0x0985
  0A96  2094C4     mov.w #0x94c,0x0008
  0A98  884BF4     mov.w 0x0008,0x097e
  0A9A  020888     call 0x000888
100:                                                                       /* Calc. current binary date & time.        */
101:               	alarmData.CurrentBinaryTime = DS1371_DateToBinary(&CurrentTime);
  0A9E  209284     mov.w #0x928,0x0008
  0AA0  884CE4     mov.w 0x0008,0x099c
  0AA2  02091E     call 0x00091e
  0AA6  884330     mov.w 0x0000,0x0866
  0AA8  884341     mov.w 0x0002,0x0868
102:                   alarmData.AlarmBinaryTime   = DS1371_DateToBinary(&AlarmTime);
  0AAA  2093A4     mov.w #0x93a,0x0008
  0AAC  884CE4     mov.w 0x0008,0x099c
  0AAE  02091E     call 0x00091e
  0AB2  884310     mov.w 0x0000,0x0862
  0AB4  884321     mov.w 0x0002,0x0864
103:                   
104:                                                                       /* Calc. next alarm ringing.                */
105:               	updateSnoozeTimeWithAlarmTime();
  0AB6  020A04     call 0x000a04
106:                   
107:                   alarmData.AlarmState     = ALARM_STANDBY;
  0ABA  B3C010     mov.b #0x1,0x0000
  0ABC  B7E876     mov.b 0x0000,0x0876
108:                   alarmData.MainLoops      = 0;
  0ABE  EF286A     clr.w 0x086a
  0AC0  EF286C     clr.w 0x086c
109:                   alarmData.PulseWidthErr  = 0;
  0AC2  EF286E     clr.w 0x086e
  0AC4  EF2870     clr.w 0x0870
110:                   alarmData.ButtonDownTick = 0;
  0AC6  EF2872     clr.w 0x0872
  0AC8  EF2874     clr.w 0x0874
111:               }
  0ACA  060000     return
112:               
113:               /*
114:                ******************************************************************************************************
115:                *                                          AlarmStateMachine()
116:                ******************************************************************************************************
117:                *
118:                * Description : Processed the alarm state machine for ringing, lamp power and snoozes
119:                *
120:                * Arguments   : none.
121:                * 
122:                * Caller      : TIMER1_isr().
123:                *
124:                * Returns     : none.
125:                * 
126:                * Notes       : none.
127:                ******************************************************************************************************
128:                */ 
129:               void AlarmStateMachine (void)
130:               {
  18BC  781F85     mov.w 0x000a,[0x001e++]
  18BE  781F86     mov.w 0x000c,[0x001e++]
131:                   switch (alarmData.AlarmState) {
  18C0  BFC876     mov.b 0x0876,0x0000
  18C2  EF6001     clr.b 0x0001
  18C4  B28010     xor.w #0x1,0x0000
  18C6  32000B     bra z, 0x0018de
  18C8  B28030     xor.w #0x3,0x0000
  18CA  320032     bra z, 0x001930
  18CC  B28010     xor.w #0x1,0x0000
  18CE  32006F     bra z, 0x0019ae
  18D0  B28070     xor.w #0x7,0x0000
  18D2  320094     bra z, 0x0019fc
  18D4  B28010     xor.w #0x1,0x0000
  18D6  3200E7     bra z, 0x001aa6
  18D8  B28030     xor.w #0x3,0x0000
  18DA  320126     bra z, 0x001b28
  18DC  370150     bra 0x001b7e
132:                       case ALARM_STANDBY:                             /* ------------ ALARM_STANDBY ------------- */
133:                                                                       /* CONDITION1 - Now is within TdelayRamp .. */
134:                           light_on_time = alarmData.AlarmBinaryTime - ((unsigned long) delayLoadLighting) * 60ul;
  18DE  804705     mov.w 0x08e0,0x000a
  18E0  FB0285     se 0x000a,0x000a
  18E2  EB0300     clr.w 0x000c
  18E4  A7F005     btsc 0x000a,#15
  18E6  EB8300     setm.w 0x000c
  18E8  F80042     push.w 0x0042
  18EA  EFE042     setm.b 0x0042
  18EC  780005     mov.w 0x000a,0x0000
  18EE  780086     mov.w 0x000c,0x0002
  18F0  2003C2     mov.w #0x3c,0x0004
  18F2  200003     mov.w #0x0,0x0006
  18F4  02050A     call 0x00050a
  18F8  F90042     pop.w 0x0042
  18FA  804314     mov.w 0x0862,0x0008
  18FC  520000     sub.w 0x0008,0x0000,0x0000
  18FE  884B80     mov.w 0x0000,0x0970
  1900  804324     mov.w 0x0864,0x0008
  1902  5A0001     subb.w 0x0008,0x0002,0x0000
  1904  884B90     mov.w 0x0000,0x0972
135:                                                                       /* .. of Talarm.                            */
136:                                                                       /* If the time is within the ramp section.  */
137:                           if ((alarmData.CurrentBinaryTime >= light_on_time) &&
138:                               (alarmData.CurrentBinaryTime <  alarmData.AlarmBinaryTime)) {
  1906  804B90     mov.w 0x0972,0x0000
  1908  804344     mov.w 0x0868,0x0008
  190A  E12000     cp.w 0x0008,0x0000
  190C  390010     bra nc, 0x00192e
  190E  3E0004     bra gtu, 0x001918
  1910  804B80     mov.w 0x0970,0x0000
  1912  804334     mov.w 0x0866,0x0008
  1914  E12000     cp.w 0x0008,0x0000
  1916  39000B     bra nc, 0x00192e
  1918  804340     mov.w 0x0868,0x0000
  191A  804324     mov.w 0x0864,0x0008
  191C  E12000     cp.w 0x0008,0x0000
  191E  390007     bra nc, 0x00192e
  1920  3E0004     bra gtu, 0x00192a
  1922  804330     mov.w 0x0866,0x0000
  1924  804314     mov.w 0x0862,0x0008
  1926  E12000     cp.w 0x0008,0x0000
  1928  360002     bra leu, 0x00192e
139:                                                                       /* Set the next state to ALARM_RAMP.        */
140:                               alarmData.AlarmState = ALARM_RAMP;
  192A  B3C020     mov.b #0x2,0x0000
  192C  B7E876     mov.b 0x0000,0x0876
141:                           }
142:                           break;
  192E  370128     bra 0x001b80
143:                           
144:                       case ALARM_RAMP:                                /* -------------- ALARM_RAMP -------------- */
145:                           
146:                           CalculateLuminosity();                      /* Evaluate Lamp Intensity.                 */
  1930  021678     call 0x001678
147:                           
148:                                                                       /* CONDITION1 - Now is Talarm.              */
149:                           light_on_time = alarmData.AlarmBinaryTime - ((unsigned long) delayLoadLighting) * 60ul;
  1934  804705     mov.w 0x08e0,0x000a
  1936  FB0285     se 0x000a,0x000a
  1938  EB0300     clr.w 0x000c
  193A  A7F005     btsc 0x000a,#15
  193C  EB8300     setm.w 0x000c
  193E  F80042     push.w 0x0042
  1940  EFE042     setm.b 0x0042
  1942  780005     mov.w 0x000a,0x0000
  1944  780086     mov.w 0x000c,0x0002
  1946  2003C2     mov.w #0x3c,0x0004
  1948  200003     mov.w #0x0,0x0006
  194A  02050A     call 0x00050a
  194E  F90042     pop.w 0x0042
  1950  804314     mov.w 0x0862,0x0008
  1952  520000     sub.w 0x0008,0x0000,0x0000
  1954  884B80     mov.w 0x0000,0x0970
  1956  804324     mov.w 0x0864,0x0008
  1958  5A0001     subb.w 0x0008,0x0002,0x0000
  195A  884B90     mov.w 0x0000,0x0972
150:                           
151:                           if (alarmData.CurrentBinaryTime == alarmData.AlarmBinaryTime) {
  195C  804330     mov.w 0x0866,0x0000
  195E  E30862     cp.w 0x0862
  1960  3A0011     bra nz, 0x001984
  1962  804340     mov.w 0x0868,0x0000
  1964  E30864     cp.w 0x0864
  1966  3A000E     bra nz, 0x001984
152:                                   
153:                               /// TODO : Add transition actions
154:                                                                       /* Set SnoozeCount to 0.                    */
155:                               SnoozeCount = 0;
  1968  EF6978     clr.b 0x0978
156:                                                                       /* Start Chime.                             */
157:                               setChime(true);
  196A  B3C010     mov.b #0x1,0x0000
  196C  B7E98E     mov.b 0x0000,0x098e
  196E  02153C     call 0x00153c
158:                                                                       /* Set SnoozeTime to AlarmTime.             */
159:                               alarmData.SnoozeBinaryTime = alarmData.AlarmBinaryTime;
  1972  F80862     push.w 0x0862
  1974  F9085E     pop.w 0x085e
  1976  F80864     push.w 0x0864
  1978  F90860     pop.w 0x0860
160:                               pushAck = false;
  197A  A92966     bclr.b 0x0966,#1
161:                               pushLongAck = false;
  197C  A94966     bclr.b 0x0966,#2
162:                               
163:                                                                       /* Set the next state to ALARM_WAKE.        */
164:                               alarmData.AlarmState = ALARM_WAKE;
  197E  B3C030     mov.b #0x3,0x0000
  1980  B7E876     mov.b 0x0000,0x0876
165:                           } else if ((alarmData.CurrentBinaryTime < light_on_time) ||
  1982  370014     bra 0x0019ac
166:                                      (alarmData.CurrentBinaryTime > alarmData.AlarmBinaryTime)) {
  1984  804340     mov.w 0x0868,0x0000
  1986  804B94     mov.w 0x0972,0x0008
  1988  E12000     cp.w 0x0008,0x0000
  198A  3E000E     bra gtu, 0x0019a8
  198C  390004     bra nc, 0x001996
  198E  804330     mov.w 0x0866,0x0000
  1990  804B84     mov.w 0x0970,0x0008
  1992  E12000     cp.w 0x0008,0x0000
  1994  3E0009     bra gtu, 0x0019a8
  1996  804320     mov.w 0x0864,0x0000
  1998  804344     mov.w 0x0868,0x0008
  199A  E12000     cp.w 0x0008,0x0000
  199C  390007     bra nc, 0x0019ac
  199E  3E0004     bra gtu, 0x0019a8
  19A0  804310     mov.w 0x0862,0x0000
  19A2  804334     mov.w 0x0866,0x0008
  19A4  E12000     cp.w 0x0008,0x0000
  19A6  360002     bra leu, 0x0019ac
167:                                                                       /* CONDITION2 - Now is not w/in TdelayRamp. */
168:                               RTCC_TransitionToSTANDBY();
  19A8  0218A0     call 0x0018a0
169:                           }
170:                           
171:                           break;
  19AC  3700E9     bra 0x001b80
172:                
173:                       case ALARM_WAKE:                                /* -------------- ALARM_WAKE -------------- */
174:                                                                       /* CONDITION1 - Button  is pushed.          */
175:                                                                       /* CONDITION2 - Timeout is expired.         */
176:                           if (pushAck || 
177:                              (alarmData.CurrentBinaryTime >= (alarmData.SnoozeBinaryTime + ALARM_WAKE_TIMEOUT_SEC))) {
  19AE  AF2966     btsc.b 0x0966,#1
  19B0  37000D     bra 0x0019cc
  19B2  2003C4     mov.w #0x3c,0x0008
  19B4  8042F3     mov.w 0x085e,0x0006
  19B6  418004     add.w 0x0006,0x0008,0x0000
  19B8  804304     mov.w 0x0860,0x0008
  19BA  4A0260     addc.w 0x0008,#0,0x0008
  19BC  780084     mov.w 0x0008,0x0002
  19BE  804344     mov.w 0x0868,0x0008
  19C0  E12001     cp.w 0x0008,0x0002
  19C2  39001B     bra nc, 0x0019fa
  19C4  3E0003     bra gtu, 0x0019cc
  19C6  804334     mov.w 0x0866,0x0008
  19C8  E12000     cp.w 0x0008,0x0000
  19CA  390017     bra nc, 0x0019fa
178:                               pushAck = false;                        /* Consume pushbutton acknowledge.          */
  19CC  A92966     bclr.b 0x0966,#1
179:                               
180:                                                                       /* Shutdown the buzzer.                     */
181:                               setChime(false);
  19CE  EF698E     clr.b 0x098e
  19D0  02153C     call 0x00153c
182:                                                                       /* Add SnoozeTime to SnoozeBinaryTime.      */
183:                               alarmData.SnoozeBinaryTime += 60 * (unsigned long)AlarmSnoozeTime;
  19D4  BFC8E1     mov.b 0x08e1,0x0000
  19D6  EF6001     clr.b 0x0001
  19D8  200001     mov.w #0x0,0x0002
  19DA  F80042     push.w 0x0042
  19DC  EFE042     setm.b 0x0042
  19DE  780100     mov.w 0x0000,0x0004
  19E0  780181     mov.w 0x0002,0x0006
  19E2  2003C0     mov.w #0x3c,0x0000
  19E4  200001     mov.w #0x0,0x0002
  19E6  02050A     call 0x00050a
  19EA  F90042     pop.w 0x0042
  19EC  B4285E     add.w 0x085e
  19EE  780001     mov.w 0x0002,0x0000
  19F0  B48860     addc.w 0x0860,0x0000
  19F2  884300     mov.w 0x0000,0x0860
184:                                                                       /* TODO : Inclrease SnoozeCount.            */
185:                               SnoozeCount++;
  19F4  EC6978     inc.b 0x0978
186:                               
187:                               alarmData.AlarmState = ALARM_SNOOZE;
  19F6  B3C040     mov.b #0x4,0x0000
  19F8  B7E876     mov.b 0x0000,0x0876
188:                           }
189:                                                                       
190:                           
191:                           break;
  19FA  3700C2     bra 0x001b80
192:                           
193:                       case ALARM_SNOOZE:                              /* ------------- ALARM_SNOOZE ------------- */
194:                           light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul;
  19FC  804705     mov.w 0x08e0,0x000a
  19FE  FB0285     se 0x000a,0x000a
  1A00  EB0300     clr.w 0x000c
  1A02  A7F005     btsc 0x000a,#15
  1A04  EB8300     setm.w 0x000c
  1A06  F80042     push.w 0x0042
  1A08  EFE042     setm.b 0x0042
  1A0A  780005     mov.w 0x000a,0x0000
  1A0C  780086     mov.w 0x000c,0x0002
  1A0E  2003C2     mov.w #0x3c,0x0004
  1A10  200003     mov.w #0x0,0x0006
  1A12  02050A     call 0x00050a
  1A16  F90042     pop.w 0x0042
  1A18  8042F4     mov.w 0x085e,0x0008
  1A1A  520000     sub.w 0x0008,0x0000,0x0000
  1A1C  884B80     mov.w 0x0000,0x0970
  1A1E  804304     mov.w 0x0860,0x0008
  1A20  5A0001     subb.w 0x0008,0x0002,0x0000
  1A22  884B90     mov.w 0x0000,0x0972
195:                                                                       /* CONDITION1 - AlarmLampOn is true.        */
196:                           if (AlarmLampOn) {
  1A24  AEC885     btss.b 0x0885,#6
  1A26  370008     bra 0x001a38
197:                               
198:                                                                       /* Set Lamp to maximum intensity.           */
199:                               SetLampIntensity(0.50f);
  1A28  EF298E     clr.w 0x098e
  1A2A  23F004     mov.w #0x3f00,0x0008
  1A2C  884C84     mov.w 0x0008,0x0990
  1A2E  0217AA     call 0x0017aa
200:                               
201:                               alarmData.AlarmState = ALARM_LAMP_ON;
  1A32  B3C060     mov.b #0x6,0x0000
  1A34  B7E876     mov.b 0x0000,0x0876
202:                           }
203:                           
204:                                                                       /* CONDITION2 - Now is within TdelayRamp .. */
205:                                                                       /* .. of Tsnooze.                           */
206:                           else if ((alarmData.CurrentBinaryTime > light_on_time) &&
  1A36  370036     bra 0x001aa4
207:                                   (alarmData.CurrentBinaryTime < alarmData.SnoozeBinaryTime)) {
  1A38  804B90     mov.w 0x0972,0x0000
  1A3A  804344     mov.w 0x0868,0x0008
  1A3C  E12000     cp.w 0x0008,0x0000
  1A3E  390011     bra nc, 0x001a62
  1A40  3E0004     bra gtu, 0x001a4a
  1A42  804B80     mov.w 0x0970,0x0000
  1A44  804334     mov.w 0x0866,0x0008
  1A46  E12000     cp.w 0x0008,0x0000
  1A48  36000C     bra leu, 0x001a62
  1A4A  804340     mov.w 0x0868,0x0000
  1A4C  804304     mov.w 0x0860,0x0008
  1A4E  E12000     cp.w 0x0008,0x0000
  1A50  390008     bra nc, 0x001a62
  1A52  3E0004     bra gtu, 0x001a5c
  1A54  804330     mov.w 0x0866,0x0000
  1A56  8042F4     mov.w 0x085e,0x0008
  1A58  E12000     cp.w 0x0008,0x0000
  1A5A  360003     bra leu, 0x001a62
208:                               
209:                               alarmData.AlarmState = ALARM_SNOOZE_RAMP;
  1A5C  B3C050     mov.b #0x5,0x0000
  1A5E  B7E876     mov.b 0x0000,0x0876
210:                           }
211:                                                                       /* CONDITION3 - Now ain't w/i TdelayRamp .. */
212:                                                                       /* .. of Tsnooze.                           */
213:                                                                       /* CONDITION4 - Snooze Count Limit Reached. */
214:                           else if ((alarmData.CurrentBinaryTime  < light_on_time)              ||
  1A60  370021     bra 0x001aa4
215:                                    (alarmData.CurrentBinaryTime  > alarmData.SnoozeBinaryTime) ||
216:                                    (SnoozeCount                 == ALARM_MAX_SNOOZE_COUNT)     || 
217:                                    (pushLongAck                 == true)) {
  1A62  804340     mov.w 0x0868,0x0000
  1A64  804B94     mov.w 0x0972,0x0008
  1A66  E12000     cp.w 0x0008,0x0000
  1A68  3E0013     bra gtu, 0x001a90
  1A6A  390004     bra nc, 0x001a74
  1A6C  804330     mov.w 0x0866,0x0000
  1A6E  804B84     mov.w 0x0970,0x0008
  1A70  E12000     cp.w 0x0008,0x0000
  1A72  3E000E     bra gtu, 0x001a90
  1A74  804300     mov.w 0x0860,0x0000
  1A76  804344     mov.w 0x0868,0x0008
  1A78  E12000     cp.w 0x0008,0x0000
  1A7A  3E000A     bra gtu, 0x001a90
  1A7C  390004     bra nc, 0x001a86
  1A7E  8042F0     mov.w 0x085e,0x0000
  1A80  804334     mov.w 0x0866,0x0008
  1A82  E12000     cp.w 0x0008,0x0000
  1A84  3E0005     bra gtu, 0x001a90
  1A86  804BC4     mov.w 0x0978,0x0008
  1A88  E12463     cp.b 0x0008,#3
  1A8A  320002     bra z, 0x001a90
  1A8C  AE4966     btss.b 0x0966,#2
  1A8E  370003     bra 0x001a96
218:               
219:                               RTCC_TransitionToSTANDBY();
  1A90  0218A0     call 0x0018a0
220:                           }
221:                                                                       /* CONDITION5 - PushLongAck is true.        */
222:                           else if (pushLongAck == true) {
  1A94  370007     bra 0x001aa4
  1A96  AE4966     btss.b 0x0966,#2
  1A98  370005     bra 0x001aa4
223:                                                                       /* Consume pushLongAck.                     */
224:                               pushLongAck = false;
  1A9A  A94966     bclr.b 0x0966,#2
225:                               alarmData.ButtonDownTick = 0;
  1A9C  EF2872     clr.w 0x0872
  1A9E  EF2874     clr.w 0x0874
226:                               
227:                               RTCC_TransitionToSTANDBY();
  1AA0  0218A0     call 0x0018a0
228:                           }
229:                           
230:                           break;
  1AA4  37006D     bra 0x001b80
231:                   
232:                       case ALARM_SNOOZE_RAMP:                         /* ---------- ALARM_SNOOZE_RAMP ----------- */
233:                       	light_on_time = alarmData.SnoozeBinaryTime - ((unsigned long) delayLoadLighting) * 60ul;
  1AA6  804705     mov.w 0x08e0,0x000a
  1AA8  FB0285     se 0x000a,0x000a
  1AAA  EB0300     clr.w 0x000c
  1AAC  A7F005     btsc 0x000a,#15
  1AAE  EB8300     setm.w 0x000c
  1AB0  F80042     push.w 0x0042
  1AB2  EFE042     setm.b 0x0042
  1AB4  780005     mov.w 0x000a,0x0000
  1AB6  780086     mov.w 0x000c,0x0002
  1AB8  2003C2     mov.w #0x3c,0x0004
  1ABA  200003     mov.w #0x0,0x0006
  1ABC  02050A     call 0x00050a
  1AC0  F90042     pop.w 0x0042
  1AC2  8042F4     mov.w 0x085e,0x0008
  1AC4  520000     sub.w 0x0008,0x0000,0x0000
  1AC6  884B80     mov.w 0x0000,0x0970
  1AC8  804304     mov.w 0x0860,0x0008
  1ACA  5A0001     subb.w 0x0008,0x0002,0x0000
  1ACC  884B90     mov.w 0x0000,0x0972
234:                           
235:                           CalculateLuminosity();                      /* Evaluate Lamp Intensity.                 */
  1ACE  021678     call 0x001678
236:                           
237:                                                                       /* CONDITION1 - Tnow is Tsnooze.            */
238:                           if (alarmData.CurrentBinaryTime == alarmData.SnoozeBinaryTime) {
  1AD2  804330     mov.w 0x0866,0x0000
  1AD4  E3085E     cp.w 0x085e
  1AD6  3A000C     bra nz, 0x001af0
  1AD8  804340     mov.w 0x0868,0x0000
  1ADA  E30860     cp.w 0x0860
  1ADC  3A0009     bra nz, 0x001af0
239:                               
240:                                                                       /* Activate the buzzer.                     */
241:                               setChime(true);
  1ADE  B3C010     mov.b #0x1,0x0000
  1AE0  B7E98E     mov.b 0x0000,0x098e
  1AE2  02153C     call 0x00153c
242:                               pushAck = false;
  1AE6  A92966     bclr.b 0x0966,#1
243:                               pushLongAck = false;
  1AE8  A94966     bclr.b 0x0966,#2
244:                               
245:                               alarmData.AlarmState = ALARM_WAKE;
  1AEA  B3C030     mov.b #0x3,0x0000
  1AEC  B7E876     mov.b 0x0000,0x0876
246:                           }
247:                                                                       /* CONDITION2 - Now ain't w/i TdelayRamp .. */
248:                                                                       /* .. of Tsnooze.                           */
249:                                                                       /* CONDITION3 - pushLongAck is true.        */
250:                           else if ((alarmData.CurrentBinaryTime  < light_on_time)    ||
  1AEE  37001B     bra 0x001b26
251:                                    (alarmData.CurrentBinaryTime  > alarmData.SnoozeBinaryTime) ||
252:                                    (pushLongAck       == true))
  1AF0  804340     mov.w 0x0868,0x0000
  1AF2  804B94     mov.w 0x0972,0x0008
  1AF4  E12000     cp.w 0x0008,0x0000
  1AF6  3E0010     bra gtu, 0x001b18
  1AF8  390004     bra nc, 0x001b02
  1AFA  804330     mov.w 0x0866,0x0000
  1AFC  804B84     mov.w 0x0970,0x0008
  1AFE  E12000     cp.w 0x0008,0x0000
  1B00  3E000B     bra gtu, 0x001b18
  1B02  804300     mov.w 0x0860,0x0000
  1B04  804344     mov.w 0x0868,0x0008
  1B06  E12000     cp.w 0x0008,0x0000
  1B08  3E0007     bra gtu, 0x001b18
  1B0A  390004     bra nc, 0x001b14
  1B0C  8042F0     mov.w 0x085e,0x0000
  1B0E  804334     mov.w 0x0866,0x0008
  1B10  E12000     cp.w 0x0008,0x0000
  1B12  3E0002     bra gtu, 0x001b18
  1B14  AE4966     btss.b 0x0966,#2
  1B16  370007     bra 0x001b26
253:                           {
254:                              if (pushLongAck == true) {
  1B18  AE4966     btss.b 0x0966,#2
  1B1A  370003     bra 0x001b22
255:                                                                       /* Consume pushLongAck.                     */
256:                                  pushLongAck = false;
  1B1C  A94966     bclr.b 0x0966,#2
257:                                  alarmData.ButtonDownTick = 0;
  1B1E  EF2872     clr.w 0x0872
  1B20  EF2874     clr.w 0x0874
258:                              }
259:                              RTCC_TransitionToSTANDBY();
  1B22  0218A0     call 0x0018a0
260:                           }
261:                           
262:                           break;
  1B26  37002C     bra 0x001b80
263:                           
264:                       case ALARM_LAMP_ON:                             /* ------------ ALARM_LAMP_ON ------------- */
265:                                                                       /* CONDITION 1 - Now is SnoozeTime.         */
266:                           if (alarmData.CurrentBinaryTime == alarmData.SnoozeBinaryTime) {
  1B28  804330     mov.w 0x0866,0x0000
  1B2A  E3085E     cp.w 0x085e
  1B2C  3A000C     bra nz, 0x001b46
  1B2E  804340     mov.w 0x0868,0x0000
  1B30  E30860     cp.w 0x0860
  1B32  3A0009     bra nz, 0x001b46
267:                               
268:                                                                       /* Activate the buzzer.                     */
269:                               setChime(true);
  1B34  B3C010     mov.b #0x1,0x0000
  1B36  B7E98E     mov.b 0x0000,0x098e
  1B38  02153C     call 0x00153c
270:                               pushAck = false;
  1B3C  A92966     bclr.b 0x0966,#1
271:                               pushLongAck = false;
  1B3E  A94966     bclr.b 0x0966,#2
272:                               
273:                               alarmData.AlarmState = ALARM_WAKE;
  1B40  B3C030     mov.b #0x3,0x0000
  1B42  B7E876     mov.b 0x0000,0x0876
274:                           }
275:                                                                       /* CONDITION2 - Now ain't w/i TdelayRamp .. */
276:                                                                       /* .. of Tsnooze.                           */
277:                           else if ((alarmData.CurrentBinaryTime < light_on_time)    ||
  1B44  37001B     bra 0x001b7c
278:                                    (alarmData.CurrentBinaryTime > alarmData.SnoozeBinaryTime) ||
279:                                    (pushLongAck == true)) {
  1B46  804340     mov.w 0x0868,0x0000
  1B48  804B94     mov.w 0x0972,0x0008
  1B4A  E12000     cp.w 0x0008,0x0000
  1B4C  3E0010     bra gtu, 0x001b6e
  1B4E  390004     bra nc, 0x001b58
  1B50  804330     mov.w 0x0866,0x0000
  1B52  804B84     mov.w 0x0970,0x0008
  1B54  E12000     cp.w 0x0008,0x0000
  1B56  3E000B     bra gtu, 0x001b6e
  1B58  804300     mov.w 0x0860,0x0000
  1B5A  804344     mov.w 0x0868,0x0008
  1B5C  E12000     cp.w 0x0008,0x0000
  1B5E  3E0007     bra gtu, 0x001b6e
  1B60  390004     bra nc, 0x001b6a
  1B62  8042F0     mov.w 0x085e,0x0000
  1B64  804334     mov.w 0x0866,0x0008
  1B66  E12000     cp.w 0x0008,0x0000
  1B68  3E0002     bra gtu, 0x001b6e
  1B6A  AE4966     btss.b 0x0966,#2
  1B6C  370007     bra 0x001b7c
280:                               
281:                               if (pushLongAck == true) {
  1B6E  AE4966     btss.b 0x0966,#2
  1B70  370003     bra 0x001b78
282:                                                                       /* Consume pushLongAck.                     */
283:                                   pushLongAck = false;
  1B72  A94966     bclr.b 0x0966,#2
284:                                   alarmData.ButtonDownTick = 0;
  1B74  EF2872     clr.w 0x0872
  1B76  EF2874     clr.w 0x0874
285:                               }
286:                               
287:                               RTCC_TransitionToSTANDBY();
  1B78  0218A0     call 0x0018a0
288:                           }
289:                           
290:                           break;
  1B7C  370001     bra 0x001b80
291:                           
292:                       default:
293:                           break;
  1B7E  370000     bra 0x001b80
294:                   }
295:               }
  1B80  78034F     mov.w [--0x001e],0x000c
  1B82  7802CF     mov.w [--0x001e],0x000a
  1B84  060000     return
296:               
297:               /*
298:                ******************************************************************************************************
299:                *                                         FindNextAlarmTime()
300:                ******************************************************************************************************
301:                *
302:                * Description : Calculates the next AlarmBinaryTime based on the enabled days in ???.
303:                *
304:                * Arguments   : none.
305:                * 
306:                * Caller      : RTCC_TransitionToSTANDBY().
307:                *
308:                * Returns     : none.
309:                * 
310:                * Notes       : none.
311:                ******************************************************************************************************
312:                */ 
313:               void FindNextAlarmTime(void)
314:               {
  1830  781F85     mov.w 0x000a,[0x001e++]
315:                            int1 valid_alarm_time;
316:                   unsigned long temp_alarm_time;
317:                                 int8 day_counter;
318:                   
319:                   valid_alarm_time = false;
  1832  A90996     bclr.b 0x0996,#0
320:                   day_counter      = 0;
  1834  EF6997     clr.b 0x0997
321:                                                                       /* Calculate today's AlarmBinaryTime.       */
322:                   updateAlarmTimeWithCurrentTime();
  1836  021814     call 0x001814
323:                   
324:                                                                       /* While !validAlarmTime & dayCounter < 7:  */
325:                   while ((valid_alarm_time == false) && 
326:                          (day_counter       < RTCC_MAX_DAY_LOOKAHEAD)) {
  183A  AF0996     btsc.b 0x0996,#0
  183C  37002F     bra 0x00189c
  183E  804CB4     mov.w 0x0996,0x0008
  1840  DE2248     lsr 0x0008,#8,0x0008
  1842  E12467     cp.b 0x0008,#7
  1844  3D002B     bra ges, 0x00189c
327:                       
328:                       
329:                   
330:                                                                       /* TempAlarm = AlarmBinaryTime + ...        */
331:                                                                       /* ... dayCounter * 24h.                    */
332:                       temp_alarm_time = alarmData.AlarmBinaryTime + (day_counter * SEC_IN_A_DAY);
  1846  BFC997     mov.b 0x0997,0x0000
  1848  FB0000     se 0x0000,0x0000
  184A  EB0080     clr.w 0x0002
  184C  A7F000     btsc 0x0000,#15
  184E  EB8080     setm.w 0x0002
  1850  251802     mov.w #0x5180,0x0004
  1852  200013     mov.w #0x1,0x0006
  1854  0208DC     call 0x0008dc
  1858  804314     mov.w 0x0862,0x0008
  185A  400004     add.w 0x0000,0x0008,0x0000
  185C  884CC0     mov.w 0x0000,0x0998
  185E  804324     mov.w 0x0864,0x0008
  1860  488004     addc.w 0x0002,0x0008,0x0000
  1862  884CD0     mov.w 0x0000,0x099a
333:                       DS1371_BinaryToDate(temp_alarm_time, &AlarmTime);
  1864  F80042     push.w 0x0042
  1866  EFE042     setm.b 0x0042
  1868  F80998     push.w 0x0998
  186A  F90A50     pop.w 0x0a50
  186C  F8099A     push.w 0x099a
  186E  F90A52     pop.w 0x0a52
  1870  2093A4     mov.w #0x93a,0x0008
  1872  8852A4     mov.w 0x0008,0x0a54
  1874  02053A     call 0x00053a
  1878  F90042     pop.w 0x0042
334:                                                                       /* If dayOfTheWeek of TempAlarm is true :   */  
335:                       if (ALARM_DAYS[AlarmTime.tm_wday] == true) {
  187A  209204     mov.w #0x920,0x0008
  187C  804A33     mov.w 0x0946,0x0006
  187E  418004     add.w 0x0006,0x0008,0x0000
  1880  784210     mov.b [0x0000],0x0008
  1882  E12461     cp.b 0x0008,#1
  1884  3A0009     bra nz, 0x001898
336:                                                                       /* validAlarmTime = true.                   */
337:                           valid_alarm_time = true;
  1886  A80996     bset.b 0x0996,#0
338:                                                                       /* AlarmBinaryTime = TempAlarm.             */
339:                           alarmData.AlarmBinaryTime  = temp_alarm_time;
  1888  F80998     push.w 0x0998
  188A  F90862     pop.w 0x0862
  188C  F8099A     push.w 0x099a
  188E  F90864     pop.w 0x0864
340:                           alarmData.SnoozeBinaryTime = alarmData.AlarmBinaryTime;
  1890  F80862     push.w 0x0862
  1892  F9085E     pop.w 0x085e
  1894  F80864     push.w 0x0864
  1896  F90860     pop.w 0x0860
341:                       }
342:                   	day_counter++;
  1898  EC6997     inc.b 0x0997
343:                   }
  189A  37FFCF     bra 0x00183a
344:               }
  189C  7802CF     mov.w [--0x001e],0x000a
  189E  060000     return
345:               
346:               /*
347:                ******************************************************************************************************
348:                *                                         RTCC_TransitionToSTANDBY()
349:                ******************************************************************************************************
350:                *
351:                * Description : Actions to execute when transitioning from any state to ALARM_STANDBY.
352:                *
353:                * Arguments   : none.
354:                * 
355:                * Caller      : AlarmStateMachine().
356:                *
357:                * Returns     : none.
358:                * 
359:                * Notes       : none.
360:                ******************************************************************************************************
361:                */ 
362:               void RTCC_TransitionToSTANDBY (void)
363:               {
364:                   SetLampIntensity(0.0f);
  18A0  EF298E     clr.w 0x098e
  18A2  EF2990     clr.w 0x0990
  18A4  0217AA     call 0x0017aa
365:                   InitLoadControl();
  18A8  020850     call 0x000850
366:                   setChime(false);
  18AC  EF698E     clr.b 0x098e
  18AE  02153C     call 0x00153c
367:                   FindNextAlarmTime();
  18B2  021830     call 0x001830
368:                   
369:                   alarmData.AlarmState = ALARM_STANDBY;
  18B6  B3C010     mov.b #0x1,0x0000
  18B8  B7E876     mov.b 0x0000,0x0876
370:               }
  18BA  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\RTCC.h  --------------------------
1:                 #ifndef __RTCC__
2:                 #define __RTCC__
3:                 
4:                 #include "customTime.c"
5:                 
6:                 /*
7:                 typedef struct {
8:                 	int tm_sec;
9:                 	int tm_min;
10:                	int tm_hour;
11:                	int tm_mday;
12:                	int tm_mon;
13:                	int tm_year;
14:                	int tm_wday;
15:                	int tm_yday;
16:                	int tm_isdst;
17:                } tm_struct;
18:                
19:                 typedef struct {
20:                	int8    year;
21:                	int8    month;
22:                	int8    day;
23:                	int8	hour;
24:                	int8	minute;
25:                	int8	second;
26:                } date;
27:                */
28:                
29:                #define MM_JAN 1
30:                #define MM_FEB 2
31:                #define MM_MAR 3
32:                #define MM_APR 4
33:                #define MM_MAY 5
34:                #define MM_JUN 6
35:                #define MM_JUL 7
36:                #define MM_AUG 8
37:                #define MM_SEP 9
38:                #define MM_OCT 10
39:                #define MM_NOV 11
40:                #define MM_DEC 12
41:                
42:                #define ALARM_WAKE_TIMEOUT_SEC     60
43:                #define ALARM_MAX_SNOOZE_COUNT      3
44:                #define RTCC_MAX_DAY_LOOKAHEAD      7
45:                #define SEC_IN_A_DAY            86400
46:                #define RTCC_STANDBY_TIMEOUT      180
47:                #define RTCC_PW_TH_MAX (DEFAULT_PULSE_WIDTH_DEFAULT + 10)             
48:                
49:                         int8 ALARM_DAYS[]    = {0,1,1,1,1,1,0};
  2FD4  201004     mov.w #0x100,0x0008
  2FD6  884904     mov.w 0x0008,0x0920
  2FD8  201014     mov.w #0x101,0x0008
  2FDA  884914     mov.w 0x0008,0x0922
  2FDC  201014     mov.w #0x101,0x0008
  2FDE  884924     mov.w 0x0008,0x0924
  2FE0  EF6926     clr.b 0x0926
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\UserInput.c  ---------------------
1:                 #include "includes.h"
2:                  
3:                 int1 ENCA_value = 0;
4:                 int1 ENCB_value = 0;
5:                 int1 PUSH_value = 0;
6:                 
7:                 int1 previous_PUSH = 0;
8:                 int16 contextEnum = WAIT_PHASE_SEL;
9:                 
10:                #int_QEI
11:                void  QEI_isr(void) 
12:                {
  07A6  F80042     push.w 0x0042
  07A8  F80036     push.w 0x0036
  07AA  781F80     mov.w 0x0000,[0x001e++]
  07AC  200020     mov.w #0x2,0x0000
  07AE  09000C     repeat #12
  07B0  781FB0     mov.w [0x0000++],[0x001e++]
13:                
14:                }
15:                 
  07B2  A90089     bclr.b 0x0089,#0
  07B4  2001A0     mov.w #0x1a,0x0000
  07B6  09000C     repeat #12
  07B8  78104F     mov.w [--0x001e],[0x0000--]
  07BA  78004F     mov.w [--0x001e],0x0000
  07BC  F90036     pop.w 0x0036
  07BE  F90042     pop.w 0x0042
  07C0  064000     retfie
16:                void initUserInput()
17:                { 
18:                	setup_qei(QEI_MODE_X4|QEI_TIMER_INTERNAL,QEI_FILTER_DIV_2,0xFFFF);
  0ACC  206004     mov.w #0x600,0x0008
  0ACE  880914     mov.w 0x0008,0x0122
  0AD0  200104     mov.w #0x10,0x0008
  0AD2  880924     mov.w 0x0008,0x0124
  0AD4  EFA128     setm.w 0x0128
  0AD6  EF2126     clr.w 0x0126
19:                
20:                 	enable_interrupts(INT_QEI);
  0AD8  A80091     bset.b 0x0091,#0
21:                 	
22:                }
  0ADA  060000     return
23:                 
24:                void encoderMonitoring()
25:                {
26:                	previous_PUSH = PUSH_value;
  1BEA  A9E966     bclr.b 0x0966,#7
  1BEC  AFC966     btsc.b 0x0966,#6
  1BEE  A8E966     bset.b 0x0966,#7
27:                 	
28:                }
  1BF0  060000     return
29:                
30:                void switchInputContext()
31:                {
32:                	contextEnum = (contextEnum + 1) % SEL_COUNT;
33:                }
34:                
35:                void addSelector()
36:                {
37:                	switch(contextEnum)
38:                	{
  1D3C  804BD0     mov.w 0x097a,0x0000
  1D3E  B28000     xor.w #0x0,0x0000
  1D40  320003     bra z, 0x001d48
  1D42  B28010     xor.w #0x1,0x0000
  1D44  320004     bra z, 0x001d4e
  1D46  370006     bra 0x001d54
39:                		case WAIT_PHASE_SEL:
40:                			LCD_Line1[15] = 0x1E;
  1D48  B3C1E0     mov.b #0x1e,0x0000
  1D4A  B7E8CF     mov.b 0x0000,0x08cf
41:                			break;
  1D4C  370003     bra 0x001d54
42:                		case WAIT_PULSE_SEL:
43:                			LCD_Line2[15] = 0x1E; 
  1D4E  B3C1E0     mov.b #0x1e,0x0000
  1D50  B7E8DF     mov.b 0x0000,0x08df
44:                			break;
  1D52  370000     bra 0x001d54
45:                	}
46:                }
  1D54  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\customTime.c  --------------------
1:                 // this structure is just the local version of Visual C tm_structure in time.h
2:                 
3:                 typedef struct 
4:                 {
5:                 	int tm_sec;		/* seconds after the minute - [0,59]   */
6:                 	int tm_min;		/* minutes after the hour   - [0,59]   */
7:                 	int tm_hour;	/* hours since midnight     - [0,23]   */
8:                 	int tm_mday;	/* day of the month         - [1,31]   */
9:                 	int tm_mon;		/* months since January     - [0,11]   */
10:                	int tm_year;	/* years since 1900					   */
11:                	int tm_wday;	/* days since Sunday         - [0,6]   */
12:                	int tm_yday;	/* days since January 1      - [0,365] */
13:                	int tm_isdst;	/* daylight savings time flag NOT USED */
14:                } tm_struct;
15:                
16:                unsigned long DaysToMonth[13] = {0,31,59,90,120,151,181,212,243,273,304,334,365};
  2F88  EF28EC     clr.w 0x08ec
  2F8A  EF28EE     clr.w 0x08ee
  2F8C  2001F4     mov.w #0x1f,0x0008
  2F8E  884784     mov.w 0x0008,0x08f0
  2F90  EF28F2     clr.w 0x08f2
  2F92  2003B4     mov.w #0x3b,0x0008
  2F94  8847A4     mov.w 0x0008,0x08f4
  2F96  EF28F6     clr.w 0x08f6
  2F98  2005A4     mov.w #0x5a,0x0008
  2F9A  8847C4     mov.w 0x0008,0x08f8
  2F9C  EF28FA     clr.w 0x08fa
  2F9E  200784     mov.w #0x78,0x0008
  2FA0  8847E4     mov.w 0x0008,0x08fc
  2FA2  EF28FE     clr.w 0x08fe
  2FA4  200974     mov.w #0x97,0x0008
  2FA6  884804     mov.w 0x0008,0x0900
  2FA8  EF2902     clr.w 0x0902
  2FAA  200B54     mov.w #0xb5,0x0008
  2FAC  884824     mov.w 0x0008,0x0904
  2FAE  EF2906     clr.w 0x0906
  2FB0  200D44     mov.w #0xd4,0x0008
  2FB2  884844     mov.w 0x0008,0x0908
  2FB4  EF290A     clr.w 0x090a
  2FB6  200F34     mov.w #0xf3,0x0008
  2FB8  884864     mov.w 0x0008,0x090c
  2FBA  EF290E     clr.w 0x090e
  2FBC  201114     mov.w #0x111,0x0008
  2FBE  884884     mov.w 0x0008,0x0910
  2FC0  EF2912     clr.w 0x0912
  2FC2  201304     mov.w #0x130,0x0008
  2FC4  8848A4     mov.w 0x0008,0x0914
  2FC6  EF2916     clr.w 0x0916
  2FC8  2014E4     mov.w #0x14e,0x0008
  2FCA  8848C4     mov.w 0x0008,0x0918
  2FCC  EF291A     clr.w 0x091a
  2FCE  2016D4     mov.w #0x16d,0x0008
  2FD0  8848E4     mov.w 0x0008,0x091c
  2FD2  EF291E     clr.w 0x091e
17:                
18:                unsigned long DS1371_DateToBinary(tm_struct *datetime)
19:                {
  091E  781F85     mov.w 0x000a,[0x001e++]
  0920  781F86     mov.w 0x000c,[0x001e++]
  0922  781F87     mov.w 0x000e,[0x001e++]
  0924  781F88     mov.w 0x0010,[0x001e++]
20:                	unsigned long iday;
21:                	unsigned long val;
22:                	
23:                	iday = 365 * (datetime->tm_year - 70) + DaysToMonth[datetime->tm_mon-1] + (datetime->tm_mday - 1);
  0926  2000A0     mov.w #0xa,0x0000
  0928  B4099C     add.w 0x099c,0x0000
  092A  780290     mov.w [0x0000],0x000a
  092C  200464     mov.w #0x46,0x0008
  092E  528004     sub.w 0x000a,0x0008,0x0000
  0930  2016D4     mov.w #0x16d,0x0008
  0932  B9A000     mul.ss 0x0008,0x0000,0x0000
  0934  780280     mov.w 0x0000,0x000a
  0936  200080     mov.w #0x8,0x0000
  0938  B4099C     add.w 0x099c,0x0000
  093A  780310     mov.w [0x0000],0x000c
  093C  530361     sub.w 0x000c,#1,0x000c
  093E  780206     mov.w 0x000c,0x0008
  0940  B82064     mul.uu 0x0008,#4,0x0000
  0942  208EC4     mov.w #0x8ec,0x0008
  0944  400004     add.w 0x0000,0x0008,0x0000
  0946  780200     mov.w 0x0000,0x0008
  0948  200003     mov.w #0x0,0x0006
  094A  7819B4     mov.w [0x0008++],[0x0006++]
  094C  7819B4     mov.w [0x0008++],[0x0006++]
  094E  400285     add.w 0x0000,0x000a,0x000a
  0950  4880E0     addc.w 0x0002,#0,0x0002
  0952  780301     mov.w 0x0002,0x000c
  0954  200060     mov.w #0x6,0x0000
  0956  B4099C     add.w 0x099c,0x0000
  0958  780390     mov.w [0x0000],0x000e
  095A  538061     sub.w 0x000e,#1,0x0000
  095C  EB0080     clr.w 0x0002
  095E  A7F000     btsc 0x0000,#15
  0960  EB8080     setm.w 0x0002
  0962  400005     add.w 0x0000,0x000a,0x0000
  0964  884CF0     mov.w 0x0000,0x099e
  0966  488006     addc.w 0x0002,0x000c,0x0000
  0968  884D00     mov.w 0x0000,0x09a0
24:                	iday = iday + (datetime->tm_year - 69) / 4;
  096A  2000A0     mov.w #0xa,0x0000
  096C  B4099C     add.w 0x099c,0x0000
  096E  780290     mov.w [0x0000],0x000a
  0970  B10455     sub.w 0x000a,#0x45
  0972  780205     mov.w 0x000a,0x0008
  0974  200043     mov.w #0x4,0x0006
  0976  090011     repeat #17
  0978  D80203     div.sw 0x0008,0x0006
  097A  EB0080     clr.w 0x0002
  097C  A7F000     btsc 0x0000,#15
  097E  EB8080     setm.w 0x0002
  0980  B4299E     add.w 0x099e
  0982  780001     mov.w 0x0002,0x0000
  0984  B489A0     addc.w 0x09a0,0x0000
  0986  884D00     mov.w 0x0000,0x09a0
25:                	if ((datetime->tm_mon > 2) && ((datetime->tm_year % 4) == 0)) {
  0988  200080     mov.w #0x8,0x0000
  098A  B4099C     add.w 0x099c,0x0000
  098C  780290     mov.w [0x0000],0x000a
  098E  E12862     cp.w 0x000a,#2
  0990  34000D     bra les, 0x0009ac
  0992  2000A0     mov.w #0xa,0x0000
  0994  B4099C     add.w 0x099c,0x0000
  0996  780290     mov.w [0x0000],0x000a
  0998  780205     mov.w 0x000a,0x0008
  099A  200043     mov.w #0x4,0x0006
  099C  090011     repeat #17
  099E  D80203     div.sw 0x0008,0x0006
  09A0  780281     mov.w 0x0002,0x000a
  09A2  E00005     cp0.w 0x000a
  09A4  3A0003     bra nz, 0x0009ac
26:                		iday++;
  09A6  EC299E     inc.w 0x099e
  09A8  AF2042     btsc.b 0x0042,#1
  09AA  EC29A0     inc.w 0x09a0
27:                	}
28:                	val = datetime->tm_sec + 60 * datetime->tm_min + 3600 * (datetime->tm_hour + 24 * iday);
  09AC  200000     mov.w #0x0,0x0000
  09AE  B4099C     add.w 0x099c,0x0000
  09B0  780290     mov.w [0x0000],0x000a
  09B2  200020     mov.w #0x2,0x0000
  09B4  B4099C     add.w 0x099c,0x0000
  09B6  780200     mov.w 0x0000,0x0008
  09B8  780014     mov.w [0x0008],0x0000
  09BA  2003C4     mov.w #0x3c,0x0008
  09BC  B9A000     mul.ss 0x0008,0x0000,0x0000
  09BE  400285     add.w 0x0000,0x000a,0x000a
  09C0  200040     mov.w #0x4,0x0000
  09C2  B4099C     add.w 0x099c,0x0000
  09C4  780310     mov.w [0x0000],0x000c
  09C6  EB0380     clr.w 0x000e
  09C8  A7F006     btsc 0x000c,#15
  09CA  EB8380     setm.w 0x000e
  09CC  F80042     push.w 0x0042
  09CE  EFE042     setm.b 0x0042
  09D0  200180     mov.w #0x18,0x0000
  09D2  200001     mov.w #0x0,0x0002
  09D4  804CF2     mov.w 0x099e,0x0004
  09D6  804D03     mov.w 0x09a0,0x0006
  09D8  02050A     call 0x00050a
  09DC  F90042     pop.w 0x0042
  09DE  400006     add.w 0x0000,0x000c,0x0000
  09E0  488087     addc.w 0x0002,0x000e,0x0002
  09E2  780100     mov.w 0x0000,0x0004
  09E4  780181     mov.w 0x0002,0x0006
  09E6  20E100     mov.w #0xe10,0x0000
  09E8  200001     mov.w #0x0,0x0002
  09EA  0208DC     call 0x0008dc
  09EE  400005     add.w 0x0000,0x000a,0x0000
  09F0  884D10     mov.w 0x0000,0x09a2
  09F2  4880E0     addc.w 0x0002,#0,0x0002
  09F4  884D21     mov.w 0x0002,0x09a4
29:                	return val;
  09F6  804D10     mov.w 0x09a2,0x0000
  09F8  804D21     mov.w 0x09a4,0x0002
30:                }
  09FA  78044F     mov.w [--0x001e],0x0010
  09FC  7803CF     mov.w [--0x001e],0x000e
  09FE  78034F     mov.w [--0x001e],0x000c
  0A00  7802CF     mov.w [--0x001e],0x000a
  0A02  060000     return
31:                
32:                void DS1371_BinaryToDate(unsigned long binary,tm_struct *datetime)
33:                {
  053A  781F85     mov.w 0x000a,[0x001e++]
  053C  781F86     mov.w 0x000c,[0x001e++]
34:                	unsigned long hour;
35:                	unsigned long day;
36:                	unsigned long minute;
37:                	unsigned long second;
38:                	unsigned long month;
39:                	unsigned long year;
40:                	unsigned long whole_minutes;
41:                	unsigned long whole_hours;
42:                	unsigned long whole_days;
43:                	unsigned long whole_days_since_1968;
44:                	unsigned long leap_year_periods;
45:                	unsigned long days_since_current_lyear;
46:                	unsigned long whole_years;
47:                	unsigned long days_since_first_of_year;
48:                	unsigned long days_to_month;
49:                	unsigned long day_of_week;
50:                	
51:                	whole_minutes = binary / 60;
  053E  A90043     bclr.b 0x0043,#0
  0540  805280     mov.w 0x0a50,0x0000
  0542  805291     mov.w 0x0a52,0x0002
  0544  2003C2     mov.w #0x3c,0x0004
  0546  200003     mov.w #0x0,0x0006
  0548  0204B6     call 0x0004b6
  054C  885370     mov.w 0x0000,0x0a6e
  054E  885381     mov.w 0x0002,0x0a70
52:                	second = binary - (60 * whole_minutes);			// leftover seconds
  0550  2003C0     mov.w #0x3c,0x0000
  0552  200001     mov.w #0x0,0x0002
  0554  805372     mov.w 0x0a6e,0x0004
  0556  805383     mov.w 0x0a70,0x0006
  0558  02050A     call 0x00050a
  055C  805284     mov.w 0x0a50,0x0008
  055E  520000     sub.w 0x0008,0x0000,0x0000
  0560  885310     mov.w 0x0000,0x0a62
  0562  805294     mov.w 0x0a52,0x0008
  0564  5A0001     subb.w 0x0008,0x0002,0x0000
  0566  885320     mov.w 0x0000,0x0a64
53:                	whole_hours = whole_minutes / 60;
  0568  A90043     bclr.b 0x0043,#0
  056A  805370     mov.w 0x0a6e,0x0000
  056C  805381     mov.w 0x0a70,0x0002
  056E  2003C2     mov.w #0x3c,0x0004
  0570  200003     mov.w #0x0,0x0006
  0572  0204B6     call 0x0004b6
  0576  885390     mov.w 0x0000,0x0a72
  0578  8853A1     mov.w 0x0002,0x0a74
54:                	minute = whole_minutes - (60 * whole_hours);	// leftover minutes
  057A  2003C0     mov.w #0x3c,0x0000
  057C  200001     mov.w #0x0,0x0002
  057E  805392     mov.w 0x0a72,0x0004
  0580  8053A3     mov.w 0x0a74,0x0006
  0582  02050A     call 0x00050a
  0586  805374     mov.w 0x0a6e,0x0008
  0588  520000     sub.w 0x0008,0x0000,0x0000
  058A  8852F0     mov.w 0x0000,0x0a5e
  058C  805384     mov.w 0x0a70,0x0008
  058E  5A0001     subb.w 0x0008,0x0002,0x0000
  0590  885300     mov.w 0x0000,0x0a60
55:                	whole_days	= whole_hours / 24;
  0592  A90043     bclr.b 0x0043,#0
  0594  805390     mov.w 0x0a72,0x0000
  0596  8053A1     mov.w 0x0a74,0x0002
  0598  200182     mov.w #0x18,0x0004
  059A  200003     mov.w #0x0,0x0006
  059C  0204B6     call 0x0004b6
  05A0  8853B0     mov.w 0x0000,0x0a76
  05A2  8853C1     mov.w 0x0002,0x0a78
56:                	hour	= whole_hours - (24 * whole_days);		// leftover hours
  05A4  200180     mov.w #0x18,0x0000
  05A6  200001     mov.w #0x0,0x0002
  05A8  8053B2     mov.w 0x0a76,0x0004
  05AA  8053C3     mov.w 0x0a78,0x0006
  05AC  02050A     call 0x00050a
  05B0  805394     mov.w 0x0a72,0x0008
  05B2  520000     sub.w 0x0008,0x0000,0x0000
  05B4  8852B0     mov.w 0x0000,0x0a56
  05B6  8053A4     mov.w 0x0a74,0x0008
  05B8  5A0001     subb.w 0x0008,0x0002,0x0000
  05BA  8852C0     mov.w 0x0000,0x0a58
57:                	
58:                	  
59:                	whole_days_since_1968 = whole_days + 365 + 366; 
  05BC  2016D4     mov.w #0x16d,0x0008
  05BE  8053B3     mov.w 0x0a76,0x0006
  05C0  418284     add.w 0x0006,0x0008,0x000a
  05C2  8053C4     mov.w 0x0a78,0x0008
  05C4  4A0260     addc.w 0x0008,#0,0x0008
  05C6  780304     mov.w 0x0008,0x000c
  05C8  2016E4     mov.w #0x16e,0x0008
  05CA  428004     add.w 0x000a,0x0008,0x0000
  05CC  8853D0     mov.w 0x0000,0x0a7a
  05CE  4B0360     addc.w 0x000c,#0,0x000c
  05D0  8853E6     mov.w 0x000c,0x0a7c
60:                	leap_year_periods = whole_days_since_1968 / ((4 * 365) + 1);	
  05D2  A90043     bclr.b 0x0043,#0
  05D4  8053D0     mov.w 0x0a7a,0x0000
  05D6  8053E1     mov.w 0x0a7c,0x0002
  05D8  205B52     mov.w #0x5b5,0x0004
  05DA  200003     mov.w #0x0,0x0006
  05DC  0204B6     call 0x0004b6
  05E0  8853F0     mov.w 0x0000,0x0a7e
  05E2  885401     mov.w 0x0002,0x0a80
61:                	days_since_current_lyear = whole_days_since_1968 % ((4 * 365) + 1);
  05E4  A80043     bset.b 0x0043,#0
  05E6  8053D0     mov.w 0x0a7a,0x0000
  05E8  8053E1     mov.w 0x0a7c,0x0002
  05EA  205B52     mov.w #0x5b5,0x0004
  05EC  200003     mov.w #0x0,0x0006
  05EE  0204B6     call 0x0004b6
  05F2  885410     mov.w 0x0000,0x0a82
  05F4  885421     mov.w 0x0002,0x0a84
62:                	
63:                	// if days are after a current leap year then add a leap year period
64:                	if ((days_since_current_lyear >= (31 + 29)))
  05F6  805424     mov.w 0x0a84,0x0008
  05F8  E12060     cp.w 0x0008,#0
  05FA  390008     bra nc, 0x00060c
  05FC  3E0004     bra gtu, 0x000606
  05FE  805414     mov.w 0x0a82,0x0008
  0600  2003C3     mov.w #0x3c,0x0006
  0602  E11804     cp.w 0x0006,0x0008
  0604  3E0003     bra gtu, 0x00060c
65:                	{
66:                		leap_year_periods++;
  0606  EC2A7E     inc.w 0x0a7e
  0608  AF2042     btsc.b 0x0042,#1
  060A  EC2A80     inc.w 0x0a80
67:                	} 
68:                	
69:                	whole_years = (whole_days_since_1968 - leap_year_periods) / 365;
  060C  8053D4     mov.w 0x0a7a,0x0008
  060E  8053F3     mov.w 0x0a7e,0x0006
  0610  520283     sub.w 0x0008,0x0006,0x000a
  0612  8053E4     mov.w 0x0a7c,0x0008
  0614  805403     mov.w 0x0a80,0x0006
  0616  5A0303     subb.w 0x0008,0x0006,0x000c
  0618  A90043     bclr.b 0x0043,#0
  061A  780005     mov.w 0x000a,0x0000
  061C  780086     mov.w 0x000c,0x0002
  061E  2016D2     mov.w #0x16d,0x0004
  0620  200003     mov.w #0x0,0x0006
  0622  0204B6     call 0x0004b6
  0626  885430     mov.w 0x0000,0x0a86
  0628  885441     mov.w 0x0002,0x0a88
70:                	days_since_first_of_year = whole_days_since_1968 - (whole_years * 365) - leap_year_periods;
  062A  805430     mov.w 0x0a86,0x0000
  062C  805441     mov.w 0x0a88,0x0002
  062E  2016D2     mov.w #0x16d,0x0004
  0630  200003     mov.w #0x0,0x0006
  0632  02050A     call 0x00050a
  0636  8053D4     mov.w 0x0a7a,0x0008
  0638  520280     sub.w 0x0008,0x0000,0x000a
  063A  8053E4     mov.w 0x0a7c,0x0008
  063C  5A0301     subb.w 0x0008,0x0002,0x000c
  063E  8053F4     mov.w 0x0a7e,0x0008
  0640  528004     sub.w 0x000a,0x0008,0x0000
  0642  885450     mov.w 0x0000,0x0a8a
  0644  805404     mov.w 0x0a80,0x0008
  0646  5B0004     subb.w 0x000c,0x0008,0x0000
  0648  885460     mov.w 0x0000,0x0a8c
71:                
72:                	if ((days_since_current_lyear <= 365) && (days_since_current_lyear >= 60))
  064A  805424     mov.w 0x0a84,0x0008
  064C  E12060     cp.w 0x0008,#0
  064E  3E0010     bra gtu, 0x000670
  0650  390004     bra nc, 0x00065a
  0652  805414     mov.w 0x0a82,0x0008
  0654  2016D3     mov.w #0x16d,0x0006
  0656  E11804     cp.w 0x0006,0x0008
  0658  39000B     bra nc, 0x000670
  065A  805424     mov.w 0x0a84,0x0008
  065C  E12060     cp.w 0x0008,#0
  065E  390008     bra nc, 0x000670
  0660  3E0004     bra gtu, 0x00066a
  0662  805414     mov.w 0x0a82,0x0008
  0664  2003C3     mov.w #0x3c,0x0006
  0666  E11804     cp.w 0x0006,0x0008
  0668  3E0003     bra gtu, 0x000670
73:                	{
74:                		days_since_first_of_year++;
  066A  EC2A8A     inc.w 0x0a8a
  066C  AF2042     btsc.b 0x0042,#1
  066E  EC2A8C     inc.w 0x0a8c
75:                	}
76:                	
77:                	year = whole_years + 68;
  0670  200444     mov.w #0x44,0x0008
  0672  805433     mov.w 0x0a86,0x0006
  0674  418004     add.w 0x0006,0x0008,0x0000
  0676  885350     mov.w 0x0000,0x0a6a
  0678  805444     mov.w 0x0a88,0x0008
  067A  4A0260     addc.w 0x0008,#0,0x0008
  067C  885364     mov.w 0x0008,0x0a6c
78:                
79:                	// setup for a search for what month it is based on how many days have past
80:                	//	within the current year
81:                	month = 13;
  067E  2000D4     mov.w #0xd,0x0008
  0680  885334     mov.w 0x0008,0x0a66
  0682  EF2A68     clr.w 0x0a68
82:                	days_to_month = 366;
  0684  2016E4     mov.w #0x16e,0x0008
  0686  885474     mov.w 0x0008,0x0a8e
  0688  EF2A90     clr.w 0x0a90
83:                	
84:                	while (days_since_first_of_year < days_to_month)
85:                	{
  068A  805460     mov.w 0x0a8c,0x0000
  068C  805484     mov.w 0x0a90,0x0008
  068E  E12000     cp.w 0x0008,0x0000
  0690  390046     bra nc, 0x00071e
  0692  3E0004     bra gtu, 0x00069c
  0694  805450     mov.w 0x0a8a,0x0000
  0696  805474     mov.w 0x0a8e,0x0008
  0698  E12000     cp.w 0x0008,0x0000
  069A  360041     bra leu, 0x00071e
86:                		month--;
  069C  ED2A66     dec.w 0x0a66
  069E  AE0042     btss.b 0x0042,#0
  06A0  ED2A68     dec.w 0x0a68
87:                		days_to_month = DaysToMonth[month-1];
  06A2  805334     mov.w 0x0a66,0x0008
  06A4  5202E1     sub.w 0x0008,#1,0x000a
  06A6  805344     mov.w 0x0a68,0x0008
  06A8  5A0360     subb.w 0x0008,#0,0x000c
  06AA  200024     mov.w #0x2,0x0008
  06AC  EF6009     clr.b 0x0009
  06AE  780005     mov.w 0x000a,0x0000
  06B0  780086     mov.w 0x000c,0x0002
  06B2  E80204     inc.w 0x0008,0x0008
  06B4  E90204     dec.w 0x0008,0x0008
  06B6  320003     bra z, 0x0006be
  06B8  D00000     sl.w 0x0000,0x0000
  06BA  D28081     rlc.w 0x0002,0x0002
  06BC  37FFFB     bra 0x0006b4
  06BE  208EC4     mov.w #0x8ec,0x0008
  06C0  400004     add.w 0x0000,0x0008,0x0000
  06C2  20A8E4     mov.w #0xa8e,0x0008
  06C4  781A30     mov.w [0x0000++],[0x0008++]
  06C6  781A30     mov.w [0x0000++],[0x0008++]
88:                		if ((month > 2) && ((year % 4) == 0))
  06C8  805344     mov.w 0x0a68,0x0008
  06CA  E12060     cp.w 0x0008,#0
  06CC  39000E     bra nc, 0x0006ea
  06CE  3E0003     bra gtu, 0x0006d6
  06D0  805334     mov.w 0x0a66,0x0008
  06D2  E12062     cp.w 0x0008,#2
  06D4  36000A     bra leu, 0x0006ea
  06D6  805350     mov.w 0x0a6a,0x0000
  06D8  6002E3     and.w 0x0000,#3,0x000a
  06DA  EB0300     clr.w 0x000c
  06DC  E00005     cp0.w 0x000a
  06DE  3A0005     bra nz, 0x0006ea
  06E0  E00006     cp0.w 0x000c
  06E2  3A0003     bra nz, 0x0006ea
89:                		{
90:                			days_to_month++;
  06E4  EC2A8E     inc.w 0x0a8e
  06E6  AF2042     btsc.b 0x0042,#1
  06E8  EC2A90     inc.w 0x0a90
91:                		}
92:                		
93:                		day = days_since_first_of_year - days_to_month + 1;
  06EA  805454     mov.w 0x0a8a,0x0008
  06EC  805473     mov.w 0x0a8e,0x0006
  06EE  520283     sub.w 0x0008,0x0006,0x000a
  06F0  805464     mov.w 0x0a8c,0x0008
  06F2  805483     mov.w 0x0a90,0x0006
  06F4  5A0303     subb.w 0x0008,0x0006,0x000c
  06F6  4282E1     add.w 0x000a,#1,0x000a
  06F8  8852D5     mov.w 0x000a,0x0a5a
  06FA  4B0360     addc.w 0x000c,#0,0x000c
  06FC  8852E6     mov.w 0x000c,0x0a5c
94:                		day_of_week = (whole_days + 4) % 7;
  06FE  8053B4     mov.w 0x0a76,0x0008
  0700  420264     add.w 0x0008,#4,0x0008
  0702  780284     mov.w 0x0008,0x000a
  0704  8053C4     mov.w 0x0a78,0x0008
  0706  4A0260     addc.w 0x0008,#0,0x0008
  0708  780304     mov.w 0x0008,0x000c
  070A  A80043     bset.b 0x0043,#0
  070C  780005     mov.w 0x000a,0x0000
  070E  780086     mov.w 0x000c,0x0002
  0710  200072     mov.w #0x7,0x0004
  0712  200003     mov.w #0x0,0x0006
  0714  0204B6     call 0x0004b6
  0718  885490     mov.w 0x0000,0x0a92
  071A  8854A1     mov.w 0x0002,0x0a94
95:                	}
  071C  37FFB6     bra 0x00068a
96:                	
97:                	datetime->tm_yday = days_since_first_of_year;	/* days since January 1 - [0,365]	*/
  071E  2000E0     mov.w #0xe,0x0000
  0720  B40A54     add.w 0x0a54,0x0000
  0722  780280     mov.w 0x0000,0x000a
  0724  805454     mov.w 0x0a8a,0x0008
  0726  980284     mov.w 0x0008,[0x000a+0]
98:                	datetime->tm_sec = second;						/* seconds after the minute - [0,59]	*/
  0728  200000     mov.w #0x0,0x0000
  072A  B40A54     add.w 0x0a54,0x0000
  072C  780280     mov.w 0x0000,0x000a
  072E  805314     mov.w 0x0a62,0x0008
  0730  980284     mov.w 0x0008,[0x000a+0]
99:                	datetime->tm_min = minute;						/* minutes after the hour - [0,59]	*/
  0732  200020     mov.w #0x2,0x0000
  0734  B40A54     add.w 0x0a54,0x0000
  0736  780280     mov.w 0x0000,0x000a
  0738  8052F4     mov.w 0x0a5e,0x0008
  073A  980284     mov.w 0x0008,[0x000a+0]
100:               	datetime->tm_hour = hour;						/* hours since midnight - [0,23]	*/
  073C  200040     mov.w #0x4,0x0000
  073E  B40A54     add.w 0x0a54,0x0000
  0740  780280     mov.w 0x0000,0x000a
  0742  8052B4     mov.w 0x0a56,0x0008
  0744  980284     mov.w 0x0008,[0x000a+0]
101:               	datetime->tm_mday = day;						/* day of the month - [1,31]	*/
  0746  200060     mov.w #0x6,0x0000
  0748  B40A54     add.w 0x0a54,0x0000
  074A  780280     mov.w 0x0000,0x000a
  074C  8052D4     mov.w 0x0a5a,0x0008
  074E  980284     mov.w 0x0008,[0x000a+0]
102:               	datetime->tm_wday = day_of_week;				/* days since Sunday - [0,6]	*/
  0750  2000C0     mov.w #0xc,0x0000
  0752  B40A54     add.w 0x0a54,0x0000
  0754  780280     mov.w 0x0000,0x000a
  0756  805494     mov.w 0x0a92,0x0008
  0758  980284     mov.w 0x0008,[0x000a+0]
103:               	datetime->tm_mon = month;						/* months since January - [0,11]	*/
  075A  200080     mov.w #0x8,0x0000
  075C  B40A54     add.w 0x0a54,0x0000
  075E  780280     mov.w 0x0000,0x000a
  0760  805334     mov.w 0x0a66,0x0008
  0762  980284     mov.w 0x0008,[0x000a+0]
104:               	datetime->tm_year = year;						/* years since 1900	*/
  0764  2000A0     mov.w #0xa,0x0000
  0766  B40A54     add.w 0x0a54,0x0000
  0768  780280     mov.w 0x0000,0x000a
  076A  805354     mov.w 0x0a6a,0x0008
  076C  980284     mov.w 0x0008,[0x000a+0]
105:               }
  076E  78034F     mov.w [--0x001e],0x000c
  0770  7802CF     mov.w [--0x001e],0x000a
  0772  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\includes.h  ----------------------
1:                 #ifndef __INCLUDES__
2:                 #define __INCLUDES__
  12A8  780280     mov.w 0x0000,0x000a
  12AA  780301     mov.w 0x0002,0x000c
  12AC  780005     mov.w 0x000a,0x0000
  12AE  780086     mov.w 0x000c,0x0002
  12B0  201002     mov.w #0x100,0x0004
  12B2  2477E3     mov.w #0x477e,0x0006
  12B4  020C78     call 0x000c78
  12C8  780280     mov.w 0x0000,0x000a
  12CA  780301     mov.w 0x0002,0x000c
  12CC  780005     mov.w 0x000a,0x0000
  12CE  780086     mov.w 0x000c,0x0002
  12D0  200002     mov.w #0x0,0x0004
  12D2  242703     mov.w #0x4270,0x0006
  12D4  020C78     call 0x000c78
  12EE  780280     mov.w 0x0000,0x000a
  12F0  780301     mov.w 0x0002,0x000c
  12F2  A80043     bset.b 0x0043,#0
  12F4  780005     mov.w 0x000a,0x0000
  12F6  780086     mov.w 0x000c,0x0002
  12F8  200002     mov.w #0x0,0x0004
  12FA  23F803     mov.w #0x3f80,0x0006
  12FC  020E20     call 0x000e20
  1300  780280     mov.w 0x0000,0x000a
  1302  780301     mov.w 0x0002,0x000c
  13F4  780280     mov.w 0x0000,0x000a
  13F6  780301     mov.w 0x0002,0x000c
  13F8  780005     mov.w 0x000a,0x0000
  13FA  780086     mov.w 0x000c,0x0002
  13FC  200002     mov.w #0x0,0x0004
  13FE  2437F3     mov.w #0x437f,0x0006
  1400  020C78     call 0x000c78
  1404  780280     mov.w 0x0000,0x000a
  1406  780301     mov.w 0x0002,0x000c
  1408  A80043     bset.b 0x0043,#0
  140A  780005     mov.w 0x000a,0x0000
  140C  780086     mov.w 0x000c,0x0002
  140E  804D92     mov.w 0x09b2,0x0004
  1410  804DA3     mov.w 0x09b4,0x0006
  1412  020E20     call 0x000e20
  17B6  780280     mov.w 0x0000,0x000a
  17B8  780301     mov.w 0x0002,0x000c
  17BA  780005     mov.w 0x000a,0x0000
  17BC  780086     mov.w 0x000c,0x0002
  17BE  804C72     mov.w 0x098e,0x0004
  17C0  804C83     mov.w 0x0990,0x0006
  17C2  020FC0     call 0x000fc0
  17C6  780280     mov.w 0x0000,0x000a
  17C8  780301     mov.w 0x0002,0x000c
  17CA  780005     mov.w 0x000a,0x0000
  17CC  780086     mov.w 0x000c,0x0002
  17CE  200002     mov.w #0x0,0x0004
  17D0  242C83     mov.w #0x42c8,0x0006
  17D2  020C78     call 0x000c78
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\main.c  --------------------------
1:                 #include "includes.h"
  0000  042E96     goto 0x002e96
  0006  000834     nop
  0008  000816     nop
  000A  000834     nop
  000C  000834     nop
  000E  000834     nop
  0010  000834     nop
  0012  000834     nop
  0014  000834     nop
  0016  000834     nop
  0018  000834     nop
  001A  000774     nop
  001C  000834     nop
  001E  000834     nop
  0020  000834     nop
  0022  000470     nop
  0024  000834     nop
  0026  0007C2     nop
  0028  0007DE     nop
  002A  0007FA     nop
  002C  000834     nop
  002E  000834     nop
  0030  000834     nop
  0032  00031E     nop
  0034  000834     nop
  0036  000834     nop
  0038  000834     nop
  003A  000834     nop
  003C  000834     nop
  003E  0003FC     nop
  0040  0002B8     nop
  0042  000834     nop
  0044  000834     nop
  0046  000834     nop
  0048  000834     nop
  004A  000834     nop
  004C  000834     nop
  004E  000834     nop
  0050  000834     nop
  0052  000834     nop
  0054  000834     nop
  0056  000834     nop
  0058  000834     nop
  005A  000834     nop
  005C  000834     nop
  005E  000834     nop
  0060  000834     nop
  0062  000834     nop
  0064  0007A6     nop
  0066  000834     nop
  0068  000834     nop
  006A  000834     nop
  006C  000834     nop
  006E  000834     nop
  0070  000834     nop
  0072  000834     nop
  0074  000834     nop
  0076  000834     nop
  0078  000834     nop
  007A  000834     nop
  007C  000834     nop
  007E  000834     nop
2:                 
3:                 //#include "i2c.c"
4:                 #include "uart.c"
5:                 #include "RBGLighting.c"
6:                 #include "LumMonitor.c"
7:                 #include "LoadControl.c"
8:                 #include "LCDDriver.c"
9:                 #include "Chime.c"
10:                #include "RTCC.c"
11:                #include "UserInput.c"
12:                #include "EEPROM.c"
13:                #include "Menu.c"
14:                
15:                #define ENABLE_LCD_REFRESH 1
16:                
17:                
18:                #int_RDA
19:                void  RDA_isr(void) 
20:                {
  07C2  F80042     push.w 0x0042
  07C4  F80036     push.w 0x0036
  07C6  781F80     mov.w 0x0000,[0x001e++]
  07C8  200020     mov.w #0x2,0x0000
  07CA  09000C     repeat #12
  07CC  781FB0     mov.w [0x0000++],[0x001e++]
21:                	//while(1){;}
22:                }
23:                
  07CE  A92085     bclr.b 0x0085,#1
  07D0  2001A0     mov.w #0x1a,0x0000
  07D2  09000C     repeat #12
  07D4  78104F     mov.w [--0x001e],[0x0000--]
  07D6  78004F     mov.w [--0x001e],0x0000
  07D8  F90036     pop.w 0x0036
  07DA  F90042     pop.w 0x0042
  07DC  064000     retfie
24:                #int_TBE
25:                void  TBE_isr(void) 
26:                {
  07DE  A94085     bclr.b 0x0085,#2
  07E0  F80042     push.w 0x0042
  07E2  F80036     push.w 0x0036
  07E4  781F80     mov.w 0x0000,[0x001e++]
  07E6  200020     mov.w #0x2,0x0000
  07E8  09000C     repeat #12
  07EA  781FB0     mov.w [0x0000++],[0x001e++]
27:                	//while(1){;}
28:                }
29:                
  07EC  2001A0     mov.w #0x1a,0x0000
  07EE  09000C     repeat #12
  07F0  78104F     mov.w [--0x001e],[0x0000--]
  07F2  78004F     mov.w [--0x001e],0x0000
  07F4  F90036     pop.w 0x0036
  07F6  F90042     pop.w 0x0042
  07F8  064000     retfie
30:                #int_ADC1
31:                void  ADC1_isr(void) 
32:                {
  07FA  F80042     push.w 0x0042
  07FC  F80036     push.w 0x0036
  07FE  781F80     mov.w 0x0000,[0x001e++]
  0800  200020     mov.w #0x2,0x0000
  0802  09000C     repeat #12
  0804  781FB0     mov.w [0x0000++],[0x001e++]
33:                	//while(1){;}
34:                }
35:                
  0806  A96085     bclr.b 0x0085,#3
  0808  2001A0     mov.w #0x1a,0x0000
  080A  09000C     repeat #12
  080C  78104F     mov.w [--0x001e],[0x0000--]
  080E  78004F     mov.w [--0x001e],0x0000
  0810  F90036     pop.w 0x0036
  0812  F90042     pop.w 0x0042
  0814  064000     retfie
36:                #int_ADDRERR
37:                void  ADDRERR_isr(void) 
38:                {
  0816  F80042     push.w 0x0042
  0818  F80036     push.w 0x0036
  081A  781F80     mov.w 0x0000,[0x001e++]
  081C  200020     mov.w #0x2,0x0000
  081E  09000C     repeat #12
  0820  781FB0     mov.w [0x0000++],[0x001e++]
39:                    ADDRERR = 0;
  0822  A96080     bclr.b 0x0080,#3
40:                }
41:                
  0824  A96080     bclr.b 0x0080,#3
  0826  2001A0     mov.w #0x1a,0x0000
  0828  09000C     repeat #12
  082A  78104F     mov.w [--0x001e],[0x0000--]
  082C  78004F     mov.w [--0x001e],0x0000
  082E  F90036     pop.w 0x0036
  0830  F90042     pop.w 0x0042
  0832  064000     retfie
42:                #int_default
43:                void default_isr()
44:                {
  0834  F80042     push.w 0x0042
  0836  F80036     push.w 0x0036
  0838  781F80     mov.w 0x0000,[0x001e++]
  083A  200020     mov.w #0x2,0x0000
  083C  09000C     repeat #12
  083E  781FB0     mov.w [0x0000++],[0x001e++]
45:                #asm
46:                    NOP
  0840  000000     nop
47:                #endasm
48:                }
  1E22  A921C8     bclr.b 0x01c8,#1
  1E24  AF09AC     btsc.b 0x09ac,#0
  1E26  A821C8     bset.b 0x01c8,#1
49:                
  1E28  060000     return
50:                
  0842  2001A0     mov.w #0x1a,0x0000
  0844  09000C     repeat #12
  0846  78104F     mov.w [--0x001e],[0x0000--]
  0848  78004F     mov.w [--0x001e],0x0000
  084A  F90036     pop.w 0x0036
  084C  F90042     pop.w 0x0042
  084E  064000     retfie
51:                void main()
52:                {	
  2E96  244440     mov.w #0x4444,0x0000
  2E98  8804A0     mov.w 0x0000,0x0094
  2E9A  244440     mov.w #0x4444,0x0000
  2E9C  8804B0     mov.w 0x0000,0x0096
  2E9E  244440     mov.w #0x4444,0x0000
  2EA0  8804C0     mov.w 0x0000,0x0098
  2EA2  274440     mov.w #0x7444,0x0000
  2EA4  8804D0     mov.w 0x0000,0x009a
  2EA6  244740     mov.w #0x4474,0x0000
  2EA8  8804F0     mov.w 0x0000,0x009e
  2EAA  A8E081     bset.b 0x0081,#7
  2EAC  280004     mov.w #0x8000,0x0008
  2EAE  8810B4     mov.w 0x0008,0x0216
  2EB0  204004     mov.w #0x400,0x0008
  2EB2  8810C4     mov.w 0x0008,0x0218
  2EB4  2000F4     mov.w #0xf,0x0008
  2EB6  8810F4     mov.w 0x0008,0x021e
  2EB8  EFA85A     setm.w 0x085a
  2EBA  EF285C     clr.w 0x085c
  2EBC  A90885     bclr.b 0x0885,#0
  2EBE  A92885     bclr.b 0x0885,#1
  2EC0  EF688F     clr.b 0x088f
  2EC2  EF68A5     clr.b 0x08a5
  2EC4  EF68AB     clr.b 0x08ab
  2EC6  EF68AF     clr.b 0x08af
  2EC8  A94885     bclr.b 0x0885,#2
  2ECA  B3C640     mov.b #0x64,0x0000
  2ECC  B7E8B3     mov.b 0x0000,0x08b3
  2ECE  B3C010     mov.b #0x1,0x0000
  2ED0  B7E8BE     mov.b 0x0000,0x08be
  2ED2  A96885     bclr.b 0x0885,#3
  2ED4  A88885     bset.b 0x0885,#4
  2ED6  B3C640     mov.b #0x64,0x0000
  2ED8  B7E8BF     mov.b 0x0000,0x08bf
  2EDA  B3C1E0     mov.b #0x1e,0x0000
  2EDC  B7E8E0     mov.b 0x0000,0x08e0
  2EDE  EF28E8     clr.w 0x08e8
  2EE0  EF28EA     clr.w 0x08ea
  2EE2  B3C070     mov.b #0x7,0x0000
  2EE4  B7E8E1     mov.b 0x0000,0x08e1
  2EE6  A9A885     bclr.b 0x0885,#5
  2EE8  A8C885     bset.b 0x0885,#6
  2EEA  EF295E     clr.w 0x095e
  2EEC  EF2960     clr.w 0x0960
  2EEE  EF2962     clr.w 0x0962
  2EF0  EF6927     clr.b 0x0927
  2EF2  A9E885     bclr.b 0x0885,#7
  2EF4  EF2964     clr.w 0x0964
  2EF6  A90966     bclr.b 0x0966,#0
  2EF8  A92966     bclr.b 0x0966,#1
  2EFA  A94966     bclr.b 0x0966,#2
  2EFC  A96966     bclr.b 0x0966,#3
  2EFE  EF296C     clr.w 0x096c
  2F00  EF296E     clr.w 0x096e
  2F02  A98966     bclr.b 0x0966,#4
  2F04  A9A966     bclr.b 0x0966,#5
  2F06  A9C966     bclr.b 0x0966,#6
  2F08  A9E966     bclr.b 0x0966,#7
  2F0A  EF297A     clr.w 0x097a
  2F0C  EFA2A8     setm.w 0x02a8
  2F0E  20B80F     mov.w #0xb80,0x001e
  2F10  20BFF0     mov.w #0xbff,0x0000
  2F12  B7A020     mov.w 0x0000,0x0020
  2F14  000000     nop
53:                    
54:                    
55:                    
56:                    setup_wdt(WDT_OFF);
  2FE4  A9A740     bclr.b 0x0740,#5
57:                  	
58:                    enable_interrupts(INT_RDA);
  2FE6  A8208D     bset.b 0x008d,#1
59:                   	enable_interrupts(INT_TBE);
  2FE8  A8408D     bset.b 0x008d,#2
60:                   	enable_interrupts(INT_ADC1);
  2FEA  A8608D     bset.b 0x008d,#3
61:                   	enable_interrupts(INT_CNI);
  2FEC  A8E08D     bset.b 0x008d,#7
62:                   	
63:                   	InitLoadControl();
  2FEE  020850     call 0x000850
64:                	InitRTCC();
  2FF2  020A28     call 0x000a28
65:                 	initUserInput();
  2FF6  020ACC     call 0x000acc
66:                 	initLumMonitor();
  2FFA  020ADC     call 0x000adc
67:                 	initLCD();
  2FFE  020B74     call 0x000b74
68:                	initChime();
  3002  020C22     call 0x000c22
69:                	initRGBLighting();
  3006  02150C     call 0x00150c
70:                    
71:                    setChime(true);
  300A  B3C010     mov.b #0x1,0x0000
  300C  B7E98E     mov.b 0x0000,0x098e
  300E  02153C     call 0x00153c
72:                    delay_ms(50);
  3012  200320     mov.w #0x32,0x0000
  3014  020AEC     call 0x000aec
73:                    setChime(false);
  3018  EF698E     clr.b 0x098e
  301A  02153C     call 0x00153c
74:                
75:                 	while(true)
76:                    {
77:                        AlarmStateMachine();
  301E  0218BC     call 0x0018bc
78:                        TransmitDataStreaming();
  3022  021BD8     call 0x001bd8
79:                	    //setChime(true); 
80:                	    
81:                 		encoderMonitoring();
  3026  021BEA     call 0x001bea
82:                 		readLumMonitor();
  302A  021C00     call 0x001c00
83:                		PDC1 = POSCNT*32;
  302E  800930     mov.w 0x0126,0x0000
  3030  DD0045     sl 0x0000,#5,0x0000
  3032  880EB0     mov.w 0x0000,0x01d6
84:                        
85:                		currentPOSCNT = POSCNT;
  3034  F80126     push.w 0x0126
  3036  F9085C     pop.w 0x085c
86:                
87:                #ifdef ENABLE_LCD_REFRESH
88:                		clearLCDLines();
  3038  020B4E     call 0x000b4e
89:                		sprintf(LCD_Line1,"%02u:%02u:%02u",CurrentTime.tm_hour,CurrentTime.tm_min,CurrentTime.tm_sec);
  303C  208C04     mov.w #0x8c0,0x0008
  303E  884BE4     mov.w 0x0008,0x097c
  3040  804960     mov.w 0x092c,0x0000
  3042  280024     mov.w #0x8002,0x0008
  3044  021C80     call 0x001c80
  3048  B3C3A0     mov.b #0x3a,0x0000
  304A  021C72     call 0x001c72
  304E  804950     mov.w 0x092a,0x0000
  3050  280024     mov.w #0x8002,0x0008
  3052  021C80     call 0x001c80
  3056  B3C3A0     mov.b #0x3a,0x0000
  3058  021C72     call 0x001c72
  305C  804940     mov.w 0x0928,0x0000
  305E  280024     mov.w #0x8002,0x0008
  3060  021C80     call 0x001c80
90:                		addSelector();
  3064  021D3C     call 0x001d3c
91:                		refreshLCD();
  3068  021D90     call 0x001d90
92:                #endif
93:                        
94:                        if (pushAck                              && 
95:                             (alarmData.AlarmState != ALARM_WAKE) &&
96:                             (enableLCD)) {
  306C  AE2966     btss.b 0x0966,#1
  306E  37000B     bra 0x003086
  3070  8043B4     mov.w 0x0876,0x0008
  3072  E12463     cp.b 0x0008,#3
  3074  320008     bra z, 0x003086
  3076  AE8885     btss.b 0x0885,#4
  3078  370006     bra 0x003086
97:                             pushAck = false;
  307A  A92966     bclr.b 0x0966,#1
98:                             alarmData.PulseWidthErr++;
  307C  EC286E     inc.w 0x086e
  307E  AF2042     btsc.b 0x0042,#1
  3080  EC2870     inc.w 0x0870
99:                             EditMenu();    
  3082  022D42     call 0x002d42
100:                       }
101:               		
102:               		//}
103:                		previousPOSCNT = currentPOSCNT;
  3086  F8085C     push.w 0x085c
  3088  F9085A     pop.w 0x085a
104:                		//delay_ms(500);
105:                      
106:               //       float intensity = 0.0;
107:               //       
108:               //       while (1) {
109:               //           
110:               //       
111:               //       for (intensity = 0.0 ; intensity < 0.99 ; intensity += 0.01) {
112:               //           SetLampIntensity(intensity);
113:               //           delay_ms(50);
114:               //       }
115:               //       
116:               //       for (intensity = 0.99 ; intensity > 0.01 ; intensity -= 0.01) {
117:               //           SetLampIntensity(intensity);
118:               //           delay_ms(50);
119:               //       }
120:               //       }
121:                       
122:                       IncreaseHue(&hsvColor);
  308A  208B84     mov.w #0x8b8,0x0008
  308C  884BF4     mov.w 0x0008,0x097e
  308E  022E72     call 0x002e72
123:                       HSVtoRGB(&hsvColor, &rgbColor);
  3092  208B84     mov.w #0x8b8,0x0008
  3094  884D64     mov.w 0x0008,0x09ac
  3096  208B44     mov.w #0x8b4,0x0008
  3098  884D74     mov.w 0x0008,0x09ae
  309A  021288     call 0x001288
124:                       delay_ms(10);
  309E  2000A0     mov.w #0xa,0x0000
  30A0  020AEC     call 0x000aec
125:                       
126:                       //UpdateRGB_Out(&rgbColor);
127:                      
128:                       //alarmData.DayOfTheWeek = CurrentTime.tm_wday;
129:                      
130:                       alarmData.MainLoops++;
  30A4  EC286A     inc.w 0x086a
  30A6  AF2042     btsc.b 0x0042,#1
  30A8  EC286C     inc.w 0x086c
131:                	}
  30AA  37FFB9     bra 0x00301e
132:               }
  30AC  37FFFF     bra 0x0030ac
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\main.h  --------------------------
1:                 #ifndef __MAIN__
2:                 #define __MAIN__
3:                 
4:                 #include <30F3011.h>
5:                 #define USE_UART_2
6:                 
7:                 #device *=16 ICD=TRUE
8:                 
9:                 #FUSES NOWDT                 	//No Watch Dog Timer
10:                #FUSES FRC_PLL16              	//Internal Fast RC oscillator with 16X PLL
11:                //#FUSES FRC                   	//Internal Fast RC Oscillator
12:                #FUSES NOCKSFSM              	//Clock Switching is disabled, fail Safe clock monitor is disabled
13:                #FUSES WPSB16                	//Watch Dog Timer PreScalar B 1:16
14:                #FUSES WPSA512               	//Watch Dog Timer PreScalar A 1:512
15:                #FUSES PUT64                 	//Power On Reset Timer value 64ms
16:                #FUSES NOBROWNOUT            	//No brownout reset 
17:                //#FUSES BORV27                	//Brownout reset at 2.7V
18:                #FUSES LPOL_HIGH             	//Low-Side Transistors Polarity is Active-High (PWM 0,2,4 and 6)
19:                								//PWM module low side output pins have active high output polar
20:                #FUSES HPOL_HIGH             	//High-Side Transistors Polarity is Active-High (PWM 1,3,5 and 7)
21:                								//PWM module high side output pins have active high output polarity
22:                #FUSES NOPWMPIN              	//PWM outputs drive active state upon Reset
23:                #FUSES MCLR                  	//Master Clear pin enabled
24:                #FUSES NOPROTECT             	//Code not protected from reading
25:                #FUSES NOWRT                 	//Program memory not write protected
26:                #FUSES NODEBUG               	//No Debug mode for ICD
27:                #FUSES NOCOE                 	//Device will reset into operational mode
28:                #FUSES ICSP1                 	//ICD uses PGC1/PGD1 pins
29:                
30:                #define  DSPIC30F_OSC  118662200     //29665550
31:                
32:                #use delay(clock= DSPIC30F_OSC)
  0AEC  E00000     cp0.w 0x0000
  0AEE  AF2042     btsc.b 0x0042,#1
  0AF0  370006     bra 0x000afe
  0AF2  0933DB     repeat #13275
  0AF4  000000     nop
  0AF6  093FFF     repeat #16383
  0AF8  000000     nop
  0AFA  E90000     dec.w 0x0000,0x0000
  0AFC  37FFF7     bra 0x000aec
  0AFE  060000     return
---  Z:\Users\aop007\Documents\Projets\DawnStar\dsPIC workspace\uart.c  --------------------------
1:                 #include "includes.h"
2:                 
3:                 #ifdef USE_UART_2
4:                 void transmitTLV(int8 *arrayToSend, int8 length)
5:                 {
6:                 	volatile int8 j = 0;
7:                 	putc(0xAA);
8:                 	for(j = 0 ; j < length ; j++)
9:                 	{
10:                		putc(arrayToSend[j]);
11:                	}
12:                	putc(0x55);
13:                }
14:                
15:                void transmitTLV(int8 *arrayToSend, int8 length, int8 tlvID)
16:                {
  1B86  781F85     mov.w 0x000a,[0x001e++]
  1B88  EF6986     clr.b 0x0986
17:                    volatile int8 j = 0;
18:                	putc(0xAA);	
  1B8A  B3CAA0     mov.b #0xaa,0x0000
  1B8C  AF2219     btsc.b 0x0219,#1
  1B8E  37FFFE     bra 0x001b8c
  1B90  B7E21A     mov.b 0x0000,0x021a
  1B92  EF621B     clr.b 0x021b
19:                    putc(tlvID);
  1B94  BFC985     mov.b 0x0985,0x0000
  1B96  AF2219     btsc.b 0x0219,#1
  1B98  37FFFE     bra 0x001b96
  1B9A  B7E21A     mov.b 0x0000,0x021a
  1B9C  EF621B     clr.b 0x021b
20:                    putc(length);
  1B9E  BFC984     mov.b 0x0984,0x0000
  1BA0  AF2219     btsc.b 0x0219,#1
  1BA2  37FFFE     bra 0x001ba0
  1BA4  B7E21A     mov.b 0x0000,0x021a
  1BA6  EF621B     clr.b 0x021b
21:                	for(j = 0 ; j < length ; j++)
  1BA8  EF6986     clr.b 0x0986
  1BAA  BFC986     mov.b 0x0986,0x0000
  1BAC  804C24     mov.w 0x0984,0x0008
  1BAE  E12400     cp.b 0x0008,0x0000
  1BB0  34000C     bra les, 0x001bca
22:                    {
23:                	    putc(arrayToSend[j]);
  1BB2  BFC986     mov.b 0x0986,0x0000
  1BB4  FB0000     se 0x0000,0x0000
  1BB6  804C14     mov.w 0x0982,0x0008
  1BB8  400004     add.w 0x0000,0x0008,0x0000
  1BBA  784290     mov.b [0x0000],0x000a
  1BBC  784005     mov.b 0x000a,0x0000
  1BBE  AF2219     btsc.b 0x0219,#1
  1BC0  37FFFE     bra 0x001bbe
  1BC2  B7E21A     mov.b 0x0000,0x021a
  1BC4  EF621B     clr.b 0x021b
24:                    }
  1BC6  EC6986     inc.b 0x0986
  1BC8  37FFF0     bra 0x001baa
25:                	putc(0x55);
  1BCA  B3C550     mov.b #0x55,0x0000
  1BCC  AF2219     btsc.b 0x0219,#1
  1BCE  37FFFE     bra 0x001bcc
  1BD0  B7E21A     mov.b 0x0000,0x021a
  1BD2  EF621B     clr.b 0x021b
26:                }
  1BD4  7802CF     mov.w [--0x001e],0x000a
  1BD6  060000     return
27:                
28:                void TransmitDataStreaming(void)
29:                {
30:                    transmitTLV((int8  *)&alarmData,
31:                                (int8   ) sizeof(ALARM_DATA),
32:                                (int8   ) ALARM_DATA_ID);
  1BD8  2085E0     mov.w #0x85e,0x0000
  1BDA  884C10     mov.w 0x0000,0x0982
  1BDC  B3C1A0     mov.b #0x1a,0x0000
  1BDE  B7E984     mov.b 0x0000,0x0984
  1BE0  B3C030     mov.b #0x3,0x0000
  1BE2  B7E985     mov.b 0x0000,0x0985
  1BE4  021B86     call 0x001b86
33:                }
  1BE8  060000     return
