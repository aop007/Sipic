{"ts":1350907864103,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"//\n//  core_24f_opcode.c\n//  Sipic\n//\n//  Created by Alexis Ouellet-Patenaude on 2012-10-06.\n//  Copyright (c) 2012 Alexis Ouellet-Patenaude. All rights reserved.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"core_24f_opcode.h\"\n\n\n\nvoid  Core_OPC_Stats (MEM  *p_mem)\n{\n    MEM_HDR     *p_mem_hdr;\n    CPU_INT16U   opc_ctr[256];\n    CPU_INT32U   mem_size;\n    OPCODE       opc;\n    OPCODE      *p_opc;\n    CPU_INT32U   ix;\n    \n    \n    memset(&opc_ctr[0], 0, sizeof(opc_ctr));\n    \n    p_mem_hdr = &p_mem->Hdr;\n    \n    while (p_mem_hdr->Next->Hdr.Index != 0) {\n        \n        mem_size = p_mem_hdr->Size;\n        p_opc    = p_mem->Ptr;\n        \n        for (ix = 0 ; ix < p_mem_hdr->Size ; ix++) {\n            opc = (*p_opc & 0x00FF0000) >> 16;\n            opc_ctr[opc]++;\n            p_opc++;\n        }\n        \n        p_mem     =  p_mem_hdr->Next;\n        p_mem_hdr = &p_mem->Hdr;\n    }\n    \n    printf(\"\\r\\nOPC STATS:\");\n    \n    for (ix = 0 ; ix < sizeof(opc_ctr) / sizeof (CPU_INT16U) ; ix++) {\n        if (ix % 16 == 0) {\n            printf(\"\\r\\n\");\n        }\n#if 0\n        printf(\"\\r\\n%#x = %d\", ix, opc_ctr[ix]);\n#else\n        printf(\"%d\\t\", opc_ctr[ix]);\n#endif\n    }\n}\n\nvoid  Core_NOP_00 (MEM         *p_mem_prom,\n                   MEM         *p_mem_data,\n                   CORE_24F    *p_core,\n                   CPU_INT32U   args,\n                   CORE_ERR    *p_err)\n{\n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_CALL_02            (MEM         *p_mem_prog,\n                               MEM         *p_mem_data,\n                               CORE_24F    *p_core,\n                               CPU_INT32U   args,\n                               CORE_ERR    *p_err)\n{\n    OPCODE   next_word;\n    MEM_ERR  mem_err;\n    \n    p_core->PC += 2;\n    \n    next_word   = Mem_Get(p_mem_prog, p_core->PC, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->PC += 2;\n    \n    Core_Push( p_core->PC & 0x00FFFF, p_core, p_mem_data, p_err);\n    \n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    Core_Push((p_core->PC & 0xFF0000) >> 16, p_core, p_mem_data, p_err);\n\n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    p_core->PC = (next_word & 0x00007F) << 16 |\n                 (args      & 0x00FFFE);\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_GOTO_04 (MEM         *p_mem_prog,\n                    MEM         *p_mem_data,\n                    CORE_24F    *p_core,\n                    CPU_INT32U   args,\n                    CORE_ERR    *p_err)\n{\n    MEM_ERR     mem_err;\n    OPCODE      next_word;\n    CPU_INT32U  next_PC;\n    \n    next_word = Mem_Get(p_mem_prog, p_core->PC + 2, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n            \n    next_PC   = ((next_word & 0x00007F) << 16) | (args & 0x00FFFE);\n    \n    p_core->PC = next_PC;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_RETURN_060  (MEM         *p_mem_prog,\n                       MEM         *p_mem_data,\n                       CORE_24F    *p_core,\n                       CPU_INT32U   args,\n                       CORE_ERR    *p_err)\n{\n    CPU_INT32U  word1;\n    CPU_INT32U  word2;\n    \n    word1 = Core_Pop(p_core, p_mem_data, p_err);\n    \n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    word2 = Core_Pop(p_core, p_mem_data, p_err);\n    \n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    p_core->PC = word1 << 16 | word2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_MOV_2 (MEM         *p_mem_prog,\n                  MEM         *p_mem_data,\n                  CORE_24F    *p_core,\n                  CPU_INT32U   args,\n                  CORE_ERR    *p_err)\n{\n    CPU_INT32U  literal;\n    CPU_INT32U  w_reg;\n    \n    \n    literal = (args & 0x0FFFF0) >> 4;\n    w_reg   =  args & 0x00000F;\n    \n    p_core->W[w_reg] = literal;\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_BRA_37       (MEM         *p_mem_prog,\n                        MEM         *p_mem_data,\n                        CORE_24F    *p_core,\n                        CPU_INT32U   args,\n                        CORE_ERR    *p_err)\n{\n    CPU_INT16U     slit;\n    CPU_INT16S  *p_slit;\n    CPU_INT32U   addr;\n    \n    slit = args;\n    \n    p_slit = (CPU_INT16S *)&slit;\n    \n    addr   = p_core->PC + 2 + 2 * (*p_slit);\n    \n    p_core->PC = addr;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_MATH_WS_WD   (MEM          *p_mem_prog,\n                        MEM          *p_mem_data,\n                        CORE_24F     *p_core,\n                        CPU_INT32U    args,\n                        CORE_MATH_OP  math_op,\n                        CORE_ERR     *p_err)\n{\n    CPU_INT32U  base_w_addr;                                    /* wwww */\n    CPU_INT32U  size_op;                                        /* B    */\n    CPU_INT32U  dst_addr_mode;                                  /* qqq  */\n    CPU_INT32U  dst_addr;                                       /* dddd */\n    CPU_INT32U  src_addr_mode;                                  /* ppp  */\n    CPU_INT32U  src_addr;                                       /* ssss */\n    CPU_INT32S  operand_1;\n    CPU_INT32S  operand_2;\n    CPU_INT32S  result;\n    CPU_INT32U  value_mask;\n    CPU_INT32S  addr_offset;\n    CPU_INT32S  value_temp;\n    MEM_ERR     mem_err;\n    \n    \n    base_w_addr   = (args & 0x078000) >> 15;\n    size_op       = (args & 0x004000) >> 12;\n    dst_addr_mode = (args & 0x003800) >> 11;\n    dst_addr      = (args & 0x000780) >>  7;\n    src_addr_mode = (args & 0x000070) >>  4;\n    src_addr      =  args & 0x00000F;\n    \n    if (size_op == 0u) {\n        addr_offset = 2;\n        value_mask  = 0xFFFF;\n    } else {\n        addr_offset = 1;\n        value_mask  = 0x00FF;\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n    }\n    \n    operand_1 = CPU_SignExt16(p_core->W[base_w_addr]);\n\n    switch (src_addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            operand_2 = p_core->W[src_addr] & value_mask;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            operand_2  = Mem_Get(p_mem_data, (p_core->W[src_addr] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_addr] & 0x0001) == 0x0001)) {\n                operand_2 >>= 8;\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            operand_2 = Mem_Get(p_mem_data, (p_core->W[src_addr] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_addr] & 0x0001) == 0x0001)) {\n                operand_2 >>= 8;\n            }\n            \n            p_core->W[src_addr] -= addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            operand_2 = Mem_Get(p_mem_data, (p_core->W[src_addr] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_addr] & 0x0001) == 0x0001)) {\n                operand_2 >>= 8;\n            }\n            \n            p_core->W[src_addr] += addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[src_addr] -= addr_offset;\n            \n            operand_2 = Mem_Get(p_mem_data, (p_core->W[src_addr] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_addr] & 0x0001) == 0x0001)) {\n                operand_2 >>= 8;\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[src_addr] += addr_offset;\n            \n            operand_2 = Mem_Get(p_mem_data, (p_core->W[src_addr] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_addr] & 0x0001) == 0x0001)) {\n                operand_2 >>= 8;\n            }\n            \n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n\n    switch (math_op) {\n        case CORE_MATH_OP_ADD:\n            result = operand_1 + operand_2;\n            break;\n            \n        case CORE_MATH_OP_SUB:\n            result = operand_1 - operand_2;\n            break;\n            \n        case CORE_MATH_OP_MUL:\n            result = operand_1 * operand_2;\n            break;\n            \n        case CORE_MATH_OP_DIV:\n            result = operand_1 / operand_2;\n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_MATH_OP;\n            return;\n    }\n    \n    \n    switch (dst_addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            p_core->W[dst_addr] &= ~(value_mask);\n            p_core->W[dst_addr] |=   result;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_addr], result, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_addr] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (result << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= result;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_addr], result, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_addr] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (result << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= result;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            p_core->W[dst_addr] -= addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_addr], result, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_addr] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (result << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= result;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            p_core->W[dst_addr] += addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[dst_addr] -= addr_offset;\n            \n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_addr], result, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_addr] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (result << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= result;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[dst_addr] += addr_offset;\n            \n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_addr], result, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_addr] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (result << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= result;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_addr] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;    \n}\n\nvoid Core_SUB_50006 (MEM         *p_mem_prog,\n                     MEM         *p_mem_data,\n                     CORE_24F    *p_core,\n                     CPU_INT32U   args,\n                     CORE_ERR    *p_err)\n{\n    CPU_INT32U  base_w;\n    CPU_INT32U  size_op;\n    CPU_INT32U  addr_mode;\n    CPU_INT32U  dest_w;\n    CPU_INT32U  lit_op;\n    CPU_INT32S  operand1;\n    CPU_INT32S  result;\n    CPU_INT32S  offset;\n    MEM_ERR     mem_err;\n\n    \n    base_w    = (args & 0x078000) >> 15;\n    size_op   = (args & 0x004000) >> 14;\n    addr_mode = (args & 0x003800) >> 11;\n    dest_w    = (args & 0x000780) >>  7;\n    lit_op    =  args & 0x00001F;\n    \n    if (size_op != 0) {\n        offset = 1;\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n    } else {\n        offset = 2;\n    }\n    \n    operand1 = CPU_SignExt16(p_core->W[base_w]);\n    \n    result   = operand1 - lit_op;\n    \n    switch (addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            p_core->W[dest_w] = result & 0xFFF;\n            break;\n\n        case CORE_OPC_ADDR_MODE_IND:\n            Mem_Set(p_mem_data, (p_core->[dest_w] & 0xFFFE), result & 0xFFFF, &mem_err);\n\n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            break;\n\n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            Mem_Set(p_mem_data, (p_core->[dest_w] & 0xFFFE), result & 0xFFFF, &mem_err);\n\n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n\n            p_core->[dest_w] -= offset;\n            break;\n\n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            Mem_Set(p_mem_data, (p_core->[dest_w] & 0xFFFE), result & 0xFFFF, &mem_err);\n\n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n\n            p_core->[dest_w] += offset;\n            break;\n\n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->[dest_w] -= offset;\n            Mem_Set(p_mem_data, (p_core->[dest_w] & 0xFFFE), result & 0xFFFF, &mem_err);\n\n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            break;\n\n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->[dest_w] += offset;\n            Mem_Set(p_mem_data, (p_core->[dest_w] & 0xFFFE), result & 0xFFFF, &mem_err);\n\n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            break;\n    \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n\n    /* Update Status Register */\n    if (((operand1 & 0x00000080) &&                              /* DC */\n         (result   & 0x00000080))) {\n        p_core->SR |=   CORE_SR_DC;\n    } else {\n        p_core->SR &= ~(CORE_SR_DC);\n    }\n    \n    if (result < 0) {                                          /* N */\n        p_core->SR |=   CORE_SR_N;\n    } else {\n        p_core->SR &= ~(CORE_SR_N);\n    }\n    \n    if ((operand1 <  0) &&                                       /* OV */\n        (result   >= 0)) {\n        p_core->SR |=   CORE_SR_OV;\n    } else {\n        p_core->SR &= ~(CORE_SR_OV);\n    }\n    \n    if (result == 0) {                                         /* Z */\n        p_core->SR |=   CORE_SR_Z;\n    } else {\n        p_core->SR &= ~(CORE_SR_Z);\n    }\n    \n    if (((operand1 & 0x00008000) &&                              /* C */\n         (result   & 0x00008000))) {\n        p_core->SR |=   CORE_SR_C;\n    } else {\n        p_core->SR &= ~(CORE_SR_C);\n    }\n\n    p_core->PC += 2;\n\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_MOV_WS_WD_78 (MEM         *p_mem_prog,\n                        MEM         *p_mem_data,\n                        CORE_24F    *p_core,\n                        CPU_INT32U   args,\n                        CORE_ERR    *p_err)\n{\n    CPU_INT32U  off_w;\n    CPU_INT32U  size_op;\n    CPU_INT32U  src_addr_mode;\n    CPU_INT32U  dst_addr_mode;\n    CPU_INT32U  src_w;\n    CPU_INT32U  dst_w;\n    CPU_INT32U  value;\n    CPU_INT32U  value_mask;\n    CPU_INT32U  value_temp;\n    CPU_INT08S  addr_offset;\n    MEM_ERR     mem_err;\n    \n    \n    \n    off_w         = (args & 0x078000) >> 15;\n    size_op       =  args & 0x004000;\n    dst_addr_mode = (args & 0x003800) >> 11;\n    dst_w         = (args & 0x000780) >>  7;\n    src_addr_mode = (args & 0x000070) >>  4;\n    src_w         =  args & 0x00000F;\n    \n    if (size_op == 0u) {\n        addr_offset = 2;\n        value_mask  = 0xFFFF;\n    } else {\n        addr_offset = 1;\n        value_mask  = 0x00FF;\n        //*p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        //return;\n    }\n    \n    switch (src_addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            value = p_core->W[src_w] & value_mask;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            value  = Mem_Get(p_mem_data, (p_core->W[src_w] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] & 0x0001) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            value = Mem_Get(p_mem_data, (p_core->W[src_w] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] & 0x0001) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            p_core->W[src_w] -= addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            value = Mem_Get(p_mem_data, (p_core->W[src_w] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] & 0x0001) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            p_core->W[src_w] += addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[src_w] -= addr_offset;\n            \n            value = Mem_Get(p_mem_data, (p_core->W[src_w] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] & 0x0001) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[src_w] += addr_offset;\n            \n            value = Mem_Get(p_mem_data, (p_core->W[src_w] & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] & 0x0001) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_OFFSET:\n            value = Mem_Get(p_mem_data, ((p_core->W[src_w] + p_core->W[off_w]) & 0xFFFE), &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n                return;\n            }\n            \n            if ((size_op != 0) &&\n                ((p_core->W[src_w] + p_core->W[off_w]) == 0x0001)) {\n                value >>= 8;\n            }\n            \n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n    \n    value &= value_mask;\n    \n    switch (dst_addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n                p_core->W[dst_w] &= ~(value_mask);\n                p_core->W[dst_w] |=   value;            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_w] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_w] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_w] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_w] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_w] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_w] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            p_core->W[dst_w] -= addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_w] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_w] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_w] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            \n            p_core->W[dst_w] += addr_offset;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[dst_w] -= addr_offset;\n            \n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_w] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_w] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_w] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[dst_w] += addr_offset;\n            \n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, (p_core->W[dst_w] & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if ((p_core->W[dst_w] & 0x0001) == 0x0001) {\n                    value_temp &= 0x00FF;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0xFF00;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, (p_core->W[dst_w] & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            break;\n            \n        case CORE_OPC_ADDR_MODE_OFFSET:\n            \n            if (size_op == 0) {\n                Mem_Set(p_mem_data, p_core->W[dst_w] + p_core->W[off_w], value, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n            } else {\n                value_temp = Mem_Get(p_mem_data, ((p_core->W[dst_w] + p_core->W[off_w]) & 0xFFFE), &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n                \n                if (((p_core->W[dst_w] + p_core->W[off_w]) & 0x0001) == 0x0001) {\n                    value_temp &= 0xFF00;\n                    value_temp |= (value << 8);\n                } else {\n                    value_temp &= 0x00FF;\n                    value_temp |= value;\n                }\n                Mem_Set(p_mem_data, ((p_core->W[dst_w] + p_core->W[off_w]) & 0xFFFE), value_temp, &mem_err);\n                \n                if (mem_err != MEM_ERR_NONE) {\n                    *p_err = CORE_ERR_INVALID_MEM;\n                    return;\n                }\n            }\n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_MOV_M_W_80 (MEM         *p_mem_prog,\n                       MEM         *p_mem_data,\n                       CORE_24F    *p_core,\n                       CPU_INT32U   args,\n                       CORE_ERR    *p_err)\n{\n    CPU_INT32U  addr;\n    CPU_INT32U  value;\n    CPU_INT32U  w_reg;\n    MEM_ERR     mem_err;\n\n    addr  = (args & 0x07FFF0) >> 3;\n    w_reg = (args & 0x00000F);\n    \n    value = Mem_Get(p_mem_data, addr, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->W[w_reg] = value;\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_MOV_W_M_88 (MEM         *p_mem_prog,\n                       MEM         *p_mem_data,\n                       CORE_24F    *p_core,\n                       CPU_INT32U   args,\n                       CORE_ERR    *p_err)\n{\n    CPU_INT32U  addr;\n    CPU_INT32U  value;\n    CPU_INT32U  w_reg;\n    MEM_ERR     mem_err;\n    \n    addr  = (args & 0x07FFF0) >> 3;\n    w_reg = (args & 0x00000F);\n    \n    value = p_core->W[w_reg];\n\n    Mem_Set(p_mem_data, addr, value, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\n\nvoid  Core_BSET_W_A0 (MEM         *p_mem_prog,\n                      MEM         *p_mem_data,\n                      CORE_24F    *p_core,\n                      CPU_INT32U   args,\n                      CORE_ERR    *p_err)\n{\n    printf(\"\\r\\nCore_BSET_W_A0 Unimplemented\");\n    *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n}\n\nvoid  Core_BSET_M_A8 (MEM         *p_mem_prog,\n                      MEM         *p_mem_data,\n                      CORE_24F    *p_core,\n                      CPU_INT32U   args,\n                      CORE_ERR    *p_err)\n{\n    CPU_INT32U  addr;\n    CPU_INT16U  bit;\n    MEM_ERR     mem_err;\n    CPU_INT32U  value;\n    \n    bit  = ((args & 0x00E000) >> 12) |\n            (args & 0x000001);\n    \n    addr =  (args & 0x001FFE) >> 1;\n    \n    value = Mem_Get(p_mem_data, addr, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    value |= (1 << bit);\n    \n    Mem_Set(p_mem_data, addr, value, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_BCLR_M_A9 (MEM         *p_mem_prog,\n                      MEM         *p_mem_data,\n                      CORE_24F    *p_core,\n                      CPU_INT32U   args,\n                      CORE_ERR    *p_err)\n{\n    CPU_INT32U  value;\n    CPU_INT32U  addr;\n    CPU_INT32U  bit;\n    MEM_ERR     mem_err;\n    \n    addr  = (args & 0x001FFE) >>  1;\n    bit   = (args & 0x00E000) >> 12 |\n            (args & 0x000001);\n    \n    value = Mem_Get(p_mem_data, addr, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n\n    value &= ~(1 << bit);\n    \n    Mem_Set(p_mem_data, addr, value, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_BTSC_AF (MEM         *p_mem_prog,\n                    MEM         *p_mem_data,\n                    CORE_24F    *p_core,\n                    CPU_INT32U   args,\n                    CORE_ERR    *p_err)\n{\n    CPU_INT32U  value;\n    CPU_INT32U  addr;\n    CPU_INT32U  bit;\n    CPU_INT32U  opc_words;\n    CPU_INT32U  size_op;\n    OPCODE      opc;\n    MEM_ERR     mem_err;\n    \n    addr    =  args & 0x001FFE;\n    size_op =  args & 0x000001;\n    bit     =  1 << ((args & 0x00E000) >> 12);\n    \n    if (size_op == 1) {\n        bit <<= 8;\n    }\n    \n    value   = Mem_Get(p_mem_data, addr, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    if ((value & bit) == 0u) {\n        \n        \n        opc = Mem_Get(p_mem_prog, p_core->PC, &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n#if 1\n        opc_words = Core_OPC_Words(opc);\n        \n        switch (opc_words) {\n            case 1:\n            case 2:\n                p_core->PC += 2 * opc_words;\n                break;\n                \n            default:\n                *p_err = CORE_ERR_INVALID_OPC_CYCLE;\n                return;\n        }\n#else\n        p_core->PC += 2;\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n#endif\n    }\n    \n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_SETM_MOV_8BL_WN_B3C (MEM         *p_mem_prog,\n                               MEM         *p_mem_data,\n                               CORE_24F    *p_core,\n                               CPU_INT32U   args,\n                               CORE_ERR    *p_err)\n{\n    CPU_INT32U  value;\n    CPU_INT32U  w_reg;\n    \n    \n    value = args & 0x000FF0;\n    w_reg = args & 0x00000F;\n    \n    p_core->W[w_reg] &= 0xFF00;\n    p_core->W[w_reg] |= value;\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_SETM_MOV_8BL_WN_B7A (MEM         *p_mem_prog,\n                               MEM         *p_mem_data,\n                               CORE_24F    *p_core,\n                               CPU_INT32U   args,\n                               CORE_ERR    *p_err)\n{\n    CPU_INT32U  size_op;\n    CPU_INT32U  addr;\n    CPU_INT32U  val;\n    CPU_INT32U  reg_val;\n    CPU_INT32U  mask;\n    MEM_ERR     mem_err;\n    \n    size_op = args & 0x004000;\n    addr    = args & 0x001FFF;\n    \n    if (size_op == 0u) {\n        val = p_core->W[0] & 0xFFFF;\n    } else {\n        val = p_core->W[0] & 0x00FF;\n    }\n    \n    \n    reg_val = Mem_Get(p_mem_data, (addr & 0x001FFE), &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    if ((addr & 0x000001) == 1) {\n        mask  = 0x00FF;\n        val <<= 8;\n        val  &= ~(mask);\n    } else {\n        mask  = 0xFFFF;\n    }\n    \n    reg_val &= mask;\n    reg_val |= val;\n    \n    Mem_Set(p_mem_data, (addr & 0x001FFE), reg_val, &mem_err);\n    \n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_ADD_B40     (MEM         *p_mem_prog,\n                       MEM         *p_mem_data,\n                       CORE_24F    *p_core,\n                       CPU_INT32U   args,\n                       CORE_ERR    *p_err)\n{\n    CPU_INT32U  size_op;\n    CPU_INT32U  dest;\n    CPU_INT32U  addr;\n    CPU_INT32S  value_0;\n    CPU_INT32S  value_1;\n    CPU_INT32S  val_wreg;\n    MEM_ERR     mem_err;\n    \n    \n    size_op = args & 0x004000;\n    dest    = args & 0x002000;\n    addr    = args & 0x001FFF;\n    \n    if (size_op != 0) {\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n    }\n    \n    value_0 = Mem_Get(p_mem_data, (addr & 0xFFFE), &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    value_0  = CPU_SignExt16(value_0);\n    val_wreg = CPU_SignExt16(p_core->W[0]);\n    \n    value_1 = value_0 + val_wreg;\n    \n    if (dest == 0) {\n        p_core->W[0] = value_1 & 0xFFFF;\n    } else {\n        Mem_Set(p_mem_data, (addr & 0xFFFE), (value_1 & 0xFFFF), &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n    }\n    \n    /* Update Status Register */\n    if (((value_0 & 0x00000080) &&                              /* DC */\n         (value_1 & 0x00000080))) {\n        p_core->SR |=   CORE_SR_DC;\n    } else {\n        p_core->SR &= ~(CORE_SR_DC);\n    }\n    \n    if (value_1 < 0) {                                          /* N */\n        p_core->SR |=   CORE_SR_N;\n    } else {\n        p_core->SR &= ~(CORE_SR_N);\n    }\n    \n    if ((value_0 >= 0) &&                                       /* OV */\n        (value_1 <  0)) {\n        p_core->SR |=   CORE_SR_OV;\n    } else {\n        p_core->SR &= ~(CORE_SR_OV);\n    }\n    \n    if (value_1 == 0) {                                         /* Z */\n        p_core->SR |=   CORE_SR_Z;\n    } else {\n        p_core->SR &= ~(CORE_SR_Z);\n    }\n    \n    if (((value_0 & 0x00008000) &&                              /* C */\n         (value_1 & 0x00008000))) {\n        p_core->SR |=   CORE_SR_C;\n    } else {\n        p_core->SR &= ~(CORE_SR_C);\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_MUL_SS_B98 (MEM         *p_mem_prog,\n                      MEM         *p_mem_data,\n                      CORE_24F    *p_core,\n                      CPU_INT32U   args,\n                      CORE_ERR    *p_err)\n{\n    CPU_INT32U  base_reg;\n    CPU_INT32U  dest_reg;\n    CPU_INT32U  addr_mode;\n    CPU_INT32U  srce_reg;\n    \n    CPU_INT32S  operand0;\n    CPU_INT32S  operand1;\n    CPU_INT32S  result;\n    \n    MEM_ERR     mem_err;\n    \n\n    \n    base_reg  = (args & 0x007800) >> 11;\n    dest_reg  = (args & 0x000780) >>  7;\n    addr_mode = (args & 0x000070) >>  4;\n    srce_reg  =  args & 0x00000F;\n    \n    operand0 = CPU_SignExt16(p_core->W[base_reg]);\n    \n    switch (addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            operand1 = p_core->W[srce_reg];\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            operand1 = Mem_Get(p_mem_data, p_core->W[srce_reg], &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n            }\n            break;            \n            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            operand1 = Mem_Get(p_mem_data, p_core->W[srce_reg], &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n            }\n            \n            p_core->W[srce_reg] -= 2;\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            operand1 = Mem_Get(p_mem_data, p_core->W[srce_reg], &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n            }\n            \n            p_core->W[srce_reg] += 2;\n            break;\n        \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[srce_reg] -= 2;\n            \n            operand1 = Mem_Get(p_mem_data, p_core->W[srce_reg], &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n            }\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[srce_reg] += 2;\n            \n            operand1 = Mem_Get(p_mem_data, p_core->W[srce_reg], &mem_err);\n            \n            if (mem_err != MEM_ERR_NONE) {\n                *p_err = CORE_ERR_INVALID_MEM;\n            }\n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n    \n    result = operand0 * operand1;\n    \n    p_core->W[dest_reg]     = (result & 0x0000FFFF);\n    p_core->W[dest_reg + 1] = (result & 0xFFFF0000);\n    p_core->PC += 2;\n    \n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_MOV_BF8 (MEM         *p_mem_prog,\n                   MEM         *p_mem_data,\n                   CORE_24F    *p_core,\n                   CPU_INT32U   args,\n                   CORE_ERR    *p_err)\n{\n    CPU_INT32U  size_op;\n    CPU_INT32U  dest;\n    CPU_INT32U  addr;\n    CPU_INT32S  value_0;\n    CPU_INT32S  val_wreg;\n    MEM_ERR     mem_err;\n    \n    \n    size_op = args & 0x004000;\n    dest    = args & 0x002000;\n    addr    = args & 0x001FFF;\n    \n#if 0\n    if (size_op != 0) {\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n    }\n#endif\n    \n    value_0 = Mem_Get(p_mem_data, (addr & 0xFFFE), &mem_err);\n    value_0 = CPU_SignExt16(value_0);\n    \n    if (dest == 0) {\n        if (size_op == 0) {\n            p_core->W[0] = value_0;\n        } else {\n            val_wreg = p_core->W[0];\n            \n            if ((addr & 0x0001) == 0) {\n                value_0 = (val_wreg & 0xFF00) | (value_0 & 0x00FF);\n                value_0 = CPU_SignExt16(value_0);\n                p_core->W[0] = value_0;\n            } else {\n                value_0 = (val_wreg & 0xFF00) | ((value_0 & 0xFF00) >> 8);\n                value_0 = CPU_SignExt16(value_0);\n                p_core->W[0] = value_0;\n            }\n        }\n    } else {\n        // Nothing to do, f -> f.\n        // Just update N & Z flags.\n    }\n    \n    if (value_0 < 0) {                                          /* N */\n        p_core->SR |=   CORE_SR_N;\n    } else {\n        p_core->SR &= ~(CORE_SR_N);\n    }\n    \n    if (value_0 == 0) {                                         /* Z */\n        p_core->SR |=   CORE_SR_Z;\n    } else {\n        p_core->SR &= ~(CORE_SR_Z);\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_SETM_WS_EB8 (MEM         *p_mem_prog,\n                       MEM         *p_mem_data,\n                       CORE_24F    *p_core,\n                       CPU_INT32U   args,\n                       CORE_ERR    *p_err)\n{\n    printf(\"\\r\\nCore_SETM_WS_EB8 Unimplemented\");\n    *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n}\n\nvoid Core_INC_EC0 (MEM         *p_mem_prog,\n                   MEM         *p_mem_data,\n                   CORE_24F    *p_core,\n                   CPU_INT32U   args,\n                   CORE_ERR    *p_err)\n{\n    CPU_INT32U  addr;\n    CPU_INT32U  size_op;\n    CPU_INT32U  dest_sel;\n    CPU_INT32S  value_0;\n    CPU_INT32S  value_1;\n    MEM_ERR     mem_err;\n    \n    addr     = args & 0x001FFF;\n    size_op  = args & 0x004000;\n    dest_sel = args & 0x002000;\n    \n    if (size_op != 0) {\n        *p_err = CORE_ERR_OPC_UNSUPORTED_YET;\n        return;\n    }\n    \n    value_0 = Mem_Get(p_mem_data, addr, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    value_0 = CPU_SignExt16(value_0);\n    \n    value_1 = value_0 + 1;\n    \n                                                                /* Update Status Register */\n    if (((value_0 & 0x00000080) &&                              /* DC */\n         (value_1 & 0x00000080))) {\n        p_core->SR |=   CORE_SR_DC;\n    } else {\n        p_core->SR &= ~(CORE_SR_DC);\n    }\n    \n    if (value_1 < 0) {                                          /* N */\n        p_core->SR |=   CORE_SR_N;\n    } else {\n        p_core->SR &= ~(CORE_SR_N);\n    }\n    \n    if ((value_0 >= 0) &&                                       /* OV */\n        (value_1 <  0)) {\n        p_core->SR |=   CORE_SR_OV;\n    } else {\n        p_core->SR &= ~(CORE_SR_OV);\n    }\n\n    if (value_1 == 0) {                                         /* Z */\n        p_core->SR |=   CORE_SR_Z;\n    } else {\n        p_core->SR &= ~(CORE_SR_Z);\n    }\n        \n    if (((value_0 & 0x00008000) &&                              /* C */\n         (value_1 & 0x00008000))) {\n        p_core->SR |=   CORE_SR_C;\n    } else {\n        p_core->SR &= ~(CORE_SR_C);\n    }\n\n    if (dest_sel == 0) {\n        p_core->W[0] = value_1;\n    } else {\n        Mem_Set(p_mem_data, addr, value_1, &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n    }\n    \n    p_core->PC += 2;\n}\n\n\nvoid Core_SETM_M_W0_EF8 (MEM         *p_mem_prog,\n                         MEM         *p_mem_data,\n                         CORE_24F    *p_core,\n                         CPU_INT32U   args,\n                         CORE_ERR    *p_err)\n{\n    CPU_INT32U  size_op;\n    CPU_INT32U  dest;\n    CPU_INT32U  addr;\n    CPU_INT32U  val;\n    CPU_INT32U  reg_val;\n    MEM_ERR     mem_err;\n    \n    size_op = args & 0x004000;\n    dest    = args & 0x002000;\n    addr    = args & 0x001FFF;\n    \n    if (size_op == 0u) {\n        val = 0xFFFF;\n    } else {\n        val = 0xFF;\n    }\n    \n    if (dest == 0u) {\n        p_core->W[0] |= val;\n    } else {\n        if ((DEF_FIELD_IS_SET(addr,    0x000001)  &&\n             DEF_FIELD_IS_SET(size_op, 0x004000))) {\n            \n        }\n        \n        reg_val = Mem_Get(p_mem_data, (addr & 0x001FFE), &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n        \n        reg_val |= val;\n        \n        Mem_Set(p_mem_data, (addr & 0x001FFE), reg_val, &mem_err);\n\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid Core_CLR_M_W0_EF0 (MEM         *p_mem_prog,\n                        MEM         *p_mem_data,\n                        CORE_24F    *p_core,\n                        CPU_INT32U   args,\n                        CORE_ERR    *p_err)\n{\n    CPU_INT32U  size_op;\n    CPU_INT32U  dest;\n    CPU_INT32U  addr;\n    CPU_INT32U  val;\n    CPU_INT32U  reg_val;\n    MEM_ERR     mem_err;\n    \n    size_op = args & 0x004000;\n    dest    = args & 0x002000;\n    addr    = args & 0x001FFF;\n    \n    if (size_op == 0u) {\n        val = 0xFFFF;\n    } else {\n        val = 0xFF;\n    }\n    \n    if (dest == 0u) {\n        p_core->W[0] &= ~(val);\n    } else {\n        if ((DEF_FIELD_IS_SET(addr,    0x000001)  &&\n             DEF_FIELD_IS_SET(size_op, 0x004000))) {\n            \n        }\n        \n        reg_val = Mem_Get(p_mem_data, (addr & 0x001FFE), &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n        \n        reg_val &= ~(val);\n        \n        Mem_Set(p_mem_data, (addr & 0x001FFE), reg_val, &mem_err);\n        \n        if (mem_err != MEM_ERR_NONE) {\n            *p_err = CORE_ERR_INVALID_MEM;\n            return;\n        }\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\nvoid  Core_PUSH_F8 (MEM         *p_mem_prog,\n                    MEM         *p_mem_data,\n                    CORE_24F    *p_core,\n                    CPU_INT32U   args,\n                    CORE_ERR    *p_err)\n{\n    CPU_INT32U  val;\n    MEM_ERR     mem_err;\n    \n    val = Mem_Get(p_mem_data, args, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    Core_Push(val, p_core, p_mem_data, p_err);\n    \n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    p_core->PC += 2;\n}\n\nvoid  Core_POP_F9 (MEM         *p_mem_prog,\n                   MEM         *p_mem_data,\n                   CORE_24F    *p_core,\n                   CPU_INT32U   args,\n                   CORE_ERR    *p_err)\n{\n    CPU_INT32U  val;\n    MEM_ERR     mem_err;\n    \n    val = Core_Pop(p_core, p_mem_data, p_err);\n    \n    if (*p_err != CORE_ERR_NONE) {\n        return;\n    }\n    \n    Mem_Set(p_mem_data, args, val, &mem_err);\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    p_core->PC += 2;\n}\n\nvoid Core_SE_FB00       (MEM         *p_mem_prog,\n                         MEM         *p_mem_data,\n                         CORE_24F    *p_core,\n                         CPU_INT32U   args,\n                         CORE_ERR    *p_err)\n{\n    CPU_INT32U  w_dst;\n    CPU_INT32U  w_src;\n    CPU_INT32U  addr_mode;\n    CPU_INT32S  value;\n    MEM_ERR     mem_err;\n    \n    \n    w_dst     = (args & 0x000780) >> 7;\n    addr_mode = (args & 0x000070) >> 4;\n    w_src     =  args & 0x00000F;\n    \n    mem_err = MEM_ERR_NONE;\n    \n    switch (addr_mode) {\n        case CORE_OPC_ADDR_MODE_DIR:\n            value = (p_core->W[w_src] & 0x00FF);\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND:\n            value = Mem_Get(p_mem_data, (p_core->W[w_src] & 0xFFFE), &mem_err);\n            \n            if ((p_core->W[w_src] & 0x0001) == 0) {\n                value  &= 0x00FF;\n            } else {\n                value  &= 0xFF00;\n                value >>= 8;\n            }\n            break;\n                            \n        case CORE_OPC_ADDR_MODE_IND_POS_DEC:\n            value = Mem_Get(p_mem_data, (p_core->W[w_src] & 0xFFFE), &mem_err);\n            \n            if ((p_core->W[w_src] & 0x0001) == 0) {\n                value  &= 0x00FF;\n            } else {\n                value  &= 0xFF00;\n                value >>= 8;\n            }\n            \n            p_core->W[w_src]--;\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_POS_INC:\n            value = Mem_Get(p_mem_data, (p_core->W[w_src] & 0xFFFE), &mem_err);\n            \n            if ((p_core->W[w_src] & 0x0001) == 0) {\n                value  &= 0x00FF;\n            } else {\n                value  &= 0xFF00;\n                value >>= 8;\n            }\n            \n            p_core->W[w_src]++;\n            \n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_DEC:\n            p_core->W[w_src]--;\n            \n            value = Mem_Get(p_mem_data, (p_core->W[w_src] & 0xFFFE), &mem_err);\n            \n            if ((p_core->W[w_src] & 0x0001) == 0) {\n                value  &= 0x00FF;\n            } else {\n                value  &= 0xFF00;\n                value >>= 8;\n            }\n            break;\n            \n        case CORE_OPC_ADDR_MODE_IND_PRE_INC:\n            p_core->W[w_src]++;\n            \n            value = Mem_Get(p_mem_data, (p_core->W[w_src] & 0xFFFE), &mem_err);\n            \n            if ((p_core->W[w_src] & 0x0001) == 0) {\n                value  &= 0x00FF;\n            } else {\n                value  &= 0xFF00;\n                value >>= 8;\n            }\n            break;\n            \n        default:\n            *p_err = CORE_ERR_INVALID_OPC_ARG;\n            return;\n    }\n    \n    if (mem_err != MEM_ERR_NONE) {\n        *p_err = CORE_ERR_INVALID_MEM;\n        return;\n    }\n    \n    value = CPU_SignExt08(value);\n    \n    p_core->W[w_dst] = value;\n    \n    if (value < 0) {                                            /* N & C */\n        p_core->SR |=   CORE_SR_N;\n        p_core->SR &= ~(CORE_SR_C);\n    } else {\n        p_core->SR &= ~(CORE_SR_N);\n        p_core->SR |=   CORE_SR_C;\n    }\n    \n    \n    if (value == 0) {                                           /* Z */\n        p_core->SR |=   CORE_SR_Z;\n    } else {\n        p_core->SR &= ~(CORE_SR_Z);\n    }\n    \n    p_core->PC += 2;\n    *p_err = CORE_ERR_NONE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":54147}]],"length":54147}
